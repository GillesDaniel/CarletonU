require({cache:{
'ibm/tivoli/fwm/mxmap/impl/boundingbox/BingBoundingBox':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_BoundingBox"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

dojo.require("ibm.tivoli.fwm.mxmap._BoundingBox");
dojo.provide("ibm.tivoli.fwm.mxmap.impl.boundingbox.BingBoundingBox");

dojo.declare("ibm.tivoli.fwm.mxmap.impl.boundingbox.BingBoundingBox", ibm.tivoli.fwm.mxmap._BoundingBox, {
	
	_init: function(swLat, swLon, neLat, neLon)
	{
		// FIXME throw error if box bigger than world
		// alert('new bbox ' + swlat + ',' + swlon + ',' + nelat + ',' + nelon);
		this.sw = new ibm.tivoli.fwm.mxmap.impl.point.BingLatLonPoint({lat: swLat, lon: swLon, lng: swLon});
		this.ne = new ibm.tivoli.fwm.mxmap.impl.point.BingLatLonPoint({lat: neLat, lon: neLon, lng: neLon});
	}
});

});

},
'ibm/tivoli/fwm/mxmap/impl/boundingbox/GmapsBoundingBox':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_BoundingBox"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

dojo.require("ibm.tivoli.fwm.mxmap._BoundingBox");
dojo.provide("ibm.tivoli.fwm.mxmap.impl.boundingbox.GmapsBoundingBox");

dojo.declare("ibm.tivoli.fwm.mxmap.impl.boundingbox.GmapsBoundingBox", ibm.tivoli.fwm.mxmap._BoundingBox, {
	
	_init: function(swLat, swLon, neLat, neLon)
	{
		// FIXME throw error if box bigger than world
		// alert('new bbox ' + swlat + ',' + swlon + ',' + nelat + ',' + nelon);
		this.sw = new ibm.tivoli.fwm.mxmap.impl.point.GmapsLatLonPoint({lat: swLat, lon: swLon, lng: swLon});
		this.ne = new ibm.tivoli.fwm.mxmap.impl.point.GmapsLatLonPoint({lat: neLat, lon: neLon, lng: neLon});
	}
});

});

},
'ibm/tivoli/fwm/mxmap/routing/itinerary/Step':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Base,dijit/_Widget,dijit/_Templated,ibm/tivoli/fwm/mxmap/routing/Router"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.routing.itinerary.Step");
dojo.require("ibm.tivoli.fwm.mxmap._Base");
dojo.require("dijit._Widget");
dojo.require("dijit._Templated");
dojo.require("ibm.tivoli.fwm.mxmap.routing.Router");

/**
 * 
 * 
 */

dojo.declare("ibm.tivoli.fwm.mxmap.routing.itinerary.Step", [ dijit._Widget, dijit._Templated, ibm.tivoli.fwm.mxmap._Base ], {
	templateString: dojo.cache("ibm.tivoli.fwm.mxmap", "templates/Step.html", "<div  style=\"width:100%;border-top:1px solid #F0F0F0;margin-bottom:3px;\" data-dojo-attach-event=\"ondijitclick:_onClick,onmouseenter:_onHover,onmouseleave:_onUnhover\" >\n\n<div  style=\"padding:10px;\">\n<span data-dojo-attach-point=\"stepInfoNode\"></span><div data-dojo-attach-point=\"distanceInfoNode\" style=\"float:right;\"></div></div>\n</div>"),
	distanceUnit:0,
	distance:0,
	constructor: function(params)
	{
		dojo.mixin(this, params);
	},
	postCreate: function()
	{
		this.stepInfoNode.innerHTML = "<b>" + this.position + ".  </b>" + this.info;
		
		this.distanceInfoNode.innerHTML = ibm.tivoli.fwm.mxmap.routing.DistanceUnit.formatDistance(this.distance,this.distanceUnit);
	},
	_onClick: function(evt)
	{
		console.log("Clicked on step " , this);
		this.map.setCenter(this.location);
		this.closeDialog();
		
	},
	_onHover: function(evt)
	{
		// console.log("e")
		// dojo.style(this.domNode,"border","1px solid black");
	},
	_onUnhover: function(evt)
	{
		// console.log("a")
		// dojo.style(this.domNode,"border","0px solid black");
	}
});

});

},
'dijit/form/TextBox':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie") has("mozilla")
	"./_FormValueWidget",
	"./_TextBoxMixin",
	"dojo/text!./templates/TextBox.html",
	"../main"	// to export dijit._setSelectionRange, remove in 2.0
], function(declare, domConstruct, domStyle, kernel, lang, on, has,
			_FormValueWidget, _TextBoxMixin, template, dijit){

	// module:
	//		dijit/form/TextBox

	var TextBox = declare("dijit.form.TextBox" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormValueWidget, _TextBoxMixin], {
		// summary:
		//		A base class for textbox form inputs

		templateString: template,
		_singleNodeTemplate: '<input class="dijit dijitReset dijitLeft dijitInputField" data-dojo-attach-point="textbox,focusNode" autocomplete="off" type="${type}" ${!nameAttrSetting} />',

		_buttonInputDisabled: has("ie") ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events

		baseClass: "dijitTextBox",

		postMixInProperties: function(){
			var type = this.type.toLowerCase();
			if(this.templateString && this.templateString.toLowerCase() == "input" || ((type == "hidden" || type == "file") && this.templateString == this.constructor.prototype.templateString)){
				this.templateString = this._singleNodeTemplate;
			}
			this.inherited(arguments);
		},

		postCreate: function(){
			this.inherited(arguments);

			if(has("ie") < 9){
				// IE INPUT tag fontFamily has to be set directly using STYLE
				// the defer gives IE a chance to render the TextBox and to deal with font inheritance
				this.defer(function(){
					try{
						var s = domStyle.getComputedStyle(this.domNode); // can throw an exception if widget is immediately destroyed
						if(s){
							var ff = s.fontFamily;
							if(ff){
								var inputs = this.domNode.getElementsByTagName("INPUT");
								if(inputs){
									for(var i=0; i < inputs.length; i++){
										inputs[i].style.fontFamily = ff;
									}
								}
							}
						}
					}catch(e){/*when used in a Dialog, and this is called before the dialog is
					 shown, s.fontFamily would trigger "Invalid Argument" error.*/}
				});
			}
		},

		_setPlaceHolderAttr: function(v){
			this._set("placeHolder", v);
			if(!this._phspan){
				this._attachPoints.push('_phspan');
				this._phspan = domConstruct.create('span', {
					// dijitInputField class gives placeHolder same padding as the input field
					// parent node already has dijitInputField class but it doesn't affect this <span>
					// since it's position: absolute.
					className: 'dijitPlaceHolder dijitInputField'
				}, this.textbox, 'after');
				this.own(
					on(this._phspan, "mousedown", function(evt){ evt.preventDefault(); }),
					on(this._phspan, "touchend, pointerup, MSPointerUp", lang.hitch(this, function(){
						// If the user clicks placeholder rather than the <input>, need programmatic focus.  Normally this
						// is done in _FormWidgetMixin._onFocus() but after [30663] it's done on a delay, which is ineffective.
						this.focus();
					}))
				);
			}
			this._phspan.innerHTML="";
			this._phspan.appendChild(this._phspan.ownerDocument.createTextNode(v));
			this._updatePlaceHolder();
		},

		_onInput: function(/*Event*/ evt){
			// summary:
			//		Called AFTER the input event has happened
			//		See if the placeHolder text should be removed or added while editing.
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		_updatePlaceHolder: function(){
			if(this._phspan){
				this._phspan.style.display = (this.placeHolder && !this.textbox.value) ? "" : "none";
			}
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.  Use get('displayedValue') instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use get('displayedValue') instead.", "", "2.0");
			return this.get('displayedValue');
		},

		setDisplayedValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('displayedValue', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use set('displayedValue', ...) instead.", "", "2.0");
			this.set('displayedValue', value);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();

			if(has("mozilla")){
				if(this.selectOnClick){
					// clear selection so that the next mouse click doesn't reselect
					this.textbox.selectionStart = this.textbox.selectionEnd = undefined;
				}
			}
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();
		}
	});

	if(has("ie") < 9){
		TextBox.prototype._isTextSelected = function(){
			var range = this.ownerDocument.selection.createRange();
			var parent = range.parentElement();
			return parent == this.textbox && range.text.length > 0;
		};

		// Overrides definition of _setSelectionRange from _TextBoxMixin (TODO: move to _TextBoxMixin.js?)
		dijit._setSelectionRange = _TextBoxMixin._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
			if(element.createTextRange){
				var r = element.createTextRange();
				r.collapse(true);
				r.moveStart("character", -99999); // move to 0
				r.moveStart("character", start); // delta from 0 is the correct position
				r.moveEnd("character", stop-start);
				r.select();
			}
		}
	}

	if(has("dojo-bidi")){
		TextBox = declare("dijit.form.TextBox", TextBox, {
			_setPlaceHolderAttr: function(v){
				this.inherited(arguments);
				this.applyTextDir(this._phspan);
			}
		});
	}

	return TextBox;
});

},
'ibm/tivoli/fwm/mxmap/impl/point/GmapsLatLonPoint':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_LatLonPoint"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

dojo.require("ibm.tivoli.fwm.mxmap._LatLonPoint");
dojo.provide("ibm.tivoli.fwm.mxmap.impl.point.GmapsLatLonPoint");

/**
 * GmapsLatLonPoint
 */
dojo.declare("ibm.tivoli.fwm.mxmap.impl.point.GmapsLatLonPoint", ibm.tivoli.fwm.mxmap._LatLonPoint, {
	
	toProprietary: function()
	{
		return new google.maps.LatLng(this.lat, this.lon);
	},

	fromProprietary: function(googlePoint)
	{
		this.lat = googlePoint.lat();
		this.lon = googlePoint.lng();
		this.lng = googlePoint.lng();
	}
	
});

});

},
'ibm/tivoli/fwm/mxmap/MapGraphite':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18
 *
 * (C) COPYRIGHT IBM CORP. 2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define( 
    [
        "dojo/main",
        "dojo/_base/declare",
        "ibm/tivoli/fwm/mxmap/MapBus",
	    "ibm/tivoli/fwm/mxmap/MapResize"
    ], 
    function ( 
        dojo,
        declare,
        MapBus,
        MapResize
    ) {
        return declare(null, {

            constructor: function (options) {
                this.mapConf = options.mapConf;
                this.compId = options.compId;
                this.mapBus = new MapBus(options, this);
                this.mapResize = new MapResize(options, this);
    
                this.mapBus.subscribeMapLoaded(dojo.hitch(this, this.onMapLoaded));
                window.mapBus = this.mapBus;
			    this.mapResize.resize();
            },

            destroyRecursive: function() {
                delete window.mapBus;

                this.mapResize.destroy();
            },

            onMapLoaded: function() {
                dojo.publish("mxmap.mapLoaded", [this, this.compId, this]);
            },

            getId: function() {
                return this.compId;
            },

            isMapGraphite: function() {
                return true;
            },

            initRoutes: function() {
                this.mapBus.initRoutes();
            },

            drawRoutes: function(routes) {
                this.mapBus.drawRoutes(routes);
            },

            clearRoutes: function() {
                this.mapBus.clearRoutes();
            },

            highlightLinearFeature: function(linearFeature) {
                this.mapBus.highlightLinearFeature(linearFeature);
            },

            inFullScreen: function() {
                return false;
            },

            // Legacy interface
            _resize: function() {},

        });
    } 
);

},
'dijit/_TemplatedMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/cache",	// dojo.cache
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.destroy, domConstruct.toDom
	"dojo/_base/lang", // lang.getObject
	"dojo/on",
	"dojo/sniff", // has("ie")
	"dojo/string", // string.substitute string.trim
	"./_AttachMixin"
], function(cache, declare, domConstruct, lang, on, has, string, _AttachMixin){

	// module:
	//		dijit/_TemplatedMixin

	var _TemplatedMixin = declare("dijit._TemplatedMixin", _AttachMixin, {
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template.
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
		templatePath: null,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template nodes poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

/*=====
		// _rendered: Boolean
		//		Not normally use, but this flag can be set by the app if the server has already rendered the template,
		//		i.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to
		//		just function like _AttachMixin.
		_rendered: false,
=====*/

		// Set _AttachMixin.searchContainerNode to true for back-compat for widgets that have data-dojo-attach-point's
		// and events inside this.containerNode.   Remove for 2.0.
		searchContainerNode: true,

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = lang.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value : this._escapeValue("" + value);
			}, this);
		},

		_escapeValue: function(/*String*/ val){
			// summary:
			//		Escape a value to be inserted into the template, either into an attribute value
			//		(ex: foo="${bar}") or as inner text of an element (ex: <span>${foo}</span>)

			// Safer substitution, see heading "Attribute values" in
			// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
			// and also https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content
			return val.replace(/["'<>&]/g, function(val){
				return {
					"&": "&amp;",
					"<": "&lt;",
					">": "&gt;",
					"\"": "&quot;",
					"'": "&#x27;"
				}[val];
			});
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			if(!this._rendered){
				if(!this.templateString){
					this.templateString = cache(this.templatePath, {sanitize: true});
				}

				// Lookup cached version of template, and download to cache if it
				// isn't there already.  Returns either a DomNode or a string, depending on
				// whether or not the template contains ${foo} replacement parameters.
				var cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache, this.ownerDocument);

				var node;
				if(lang.isString(cached)){
					node = domConstruct.toDom(this._stringRepl(cached), this.ownerDocument);
					if(node.nodeType != 1){
						// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
						throw new Error("Invalid template: " + cached);
					}
				}else{
					// if it's a node, all we have to do is clone it
					node = cached.cloneNode(true);
				}

				this.domNode = node;
			}

			// Call down to _WidgetBase.buildRendering() to get base classes assigned
			// TODO: change the baseClass assignment to _setBaseClassAttr
			this.inherited(arguments);

			if(!this._rendered){
				this._fillContent(this.srcNodeRef);
			}

			this._rendered = true;
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		}

	});

	// key is templateString; object is either string or DOM tree
	_TemplatedMixin._templateCache = {};

	_TemplatedMixin.getCachedTemplate = function(templateString, alwaysUseString, doc){
		// summary:
		//		Static method to get a template based on the templatePath or
		//		templateString key
		// templateString: String
		//		The template
		// alwaysUseString: Boolean
		//		Don't cache the DOM tree for this template, even if it doesn't have any variables
		// doc: Document?
		//		The target document.   Defaults to document global if unspecified.
		// returns: Mixed
		//		Either string (if there are ${} variables that need to be replaced) or just
		//		a DOM tree (if the node can be cloned directly)

		// is it already cached?
		var tmplts = _TemplatedMixin._templateCache;
		var key = templateString;
		var cached = tmplts[key];
		if(cached){
			try{
				// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the
				// current document, then use the current cached value
				if(!cached.ownerDocument || cached.ownerDocument == (doc || document)){
					// string or node of the same document
					return cached;
				}
			}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
			domConstruct.destroy(cached);
		}

		templateString = string.trim(templateString);

		if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
			// there are variables in the template so all we can do is cache the string
			return (tmplts[key] = templateString); //String
		}else{
			// there are no variables in the template so we can cache the DOM tree
			var node = domConstruct.toDom(templateString, doc);
			if(node.nodeType != 1){
				throw new Error("Invalid template: " + templateString);
			}
			return (tmplts[key] = node); //Node
		}
	};

	if(has("ie")){
		on(window, "unload", function(){
			var cache = _TemplatedMixin._templateCache;
			for(var key in cache){
				var value = cache[key];
				if(typeof value == "object"){ // value is either a string or a DOM node template
					domConstruct.destroy(value);
				}
				delete cache[key];
			}
		});
	}

	return _TemplatedMixin;
});

},
'dijit/_Templated':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"./_WidgetBase",
	"./_TemplatedMixin",
	"./_WidgetsInTemplateMixin",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.extend lang.isArray
	"dojo/_base/kernel" // kernel.deprecated
], function(_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, array, declare, lang, kernel){

	// module:
	//		dijit/_Templated

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	// Remove for 2.0.   Also, hide from API doc parser.
	lang.extend(_WidgetBase, /*===== {} || =====*/ {
		waiRole: "",
		waiState:""
	});

	return declare("dijit._Templated", [_TemplatedMixin, _WidgetsInTemplateMixin], {
		// summary:
		//		Deprecated mixin for widgets that are instantiated from a template.
		//		Widgets should use _TemplatedMixin plus if necessary _WidgetsInTemplateMixin instead.

		constructor: function(){
			kernel.deprecated(this.declaredClass + ": dijit._Templated deprecated, use dijit._TemplatedMixin and if necessary dijit._WidgetsInTemplateMixin", "", "2.0");
		},

		_processNode: function(baseNode, getAttrFunc){
			var ret = this.inherited(arguments);

			// Do deprecated waiRole and waiState
			var role = getAttrFunc(baseNode, "waiRole");
			if(role){
				baseNode.setAttribute("role", role);
			}
			var values = getAttrFunc(baseNode, "waiState");
			if(values){
				array.forEach(values.split(/\s*,\s*/), function(stateValue){
					if(stateValue.indexOf('-') != -1){
						var pair = stateValue.split('-');
						baseNode.setAttribute("aria-"+pair[0], pair[1]);
					}
				});
			}

			return ret;
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/FullScreen':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/main","dijit/main",
		"dojo/_base/declare",
		"ibm/tivoli/fwm/mxmap/toolbar/ext/_ToggleTool", 
		"dijit/form/Button"], 
		function(dojo, dijit,declare, _ToggleTool, Button) {
	/**
	 * Full Screen tool bar action.
	 */
	return declare([_ToggleTool], {
		_labelOn: "Set Full Screen On",
		_labelOff: "Set Full Screen Off",
		iconClass: "basicMapToolbarBtn fullScreenMapToolbarBtn",
		map: null,
		openMap: null,
		_isFullScreen: false,
		constructor: function(params)
		{
			dojo.mixin(this, params);
			this._isFullScreen = false;
			this._handlers=[];
			var labelOn = ibm.tivoli.fwm.i18n.getMaxMsg("map", "toolbarfullscreenon");
			var labelOff = ibm.tivoli.fwm.i18n.getMaxMsg("map", "toolbarfullscreenoff");
			this._labelOn = labelOn || this._labelOn; 
			this._labelOff = labelOff || this._labelOff;
			
			// listen to these events to update the button label/image by external
			// full screen changes
			this.addSubscription("mapFullScreenModeChanged_"+this.map.getId(), dojo.hitch(this, this._updateFullScreenState));
			if(this.map.mapConf.isOpenMap)
			{
				this.openMap = dojo.byId("pluss_open_map_bodydiv");
			}
			
		},
		createToolbarButton: function()
		{
			this._button = new Button({
				label: this._labelOn,
				showLabel: false,
				iconClass: this.iconClass,
				onClick: dojo.hitch(this, function()
				{	
					this.execute();
				})
			});
			return this._button;
		},
		executeOn: function()
		{	
			if(this.openMap)
			{
				dojo.addClass(this.openMap, "fullScreenOpenMap");
				this.map.fullScreenOn();
			}else
			{
				this._doFullScreen();
			}
		},
		executeOff:function()
		{
			if(this.openMap)
			{
				dojo.removeClass(this.openMap, "fullScreenOpenMap");
				this.map.fullScreenOff();
			}else
			{
				this._restoreOriginalSize();
			}
		
		},
		disable: function()
		{
			// does nothing
		},

		_doFullScreen: function()
		{
			this._changeButtonState(true, this._labelOff);
			this.map.fullScreenOn();
		},
		_restoreOriginalSize: function(event)
		{
			this._changeButtonState(false, this._labelOn);
			this.map.fullScreenOff();
		},
		_updateFullScreenState: function(event)
		{
			if (event.modeOn == true)
			{
				this.setActive(true);
				this._changeButtonState(true, this._labelOff);			
			}
			else
			{
				this.setActive(false);
				this._changeButtonState(false, this._labelOn);
			}
		},
		_changeButtonState: function(fullScreenMode, newLabel)
		{
			this._button.set({
				label: newLabel
			});
			this._isFullScreen = fullScreenMode;
		}	
		
	});
});

},
'dijit/_CssStateMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant()
	"dojo/dom-class", // domClass.toggle
	"dojo/has",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/domReady",
	"dojo/touch",
	"dojo/_base/window", // win.body
	"./a11yclick",
	"./registry"
], function(array, declare, dom, domClass, has, lang, on, domReady, touch, win, a11yclick, registry){

	// module:
	//		dijit/_CssStateMixin

	var CssStateMixin = declare("dijit._CssStateMixin", [], {
		// summary:
		//		Mixin for widgets to set CSS classes on the widget DOM nodes depending on hover/mouse press/focus
		//		state changes, and also higher-level state changes such becoming disabled or selected.
		//
		// description:
		//		By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
		//		maintain CSS classes on the widget root node (this.domNode) depending on hover,
		//		active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
		//		dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
		//
		//		It also sets CSS like dijitButtonDisabled based on widget semantic state.
		//
		//		By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
		//		within the widget).

		/*=====
		 // cssStateNodes: [protected] Object
		 //		Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
		 //		need CSS classes applied on mouse hover/press and focus.
		 //
		 //		Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
		 //		(like "dijitUpArrowButton"). Example:
		 //	|		{
		 //	|			"upArrowButton": "dijitUpArrowButton",
		 //	|			"downArrowButton": "dijitDownArrowButton"
		 //	|		}
		 //		The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
		 //		is hovered, etc.
		 cssStateNodes: {},
		 =====*/

		// hovering: [readonly] Boolean
		//		True if cursor is over this widget
		hovering: false,

		// active: [readonly] Boolean
		//		True if mouse was pressed while over this widget, and hasn't been released yet
		active: false,

		_applyAttributes: function(){
			// This code would typically be in postCreate(), but putting in _applyAttributes() for
			// performance: so the class changes happen before DOM is inserted into the document.
			// Change back to postCreate() in 2.0.  See #11635.

			this.inherited(arguments);

			// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
			array.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active", "_opened"], function(attr){
				this.watch(attr, lang.hitch(this, "_setStateClass"));
			}, this);

			// Track hover and active mouse events on widget root node, plus possibly on subnodes
			for(var ap in this.cssStateNodes || {}){
				this._trackMouseState(this[ap], this.cssStateNodes[ap]);
			}
			this._trackMouseState(this.domNode, this.baseClass);

			// Set state initially; there's probably no hover/active/focus state but widget might be
			// disabled/readonly/checked/selected so we want to set CSS classes for those conditions.
			this._setStateClass();
		},

		_cssMouseEvent: function(/*Event*/ event){
			// summary:
			//		Handler for CSS event on this.domNode. Sets hovering and active properties depending on mouse state,
			//		which triggers _setStateClass() to set appropriate CSS classes for this.domNode.

			if(!this.disabled){
				switch(event.type){
					case "mouseover":
					case "MSPointerOver":
					case "pointerover":
						this._set("hovering", true);
						this._set("active", this._mouseDown);
						break;
					case "mouseout":
					case "MSPointerOut":
					case "pointerout":
						this._set("hovering", false);
						this._set("active", false);
						break;
					case "mousedown":
					case "touchstart":
					case "MSPointerDown":
					case "pointerdown":
					case "keydown":
						this._set("active", true);
						break;
					case "mouseup":
					case "dojotouchend":
					case "MSPointerUp":
					case "pointerup":
					case "keyup":
						this._set("active", false);
						break;
				}
			}
		},

		_setStateClass: function(){
			// summary:
			//		Update the visual state of the widget by setting the css classes on this.domNode
			//		(or this.stateNode if defined) by combining this.baseClass with
			//		various suffixes that represent the current widget state(s).
			//
			// description:
			//		In the case where a widget has multiple
			//		states, it sets the class based on all possible
			//		combinations.  For example, an invalid form widget that is being hovered
			//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
			//
			//		The widget may have one or more of the following states, determined
			//		by this.state, this.checked, this.valid, and this.selected:
			//
			//		- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
			//		- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
			//		- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
			//		- Selected - ex: currently selected tab will have this.selected==true
			//
			//		In addition, it may have one or more of the following states,
			//		based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
			//
			//		- Disabled	- if the widget is disabled
			//		- Active		- if the mouse (or space/enter key?) is being pressed down
			//		- Focused		- if the widget has focus
			//		- Hover		- if the mouse is over the widget

			// Compute new set of classes
			var newStateClasses = this.baseClass.split(" ");

			function multiply(modifier){
				newStateClasses = newStateClasses.concat(array.map(newStateClasses, function(c){
					return c + modifier;
				}), "dijit" + modifier);
			}

			if(!this.isLeftToRight()){
				// For RTL mode we need to set an addition class like dijitTextBoxRtl.
				multiply("Rtl");
			}

			var checkedState = this.checked == "mixed" ? "Mixed" : (this.checked ? "Checked" : "");
			if(this.checked){
				multiply(checkedState);
			}
			if(this.state){
				multiply(this.state);
			}
			if(this.selected){
				multiply("Selected");
			}
			if(this._opened){
				multiply("Opened");
			}

			if(this.disabled){
				multiply("Disabled");
			}else if(this.readOnly){
				multiply("ReadOnly");
			}else{
				if(this.active){
					multiply("Active");
				}else if(this.hovering){
					multiply("Hover");
				}
			}

			if(this.focused){
				multiply("Focused");
			}

			// Remove old state classes and add new ones.
			// For performance concerns we only write into domNode.className once.
			var tn = this.stateNode || this.domNode,
				classHash = {};	// set of all classes (state and otherwise) for node

			array.forEach(tn.className.split(" "), function(c){
				classHash[c] = true;
			});

			if("_stateClasses" in this){
				array.forEach(this._stateClasses, function(c){
					delete classHash[c];
				});
			}

			array.forEach(newStateClasses, function(c){
				classHash[c] = true;
			});

			var newClasses = [];
			for(var c in classHash){
				newClasses.push(c);
			}
			tn.className = newClasses.join(" ");

			this._stateClasses = newStateClasses;
		},

		_subnodeCssMouseEvent: function(node, clazz, evt){
			// summary:
			//		Handler for hover/active mouse event on widget's subnode
			if(this.disabled || this.readOnly){
				return;
			}

			function hover(isHovering){
				domClass.toggle(node, clazz + "Hover", isHovering);
			}

			function active(isActive){
				domClass.toggle(node, clazz + "Active", isActive);
			}

			function focused(isFocused){
				domClass.toggle(node, clazz + "Focused", isFocused);
			}

			switch(evt.type){
				case "mouseover":
				case "MSPointerOver":
				case "pointerover":
					hover(true);
					break;
				case "mouseout":
				case "MSPointerOut":
				case "pointerout":
					hover(false);
					active(false);
					break;
				case "mousedown":
				case "touchstart":
				case "MSPointerDown":
				case "pointerdown":
				case "keydown":
					active(true);
					break;
				case "mouseup":
				case "MSPointerUp":
				case "pointerup":
				case "dojotouchend":
				case "keyup":
					active(false);
					break;
				case "focus":
				case "focusin":
					focused(true);
					break;
				case "blur":
				case "focusout":
					focused(false);
					break;
			}
		},

		_trackMouseState: function(/*DomNode*/ node, /*String*/ clazz){
			// summary:
			//		Track mouse/focus events on specified node and set CSS class on that node to indicate
			//		current state.   Usually not called directly, but via cssStateNodes attribute.
			// description:
			//		Given class=foo, will set the following CSS class on the node
			//
			//		- fooActive: if the user is currently pressing down the mouse button while over the node
			//		- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
			//		- fooFocus: if the node is focused
			//
			//		Note that it won't set any classes if the widget is disabled.
			// node: DomNode
			//		Should be a sub-node of the widget, not the top node (this.domNode), since the top node
			//		is handled specially and automatically just by mixing in this class.
			// clazz: String
			//		CSS class name (ex: dijitSliderUpArrow)

			// Flag for listener code below to call this._cssMouseEvent() or this._subnodeCssMouseEvent()
			// when node is hovered/active
			node._cssState = clazz;
		}
	});

	domReady(function(){
		// Document level listener to catch hover etc. events on widget root nodes and subnodes.
		// Note that when the mouse is moved quickly, a single onmouseenter event could signal that multiple widgets
		// have been hovered or unhovered (try test_Accordion.html)

		function pointerHandler(evt, target, relatedTarget){
			// Handler for mouseover, mouseout, a11yclick.press and a11click.release events

			// Poor man's event propagation.  Don't propagate event to ancestors of evt.relatedTarget,
			// to avoid processing mouseout events moving from a widget's domNode to a descendant node;
			// such events shouldn't be interpreted as a mouseleave on the widget.
			if(relatedTarget && dom.isDescendant(relatedTarget, target)){
				return;
			}

			for(var node = target; node && node != relatedTarget; node = node.parentNode){
				// Process any nodes with _cssState property.   They are generally widget root nodes,
				// but could also be sub-nodes within a widget
				if(node._cssState){
					var widget = registry.getEnclosingWidget(node);
					if(widget){
						if(node == widget.domNode){
							// event on the widget's root node
							widget._cssMouseEvent(evt);
						}else{
							// event on widget's sub-node
							widget._subnodeCssMouseEvent(node, node._cssState, evt);
						}
					}
				}
			}
		}

		var body = win.body(), activeNode;

		// Handle pointer related events (i.e. mouse or touch)
		on(body, touch.over, function(evt){
			// Using touch.over rather than mouseover mainly to ignore phantom mouse events on iOS.
			pointerHandler(evt, evt.target, evt.relatedTarget);
		});
		on(body, touch.out, function(evt){
			// Using touch.out rather than mouseout mainly to ignore phantom mouse events on iOS.
			pointerHandler(evt, evt.target, evt.relatedTarget);
		});
		on(body, a11yclick.press, function(evt){
			// Save the a11yclick.press target to reference when the a11yclick.release comes.
			activeNode = evt.target;
			pointerHandler(evt, activeNode)
		});
		on(body, a11yclick.release, function(evt){
			// The release event could come on a separate node than the press event, if for example user slid finger.
			// Reference activeNode to reset the state of the node that got state set in the a11yclick.press handler.
			pointerHandler(evt, activeNode);
			activeNode = null;
		});

		// Track focus events on widget sub-nodes that have been registered via _trackMouseState().
		// However, don't track focus events on the widget root nodes, because focus is tracked via the
		// focus manager (and it's not really tracking focus, but rather tracking that focus is on one of the widget's
		// nodes or a subwidget's node or a popup node, etc.)
		// Remove for 2.0 (if focus CSS needed, just use :focus pseudo-selector).
		on(body, "focusin, focusout", function(evt){
			var node = evt.target;
			if(node._cssState && !node.getAttribute("widgetId")){
				var widget = registry.getEnclosingWidget(node);
				if(widget){
					widget._subnodeCssMouseEvent(node, node._cssState, evt);
				}
			}
		});
	});

	return CssStateMixin;
});

},
'dijit/DialogUnderlay':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.hitch
	"dojo/aspect", // aspect.after
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/on",
	"dojo/window", // winUtils.getBox, winUtils.get
	"./_Widget",
	"./_TemplatedMixin",
	"./BackgroundIframe",
	"./Viewport",
	"./main" // for back-compat, exporting dijit._underlay (remove in 2.0)
], function(declare, lang, aspect, domAttr, domStyle, on,
			winUtils, _Widget, _TemplatedMixin, BackgroundIframe, Viewport, dijit){

	// module:
	//		dijit/DialogUnderlay

	var DialogUnderlay = declare("dijit.DialogUnderlay", [_Widget, _TemplatedMixin], {
		// summary:
		//		A component used to block input behind a `dijit/Dialog`.
		//
		//		Normally this class should not be instantiated directly, but rather shown and hidden via
		//		DialogUnderlay.show() and DialogUnderlay.hide().  And usually the module is not accessed directly
		//		at all, since the underlay is shown and hidden by Dialog.DialogLevelManager.
		//
		//		The underlay itself can be styled based on and id:
		//	|	#myDialog_underlay { background-color:red; }
		//
		//		In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
		//		suffixed with _underlay.

		// Template has two divs; outer div is used for fade-in/fade-out, and also to hold background iframe.
		// Inner div has opacity specified in CSS file.
		templateString: "<div class='dijitDialogUnderlayWrapper'><div class='dijitDialogUnderlay' tabIndex='-1' data-dojo-attach-point='node'></div></div>",

		// Parameters on creation or updatable later

		// dialogId: String
		//		Id of the dialog.... DialogUnderlay's id is based on this id
		dialogId: "",

		// class: String
		//		This class name is used on the DialogUnderlay node, in addition to dijitDialogUnderlay
		"class": "",

		// This will get overwritten as soon as show() is call, but leave an empty array in case hide() or destroy()
		// is called first.   The array is shared between instances but that's OK because we never write into it.
		_modalConnects: [],

		_setDialogIdAttr: function(id){
			domAttr.set(this.node, "id", id + "_underlay");
			this._set("dialogId", id);
		},

		_setClassAttr: function(clazz){
			this.node.className = "dijitDialogUnderlay " + clazz;
			this._set("class", clazz);
		},

		postCreate: function(){
			// Append the underlay to the body
			this.ownerDocumentBody.appendChild(this.domNode);

			this.own(on(this.domNode, "keydown", lang.hitch(this, "_onKeyDown")));

			this.inherited(arguments);
		},

		layout: function(){
			// summary:
			//		Sets the background to the size of the viewport
			//
			// description:
			//		Sets the background to the size of the viewport (rather than the size
			//		of the document) since we need to cover the whole browser window, even
			//		if the document is only a few lines long.
			// tags:
			//		private

			var is = this.node.style,
				os = this.domNode.style;

			// hide the background temporarily, so that the background itself isn't
			// causing scrollbars to appear (might happen when user shrinks browser
			// window and then we are called to resize)
			os.display = "none";

			// then resize and show
			var viewport = winUtils.getBox(this.ownerDocument);
			os.top = viewport.t + "px";
			os.left = viewport.l + "px";
			is.width = viewport.w + "px";
			is.height = viewport.h + "px";
			os.display = "block";
		},

		show: function(){
			// summary:
			//		Show the dialog underlay
			this.domNode.style.display = "block";
			this.open = true;
			this.layout();
			this.bgIframe = new BackgroundIframe(this.domNode);

			var win = winUtils.get(this.ownerDocument);
			this._modalConnects = [
				Viewport.on("resize", lang.hitch(this, "layout")),
				on(win, "scroll", lang.hitch(this, "layout"))
			];

		},

		hide: function(){
			// summary:
			//		Hides the dialog underlay

			this.bgIframe.destroy();
			delete this.bgIframe;
			this.domNode.style.display = "none";
			while(this._modalConnects.length){ (this._modalConnects.pop()).remove(); }
			this.open = false;
		},

		destroy: function(){
			while(this._modalConnects.length){ (this._modalConnects.pop()).remove(); }
			this.inherited(arguments);
		},

		_onKeyDown: function(){
			// summary:
			//		Extension point so Dialog can monitor keyboard events on the underlay.
		}
	});

	DialogUnderlay.show = function(/*Object*/ attrs, /*Number*/ zIndex){
		// summary:
		//		Display the underlay with the given attributes set.  If the underlay is already displayed,
		//		then adjust it's attributes as specified.
		// attrs:
		//		The parameters to create DialogUnderlay with.
		// zIndex:
		//		zIndex of the underlay

		var underlay = DialogUnderlay._singleton;
		if(!underlay || underlay._destroyed){
			underlay = dijit._underlay = DialogUnderlay._singleton = new DialogUnderlay(attrs);
		}else{
			if(attrs){ underlay.set(attrs); }
		}
		domStyle.set(underlay.domNode, 'zIndex', zIndex);
		if(!underlay.open){
			underlay.show();
		}
	};

	DialogUnderlay.hide = function(){
		// summary:
		//		Hide the underlay.

		// Guard code in case the underlay widget has already been destroyed
		// because we are being called during page unload (when all widgets are destroyed)
		var underlay = DialogUnderlay._singleton;
		if(underlay && !underlay._destroyed){
			underlay.hide();
		}
	};

	return DialogUnderlay;
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/ItineraryTool':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/main","dijit/main",
		"dojo/_base/declare",
		"ibm/tivoli/fwm/mxmap/toolbar/ext/_ToolTemplate",
		"dijit/form/Button",
		"ibm/tivoli/fwm/mxmap/routing/itinerary/ItineraryManager"], function(dojo, dijit, declare, _ToolTemplate, Button, ItineraryManager) {
	
	/**
	 * Mobile Info Panel tool bar action.
	 */
	return declare([_ToolTemplate], {
		label: "Show Itinerary",
		iconClass: "basicMapToolbarBtn itineraryMapToolbarBtn",
		map: null,
		_itineraryManager: null,
		_dialog:null,
		constructor: function(params)
		{
			
			dojo.mixin(this, params);
			var _label = ibm.tivoli.fwm.i18n.getMaxMsg("map", "itinerarytool");
			this.label = _label || this.label;
			
			this._dialog = null;
			this._itineraryManager = new ItineraryManager({
				map: this.map
			});
			this.addSubscription("showItinerary_"+this.map.getId(), dojo.hitch(this, this.triggerShowItinerary));
		},
		triggerShowItinerary:function(){
			this.execute();
		},
		execute: function()
		{
			if (this._dialog)
			{
				this._dialog.close();
				this._dialog = null;
			}
			var routeManager = this.map.getMultipleRoutesManager();
			if (routeManager && routeManager.routes && routeManager.routes[0])
			{
				var currentItinerary = routeManager.routes[0].itinerary;
				if (currentItinerary)
				{
					this._itineraryManager.updateRouteItinerary(currentItinerary, routeManager, routeManager.routes[0]);
				}
			}
			this._itineraryManager.showPanel();
		},
		disable: function()
		{
		},
		destroy: function()
		{
			this.destroyRecursive();
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/routing/MultipleRoutesManager':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Base,ibm/tivoli/fwm/mxmap/routing/RouterFactory,ibm/tivoli/fwm/mxmap/routing/itinerary/Itinerary"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.routing.MultipleRoutesManager");
dojo.require("ibm.tivoli.fwm.mxmap._Base");
dojo.require("ibm.tivoli.fwm.mxmap.routing.RouterFactory");
dojo.require("ibm.tivoli.fwm.mxmap.routing.itinerary.Itinerary");
/**
 * Manage multiple routes.<br>
 * 
 */
dojo.declare("ibm.tivoli.fwm.mxmap.routing.MultipleRoutesManager", ibm.tivoli.fwm.mxmap._Base, {
	routeConf: null,
	provider: null,
	map: null,
	routeUrl: null,
	routingData: null,
	routes: null,
	visible: true,

	constructor: function(params)
	{
		dojo.mixin(this, params);
		this.factory = new ibm.tivoli.fwm.mxmap.routing.RouterFactory({
			map: this.map,
			provider: this.provider
		});
		this.routeConf.routeUrl = this.routeUrl;
		this.routes = [];
	},
	createRoute: function(stops, config, callback, errcallback, noZoom)
	{
		var routeConf = {
			routecolor: config.routecolor,
			routeOpacity: 0.5,
			routeLineWidth: 5,
			endLocation: config.end,
			startLocation: config.start,
			optimizeroute: config.optimizeroute,
			startwithcurrentlocation: config.startwithcurrentlocation,
			routeUrl: config.routeUrl,
			map: this.map
		};

		var router = this.factory.createRouter(routeConf);

		var fct = function(route)
		{
			route.id = this.routes.length;
			this.routes.push(route);
			route.setLineVisible(this.visible);
			route.show();
			if (noZoom != true)
			{
				route.zoomToRoute();
				console.log("zooming to single route!");
				var routeWarning = this.getWarning();
				if(routeWarning)
				{
					this.map.showWarning(routeWarning);
				}
			}
			if (callback)
			{
				callback(route);
			}
		};

		if (!errcallback)
		{
			errcallback = dojo.hitch(this, this.routingError);
		}

		var me = this;
		if (router.then) {
			router.then(function(objRouter) {
				objRouter.customConf = me.customConf;
				objRouter.drawRoute(stops, dojo.hitch(me, fct), errcallback, routeConf);
			});
		}
		else {
			router.customConf = me.customConf;
			router.drawRoute(stops, dojo.hitch(me, fct), errcallback, routeConf);
		}
	},
	customConf: null,
	reGenerate: function(route, customConf, callback, errorCallback)
	{
		this.customConf = customConf;
		if (dojo.config.fwm.debug == true)
		{
			console.log("route id " + route.id);
		}
		route.originalRouter.customConf = customConf;

		// The instanceConf parameter was added because it contains information on the route that cannot
		// be retrieved from originalRouter
		route.originalRouter.drawRoute(route.inputInfo.stops, callback, errorCallback, route.instanceConf);
		// this.createRoute(conf.stops,conf.successCb,conf.errorCb);
	},
	replaceRoute: function(route, id)
	{
		this.removeRoute(this.routes[id]);
		this.routes[id] = route;
		route.id = id;
	},
	removeRoute: function(route)
	{
		route.clear();
	},
	clearAll: function()
	{
		if (dojo.config.fwm.debug == true)
		{
			console.log("[MultipleRoutesManager] Clearing all route information");
		}
		while (this.routes.length > 0)
		{
			this.routes.pop().clear();
		}
		if (dojo.config.fwm.debug == true)
		{
			console.log("[MultipleRoutesManager] Done");
		}
	},
	redrawAll: function()
	{
		dojo.forEach(this.routes, function(route)
		{
			route.redraw();
		});
	},
	setLineVisible: function(visible)
	{
		dojo.forEach(this.routes, function(route)
		{
			route.setLineVisible(visible);
		});
	},
	hideRoutesLinesAndCalculatedMarkers: function()
	{
		this.visible = false;
		dojo.forEach(this.routes, function(route)
		{
			route.setLineVisible(false);
			route.hideCalculatedMarkers();
		});
	},
	showRoutesLinesAndCalculatedMarkers: function()
	{
		this.visible = true;
		var disp = this.getDispatcher()
		// Defect 56204 - If dispatcher is the one handling this class,
		// do not show every route's lines because some of them may not be
		// active at a given time. And only dispatcher knows which routes are active
		// because it holds "routeCache".
		// This workaround is not so elegant but it is the only one I could think of that does
		// not break anything else and that is not risky.
		// The elegant way would be to make this class hold the route cache
		// but this would involve too many changes to the logic and it is risky.
		if(disp)
		{
			disp.showCachedRoutesLinesAndCalculatedMarkers();
		}
		else
		{
			dojo.forEach(this.routes, function(route)
			{
				route.setLineVisible(true);
				route.showCalculatedMarkers();
			});
		}
	},
	// _addItinerary: function(route)
	// {},
	centerAndZoom: function()
	{
		this.zoomAndCenterOverAll();
	},
	// Zoom to every route in this.routes. If "routes" is passed
	// as argument, zoom to those routes instead of this.routes.
	zoomAndCenterOverAll: function(routes)
	{
		var routesToZoomTo = (routes != undefined && routes != null) ? routes : this.routes;
		
		var bounds = null;
		for(var idx in routesToZoomTo)
		{
			if((routesToZoomTo[idx] != null) && (routesToZoomTo[idx] != undefined))
			{
				if(bounds)
				{
					bounds.merge(routesToZoomTo[idx].getBounds());
				}
				else
				{
					bounds = routesToZoomTo[idx].getBounds();
				}
			}
		};
		
		if(bounds)
		{
			this.map.setBounds(bounds);
		}
		else
		{
			console.warn("[MultipleRoutesManager] No routes to center on");
		}
	},
	routingError: function(statusCode, error)
	{

		var maximo = this.map.getMaximo();
		switch (statusCode)
		{

			case ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.MIN_STOPS_REQ:
				maximo.showMessage("mapserver", "route_min_stops_failure");
				break;
			case ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.ZERO_RESULTS:
				maximo.showMessage("mapserver", "route_zero_results");
				break;
			case ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.INVALID_REQUEST:
				maximo.showMessage("mapserver", "route_invalid_request");
				break;
			case ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.REQUEST_DENIED:
				maximo.showMessage("mapserver", "route_request_denied");
				break;
			case ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.OVER_LIMIT:
				maximo.showMessage("mapserver", "route_over_limit");
				break;
			case ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.TIMEOUT:
				maximo.showMessage("mapserver", "route_timeout");
				break;

			default:
				var msg = error;
				if (error && error.message)
				{
					msg = error.message;
				}
				maximo.showMessage("mapserver", "route_unknown_failure", [ msg ]);
				break;
		}

	},
	destroyRecursive: function()
	{
		if (this.router)
		{
			this.router.destroyRecursive();
		}
		this.inherited(arguments);
	},
	getItinerary: function()
	{
		return this.routes[0].itinerary;
	},
	getDispatcher: function()
	{
		return this.map.getDispatcher();
	},
	getWarning: function()
	{
		var warning = null;
		for(var i=0; i<this.routes.length; i++)
		{
			var warningsArray = this.routes[i].getRouteWarningCodes();
			// TODO: For now there is only one possible warning
			// Add the code to handle more when necessary
			if(warningsArray && (warningsArray.length > 0))
			{
				warning = warningsArray[0];
				break;
			}
		}
		return warning;
	}
});

});

},
'dijit/place':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach array.map array.some
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/window", // win.body
	"./Viewport", // getEffectiveBox
	"./main"	// dijit (defining dijit.place to match API doc)
], function(array, domGeometry, domStyle, kernel, win, Viewport, dijit){

	// module:
	//		dijit/place


	function _place(/*DomNode*/ node, choices, layoutNode, aroundNodeCoords){
		// summary:
		//		Given a list of spots to put node, put it at the first spot where it fits,
		//		of if it doesn't fit anywhere then the place with the least overflow
		// choices: Array
		//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
		//		Above example says to put the top-left corner of the node at (10,20)
		// layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)
		//		for things like tooltip, they are displayed differently (and have different dimensions)
		//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
		//		It also passes in the available size for the popup, which is useful for tooltips to
		//		tell them that their width is limited to a certain amount.	 layoutNode() may return a value expressing
		//		how much the popup had to be modified to fit into the available space.	 This is used to determine
		//		what the best placement is.
		// aroundNodeCoords: Object
		//		Size of aroundNode, ex: {w: 200, h: 50}

		// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
		// viewport over document
		var view = Viewport.getEffectiveBox(node.ownerDocument);

		// This won't work if the node is inside a <div style="position: relative">,
		// so reattach it to <body>.	 (Otherwise, the positioning will be wrong
		// and also it might get cutoff.)
		if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
			win.body(node.ownerDocument).appendChild(node);
		}

		var best = null;
		array.some(choices, function(choice){
			var corner = choice.corner;
			var pos = choice.pos;
			var overflow = 0;

			// calculate amount of space available given specified position of node
			var spaceAvailable = {
				w: {
					'L': view.l + view.w - pos.x,
					'R': pos.x - view.l,
					'M': view.w
				}[corner.charAt(1)],
				h: {
					'T': view.t + view.h - pos.y,
					'B': pos.y - view.t,
					'M': view.h
				}[corner.charAt(0)]
			};

			// Clear left/right position settings set earlier so they don't interfere with calculations,
			// specifically when layoutNode() (a.k.a. Tooltip.orient()) measures natural width of Tooltip
			var s = node.style;
			s.left = s.right = "auto";

			// configure node to be displayed in given position relative to button
			// (need to do this in order to get an accurate size for the node, because
			// a tooltip's size changes based on position, due to triangle)
			if(layoutNode){
				var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
				overflow = typeof res == "undefined" ? 0 : res;
			}

			// get node's size
			var style = node.style;
			var oldDisplay = style.display;
			var oldVis = style.visibility;
			if(style.display == "none"){
				style.visibility = "hidden";
				style.display = "";
			}
			var bb = domGeometry.position(node);
			style.display = oldDisplay;
			style.visibility = oldVis;

			// coordinates and size of node with specified corner placed at pos,
			// and clipped by viewport
			var
				startXpos = {
					'L': pos.x,
					'R': pos.x - bb.w,
					'M': Math.max(view.l, Math.min(view.l + view.w, pos.x + (bb.w >> 1)) - bb.w) // M orientation is more flexible
				}[corner.charAt(1)],
				startYpos = {
					'T': pos.y,
					'B': pos.y - bb.h,
					'M': Math.max(view.t, Math.min(view.t + view.h, pos.y + (bb.h >> 1)) - bb.h)
				}[corner.charAt(0)],
				startX = Math.max(view.l, startXpos),
				startY = Math.max(view.t, startYpos),
				endX = Math.min(view.l + view.w, startXpos + bb.w),
				endY = Math.min(view.t + view.h, startYpos + bb.h),
				width = endX - startX,
				height = endY - startY;

			overflow += (bb.w - width) + (bb.h - height);

			if(best == null || overflow < best.overflow){
				best = {
					corner: corner,
					aroundCorner: choice.aroundCorner,
					x: startX,
					y: startY,
					w: width,
					h: height,
					overflow: overflow,
					spaceAvailable: spaceAvailable
				};
			}

			return !overflow;
		});

		// In case the best position is not the last one we checked, need to call
		// layoutNode() again.
		if(best.overflow && layoutNode){
			layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
		}

		// And then position the node.  Do this last, after the layoutNode() above
		// has sized the node, due to browser quirks when the viewport is scrolled
		// (specifically that a Tooltip will shrink to fit as though the window was
		// scrolled to the left).

		var top = best.y,
			side = best.x,
			body = win.body(node.ownerDocument);

		if(/relative|absolute/.test(domStyle.get(body, "position"))){
			// compensate for margin on <body>, see #16148
			top -= domStyle.get(body, "marginTop");
			side -= domStyle.get(body, "marginLeft");
		}

		var s = node.style;
		s.top = top + "px";
		s.left = side + "px";
		s.right = "auto";	// needed for FF or else tooltip goes to far left

		return best;
	}

	var reverse = {
		// Map from corner to kitty-corner
		"TL": "BR",
		"TR": "BL",
		"BL": "TR",
		"BR": "TL"
	};

	var place = {
		// summary:
		//		Code to place a DOMNode relative to another DOMNode.
		//		Load using require(["dijit/place"], function(place){ ... }).

		at: function(node, pos, corners, padding, layoutNode){
			// summary:
			//		Positions node kitty-corner to the rectangle centered at (pos.x, pos.y) with width and height of
			//		padding.x * 2 and padding.y * 2, or zero if padding not specified.  Picks first corner in corners[]
			//		where node is fully visible, or the corner where it's most visible.
			//
			//		Node is assumed to be absolutely or relatively positioned.
			// node: DOMNode
			//		The node to position
			// pos: dijit/place.__Position
			//		Object like {x: 10, y: 20}
			// corners: String[]
			//		Array of Strings representing order to try corners of the node in, like ["TR", "BL"].
			//		Possible values are:
			//
			//		- "BL" - bottom left
			//		- "BR" - bottom right
			//		- "TL" - top left
			//		- "TR" - top right
			// padding: dijit/place.__Position?
			//		Optional param to set padding, to put some buffer around the element you want to position.
			//		Defaults to zero.
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.  This adjusts the popup based on orientation.
			// example:
			//		Try to place node's top right corner at (10,20).
			//		If that makes node go (partially) off screen, then try placing
			//		bottom left corner at (10,20).
			//	|	place(node, {x: 10, y: 20}, ["TR", "BL"])
			var choices = array.map(corners, function(corner){
				var c = {
					corner: corner,
					aroundCorner: reverse[corner],	// so TooltipDialog.orient() gets aroundCorner argument set
					pos: {x: pos.x,y: pos.y}
				};
				if(padding){
					c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
					c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
				}
				return c;
			});

			return _place(node, choices, layoutNode);
		},

		around: function(
			/*DomNode*/		node,
			/*DomNode|dijit/place.__Rectangle*/ anchor,
			/*String[]*/	positions,
			/*Boolean*/		leftToRight,
			/*Function?*/	layoutNode){

			// summary:
			//		Position node adjacent or kitty-corner to anchor
			//		such that it's fully visible in viewport.
			// description:
			//		Place node such that corner of node touches a corner of
			//		aroundNode, and that node is fully visible.
			// anchor:
			//		Either a DOMNode or a rectangle (object with x, y, width, height).
			// positions:
			//		Ordered list of positions to try matching up.
			//
			//		- before: places drop down to the left of the anchor node/widget, or to the right in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- after: places drop down to the right of the anchor node/widget, or to the left in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- before-centered: centers drop down to the left of the anchor node/widget, or to the right
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- after-centered: centers drop down to the right of the anchor node/widget, or to the left
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- above-centered: drop down is centered above anchor node
			//		- above: drop down goes above anchor node, left sides aligned
			//		- above-alt: drop down goes above anchor node, right sides aligned
			//		- below-centered: drop down is centered above anchor node
			//		- below: drop down goes below anchor node
			//		- below-alt: drop down goes below anchor node, right sides aligned
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
			// leftToRight:
			//		True if widget is LTR, false if widget is RTL.   Affects the behavior of "above" and "below"
			//		positions slightly.
			// example:
			//	|	placeAroundNode(node, aroundNode, ['below', 'above-alt']);
			//		This will try to position node such that node's top-left corner is at the same position
			//		as the bottom left corner of the aroundNode (ie, put node below
			//		aroundNode, with left edges aligned).	If that fails it will try to put
			//		the bottom-right corner of node where the top right corner of aroundNode is
			//		(ie, put node above aroundNode, with right edges aligned)
			//

			// If around is a DOMNode (or DOMNode id), convert to coordinates.
			var aroundNodePos;
			if(typeof anchor == "string" || "offsetWidth" in anchor || "ownerSVGElement" in anchor){
				aroundNodePos = domGeometry.position(anchor, true);

				// For above and below dropdowns, subtract width of border so that popup and aroundNode borders
				// overlap, preventing a double-border effect.  Unfortunately, difficult to measure the border
				// width of either anchor or popup because in both cases the border may be on an inner node.
				if(/^(above|below)/.test(positions[0])){
					var anchorBorder = domGeometry.getBorderExtents(anchor),
						anchorChildBorder = anchor.firstChild ? domGeometry.getBorderExtents(anchor.firstChild) : {t:0,l:0,b:0,r:0},
						nodeBorder =  domGeometry.getBorderExtents(node),
						nodeChildBorder = node.firstChild ? domGeometry.getBorderExtents(node.firstChild) : {t:0,l:0,b:0,r:0};
					aroundNodePos.y += Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t + nodeChildBorder.t);
					aroundNodePos.h -=  Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t+ nodeChildBorder.t) +
						Math.min(anchorBorder.b + anchorChildBorder.b, nodeBorder.b + nodeChildBorder.b);
				}
			}else{
				aroundNodePos = anchor;
			}

			// Compute position and size of visible part of anchor (it may be partially hidden by ancestor nodes w/scrollbars)
			if(anchor.parentNode){
				// ignore nodes between position:relative and position:absolute
				var sawPosAbsolute = domStyle.getComputedStyle(anchor).position == "absolute";
				var parent = anchor.parentNode;
				while(parent && parent.nodeType == 1 && parent.nodeName != "BODY"){  //ignoring the body will help performance
					var parentPos = domGeometry.position(parent, true),
						pcs = domStyle.getComputedStyle(parent);
					if(/relative|absolute/.test(pcs.position)){
						sawPosAbsolute = false;
					}
					if(!sawPosAbsolute && /hidden|auto|scroll/.test(pcs.overflow)){
						var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);
						var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);
						aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);
						aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);
						aroundNodePos.h = bottomYCoord - aroundNodePos.y;
						aroundNodePos.w = rightXCoord - aroundNodePos.x;
					}
					if(pcs.position == "absolute"){
						sawPosAbsolute = true;
					}
					parent = parent.parentNode;
				}
			}

			var x = aroundNodePos.x,
				y = aroundNodePos.y,
				width = "w" in aroundNodePos ? aroundNodePos.w : (aroundNodePos.w = aroundNodePos.width),
				height = "h" in aroundNodePos ? aroundNodePos.h : (kernel.deprecated("place.around: dijit/place.__Rectangle: { x:"+x+", y:"+y+", height:"+aroundNodePos.height+", width:"+width+" } has been deprecated.  Please use { x:"+x+", y:"+y+", h:"+aroundNodePos.height+", w:"+width+" }", "", "2.0"), aroundNodePos.h = aroundNodePos.height);

			// Convert positions arguments into choices argument for _place()
			var choices = [];
			function push(aroundCorner, corner){
				choices.push({
					aroundCorner: aroundCorner,
					corner: corner,
					pos: {
						x: {
							'L': x,
							'R': x + width,
							'M': x + (width >> 1)
						}[aroundCorner.charAt(1)],
						y: {
							'T': y,
							'B': y + height,
							'M': y + (height >> 1)
						}[aroundCorner.charAt(0)]
					}
				})
			}
			array.forEach(positions, function(pos){
				var ltr =  leftToRight;
				switch(pos){
					case "above-centered":
						push("TM", "BM");
						break;
					case "below-centered":
						push("BM", "TM");
						break;
					case "after-centered":
						ltr = !ltr;
						// fall through
					case "before-centered":
						push(ltr ? "ML" : "MR", ltr ? "MR" : "ML");
						break;
					case "after":
						ltr = !ltr;
						// fall through
					case "before":
						push(ltr ? "TL" : "TR", ltr ? "TR" : "TL");
						push(ltr ? "BL" : "BR", ltr ? "BR" : "BL");
						break;
					case "below-alt":
						ltr = !ltr;
						// fall through
					case "below":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "BL" : "BR", ltr ? "TL" : "TR");
						push(ltr ? "BR" : "BL", ltr ? "TR" : "TL");
						break;
					case "above-alt":
						ltr = !ltr;
						// fall through
					case "above":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "TL" : "TR", ltr ? "BL" : "BR");
						push(ltr ? "TR" : "TL", ltr ? "BR" : "BL");
						break;
					default:
						// To assist dijit/_base/place, accept arguments of type {aroundCorner: "BL", corner: "TL"}.
						// Not meant to be used directly.  Remove for 2.0.
						push(pos.aroundCorner, pos.corner);
				}
			});

			var position = _place(node, choices, layoutNode, {w: width, h: height});
			position.aroundNodePos = aroundNodePos;

			return position;
		}
	};

	/*=====
	place.__Position = {
		// x: Integer
		//		horizontal coordinate in pixels, relative to document body
		// y: Integer
		//		vertical coordinate in pixels, relative to document body
	};
	place.__Rectangle = {
		// x: Integer
		//		horizontal offset in pixels, relative to document body
		// y: Integer
		//		vertical offset in pixels, relative to document body
		// w: Integer
		//		width in pixels.   Can also be specified as "width" for backwards-compatibility.
		// h: Integer
		//		height in pixels.   Can also be specified as "height" for backwards-compatibility.
	};
	=====*/

	return dijit.place = place;	// setting dijit.place for back-compat, remove for 2.0
});

},
'dijit/_HasDropDown':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred",
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.add domClass.contains domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/has", // has("touch")
	"dojo/keys", // keys.DOWN_ARROW keys.ENTER keys.ESCAPE
	"dojo/_base/lang", // lang.hitch lang.isFunction
	"dojo/on",
	"dojo/touch",
	"./registry", // registry.byNode()
	"./focus",
	"./popup",
	"./_FocusMixin"
], function(declare, Deferred, dom, domAttr, domClass, domGeometry, domStyle, has, keys, lang, on, touch,
			registry, focus, popup, _FocusMixin){


	// module:
	//		dijit/_HasDropDown

	return declare("dijit._HasDropDown", _FocusMixin, {
		// summary:
		//		Mixin for widgets that need drop down ability.

		// _buttonNode: [protected] DomNode
		//		The button/icon/node to click to display the drop down.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then either focusNode or domNode (if focusNode is also missing) will be used.
		_buttonNode: null,

		// _arrowWrapperNode: [protected] DomNode
		//		Will set CSS class dijitUpArrow, dijitDownArrow, dijitRightArrow etc. on this node depending
		//		on where the drop down is set to be positioned.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then _buttonNode will be used.
		_arrowWrapperNode: null,

		// _popupStateNode: [protected] DomNode
		//		The node to set the aria-expanded class on.
		//		Also sets popupActive class but that will be removed in 2.0.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then focusNode or _buttonNode (if focusNode is missing) will be used.
		_popupStateNode: null,

		// _aroundNode: [protected] DomNode
		//		The node to display the popup around.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then domNode will be used.
		_aroundNode: null,

		// dropDown: [protected] Widget
		//		The widget to display as a popup.  This widget *must* be
		//		defined before the startup function is called.
		dropDown: null,

		// autoWidth: [protected] Boolean
		//		Set to true to make the drop down at least as wide as this
		//		widget.  Set to false if the drop down should just be its
		//		default width.
		autoWidth: true,

		// forceWidth: [protected] Boolean
		//		Set to true to make the drop down exactly as wide as this
		//		widget.  Overrides autoWidth.
		forceWidth: false,

		// maxHeight: [protected] Integer
		//		The max height for our dropdown.
		//		Any dropdown taller than this will have scrollbars.
		//		Set to 0 for no max height, or -1 to limit height to available space in viewport
		maxHeight: -1,

		// dropDownPosition: [const] String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//		- before: places drop down to the left of the target node/widget, or to the right in
		//		  the case of RTL scripts like Hebrew and Arabic
		//		- after: places drop down to the right of the target node/widget, or to the left in
		//		  the case of RTL scripts like Hebrew and Arabic
		//		- above: drop down goes above target node
		//		- below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		//
		dropDownPosition: ["below", "above"],

		// _stopClickEvents: Boolean
		//		When set to false, the click events will not be stopped, in
		//		case you want to use them in your subclass
		_stopClickEvents: true,

		_onDropDownMouseDown: function(/*Event*/ e){
			// summary:
			//		Callback when the user mousedown/touchstart on the arrow icon.

			if(this.disabled || this.readOnly){
				return;
			}

			// Prevent default to stop things like text selection, but don't stop propagation, so that:
			//		1. TimeTextBox etc. can focus the <input> on mousedown
			//		2. dropDownButtonActive class applied by _CssStateMixin (on button depress)
			//		3. user defined onMouseDown handler fires
			//
			// Also, don't call preventDefault() on MSPointerDown event (on IE10) because that prevents the button
			// from getting focus, and then the focus manager doesn't know what's going on (#17262)
			if(e.type != "MSPointerDown"){
				e.preventDefault();
			}

			this.own(on.once(this.ownerDocument, touch.release, lang.hitch(this, "_onDropDownMouseUp")));

			this.toggleDropDown();
		},

		_onDropDownMouseUp: function(/*Event?*/ e){
			// summary:
			//		Callback on mouseup/touchend after mousedown/touchstart on the arrow icon.
			//		Note that this function is called regardless of what node the event occurred on (but only after
			//		a mousedown/touchstart on the arrow).
			//
			//		If the drop down is a simple menu and the cursor is over the menu, we execute it, otherwise, we focus our
			//		drop down widget.  If the event is missing, then we are not
			//		a mouseup event.
			//
			//		This is useful for the common mouse movement pattern
			//		with native browser `<select>` nodes:
			//
			//		1. mouse down on the select node (probably on the arrow)
			//		2. move mouse to a menu item while holding down the mouse button
			//		3. mouse up.  this selects the menu item as though the user had clicked it.

			var dropDown = this.dropDown, overMenu = false;

			if(e && this._opened){
				// This code deals with the corner-case when the drop down covers the original widget,
				// because it's so large.  In that case mouse-up shouldn't select a value from the menu.
				// Find out if our target is somewhere in our dropdown widget,
				// but not over our _buttonNode (the clickable node)
				var c = domGeometry.position(this._buttonNode, true);
				if(!(e.pageX >= c.x && e.pageX <= c.x + c.w) || !(e.pageY >= c.y && e.pageY <= c.y + c.h)){
					var t = e.target;
					while(t && !overMenu){
						if(domClass.contains(t, "dijitPopup")){
							overMenu = true;
						}else{
							t = t.parentNode;
						}
					}
					if(overMenu){
						t = e.target;
						if(dropDown.onItemClick){
							var menuItem;
							while(t && !(menuItem = registry.byNode(t))){
								t = t.parentNode;
							}
							if(menuItem && menuItem.onClick && menuItem.getParent){
								menuItem.getParent().onItemClick(menuItem, e);
							}
						}
						return;
					}
				}
			}
			if(this._opened){
				// Focus the dropdown widget unless it's a menu (in which case autoFocus is set to false).
				// Even if it's a menu, we need to focus it if this is a fake mouse event caused by the user typing
				// SPACE/ENTER while using JAWS.  Jaws converts the SPACE/ENTER key into mousedown/mouseup events.
				// If this.hovering is false then it's presumably actually a keyboard event.
				if(dropDown.focus && (dropDown.autoFocus !== false || (e.type == "mouseup" && !this.hovering))){
					// Do it on a delay so that we don't steal back focus from the dropdown.
					this._focusDropDownTimer = this.defer(function(){
						dropDown.focus();
						delete this._focusDropDownTimer;
					});
				}
			}else{
				// The drop down arrow icon probably can't receive focus, but widget itself should get focus.
				// defer() needed to make it work on IE (test DateTextBox)
				if(this.focus){
					this.defer("focus");
				}
			}
		},

		_onDropDownClick: function(/*Event*/ e){
			// The drop down was already opened on mousedown/keydown; just need to stop the event
			if(this._stopClickEvents){
				e.stopPropagation();
				e.preventDefault();
			}
		},

		buildRendering: function(){
			this.inherited(arguments);

			this._buttonNode = this._buttonNode || this.focusNode || this.domNode;
			this._popupStateNode = this._popupStateNode || this.focusNode || this._buttonNode;

			// Add a class to the "dijitDownArrowButton" type class to _buttonNode so theme can set direction of arrow
			// based on where drop down will normally appear
			var defaultPos = {
				"after": this.isLeftToRight() ? "Right" : "Left",
				"before": this.isLeftToRight() ? "Left" : "Right",
				"above": "Up",
				"below": "Down",
				"left": "Left",
				"right": "Right"
			}[this.dropDownPosition[0]] || this.dropDownPosition[0] || "Down";
			domClass.add(this._arrowWrapperNode || this._buttonNode, "dijit" + defaultPos + "ArrowButton");
		},

		postCreate: function(){
			// summary:
			//		set up nodes and connect our mouse and keyboard events

			this.inherited(arguments);

			var keyboardEventNode = this.focusNode || this.domNode;
			this.own(
				on(this._buttonNode, touch.press, lang.hitch(this, "_onDropDownMouseDown")),
				on(this._buttonNode, "click", lang.hitch(this, "_onDropDownClick")),
				on(keyboardEventNode, "keydown", lang.hitch(this, "_onKey")),
				on(keyboardEventNode, "keyup", lang.hitch(this, "_onKeyUp"))
			);
		},

		destroy: function(){
			// If dropdown is open, close it, to avoid leaving dijit/focus in a strange state.
			// Put focus back on me to avoid the focused node getting destroyed, which flummoxes IE.
			if(this._opened){
				this.closeDropDown(true);
			}

			if(this.dropDown){
				// Destroy the drop down, unless it's already been destroyed.  This can happen because
				// the drop down is a direct child of <body> even though it's logically my child.
				if(!this.dropDown._destroyed){
					this.dropDown.destroyRecursive();
				}
				delete this.dropDown;
			}
			this.inherited(arguments);
		},

		_onKey: function(/*Event*/ e){
			// summary:
			//		Callback when the user presses a key while focused on the button node

			if(this.disabled || this.readOnly){
				return;
			}
			var d = this.dropDown, target = e.target;
			if(d && this._opened && d.handleKey){
				if(d.handleKey(e) === false){
					/* false return code means that the drop down handled the key */
					e.stopPropagation();
					e.preventDefault();
					return;
				}
			}
			if(d && this._opened && e.keyCode == keys.ESCAPE){
				this.closeDropDown();
				e.stopPropagation();
				e.preventDefault();
			}else if(!this._opened &&
				(e.keyCode == keys.DOWN_ARROW ||
					// ignore unmodified SPACE if _KeyNavMixin has active searching in progress
					( (e.keyCode == keys.ENTER || (e.keyCode == keys.SPACE && (!this._searchTimer || (e.ctrlKey || e.altKey || e.metaKey)))) &&
						//ignore enter and space if the event is for a text input
						((target.tagName || "").toLowerCase() !== 'input' ||
							(target.type && target.type.toLowerCase() !== 'text'))))){
				// Toggle the drop down, but wait until keyup so that the drop down doesn't
				// get a stray keyup event, or in the case of key-repeat (because user held
				// down key for too long), stray keydown events
				this._toggleOnKeyUp = true;
				e.stopPropagation();
				e.preventDefault();
			}
		},

		_onKeyUp: function(){
			if(this._toggleOnKeyUp){
				delete this._toggleOnKeyUp;
				this.toggleDropDown();
				var d = this.dropDown;	// drop down may not exist until toggleDropDown() call
				if(d && d.focus){
					this.defer(lang.hitch(d, "focus"), 1);
				}
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's dropdown

			// Close dropdown but don't focus my <input>.  User may have focused somewhere else (ex: clicked another
			// input), and even if they just clicked a blank area of the screen, focusing my <input> will unwantedly
			// popup the keyboard on mobile.
			this.closeDropDown(false);

			this.inherited(arguments);
		},

		isLoaded: function(){
			// summary:
			//		Returns true if the dropdown exists and it's data is loaded.  This can
			//		be overridden in order to force a call to loadDropDown().
			// tags:
			//		protected

			return true;
		},

		loadDropDown: function(/*Function*/ loadCallback){
			// summary:
			//		Creates the drop down if it doesn't exist, loads the data
			//		if there's an href and it hasn't been loaded yet, and then calls
			//		the given callback.
			// tags:
			//		protected

			// TODO: for 2.0, change API to return a Deferred, instead of calling loadCallback?
			loadCallback();
		},

		loadAndOpenDropDown: function(){
			// summary:
			//		Creates the drop down if it doesn't exist, loads the data
			//		if there's an href and it hasn't been loaded yet, and
			//		then opens the drop down.  This is basically a callback when the
			//		user presses the down arrow button to open the drop down.
			// returns: Deferred
			//		Deferred for the drop down widget that
			//		fires when drop down is created and loaded
			// tags:
			//		protected
			var d = new Deferred(),
				afterLoad = lang.hitch(this, function(){
					this.openDropDown();
					d.resolve(this.dropDown);
				});
			if(!this.isLoaded()){
				this.loadDropDown(afterLoad);
			}else{
				afterLoad();
			}
			return d;
		},

		toggleDropDown: function(){
			// summary:
			//		Callback when the user presses the down arrow button or presses
			//		the down arrow key to open/close the drop down.
			//		Toggle the drop-down widget; if it is up, close it, if not, open it
			// tags:
			//		protected

			if(this.disabled || this.readOnly){
				return;
			}
			if(!this._opened){
				this.loadAndOpenDropDown();
			}else{
				this.closeDropDown(true);	// refocus button to avoid hiding node w/focus
			}
		},

		openDropDown: function(){
			// summary:
			//		Opens the dropdown for this widget.   To be called only when this.dropDown
			//		has been created and is ready to display (ie, it's data is loaded).
			// returns:
			//		return value of dijit/popup.open()
			// tags:
			//		protected

			var dropDown = this.dropDown,
				ddNode = dropDown.domNode,
				aroundNode = this._aroundNode || this.domNode,
				self = this;

			var retVal = popup.open({
				parent: this,
				popup: dropDown,
				around: aroundNode,
				orient: this.dropDownPosition,
				maxHeight: this.maxHeight,
				onExecute: function(){
					self.closeDropDown(true);
				},
				onCancel: function(){
					self.closeDropDown(true);
				},
				onClose: function(){
					domAttr.set(self._popupStateNode, "popupActive", false);
					domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
					self._set("_opened", false);	// use set() because _CssStateMixin is watching
				}
			});

			// Set width of drop down if necessary, so that dropdown width + width of scrollbar (from popup wrapper)
			// matches width of aroundNode
			if(this.forceWidth || (this.autoWidth && aroundNode.offsetWidth > dropDown._popupWrapper.offsetWidth)){
				var widthAdjust = aroundNode.offsetWidth - dropDown._popupWrapper.offsetWidth;
				var resizeArgs = {
					w: dropDown.domNode.offsetWidth + widthAdjust
				};
				this._origStyle = ddNode.style.cssText;
				if(lang.isFunction(dropDown.resize)){
					dropDown.resize(resizeArgs);
				}else{
					domGeometry.setMarginBox(ddNode, resizeArgs);
				}

				// If dropdown is right-aligned then compensate for width change by changing horizontal position
				if(retVal.corner[1] == "R"){
					dropDown._popupWrapper.style.left =
						(dropDown._popupWrapper.style.left.replace("px", "") - widthAdjust) + "px";
				}
			}

			domAttr.set(this._popupStateNode, "popupActive", "true");
			domClass.add(this._popupStateNode, "dijitHasDropDownOpen");
			this._set("_opened", true);	// use set() because _CssStateMixin is watching

			this._popupStateNode.setAttribute("aria-expanded", "true");
			this._popupStateNode.setAttribute("aria-owns", dropDown.id);

			// Set aria-labelledby on dropdown if it's not already set to something more meaningful
			if(ddNode.getAttribute("role") !== "presentation" && !ddNode.getAttribute("aria-labelledby")){
				ddNode.setAttribute("aria-labelledby", this.id);
			}

			return retVal;
		},

		closeDropDown: function(/*Boolean*/ focus){
			// summary:
			//		Closes the drop down on this widget
			// focus:
			//		If true, refocuses the button widget
			// tags:
			//		protected

			if(this._focusDropDownTimer){
				this._focusDropDownTimer.remove();
				delete this._focusDropDownTimer;
			}

			if(this._opened){
				this._popupStateNode.setAttribute("aria-expanded", "false");
				if(focus && this.focus){
					this.focus();
				}
				popup.close(this.dropDown);
				this._opened = false;
			}

			if(this._origStyle){
				this.dropDown.domNode.style.cssText = this._origStyle;
				delete this._origStyle;
			}
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/MapBus':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18
 *
 * (C) COPYRIGHT IBM CORP. 2023,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define( 
    [
        "dojo/_base/declare",
        "ibm/tivoli/fwm/mxmap/MaximoIntegration",
    ], 
    function ( 
        declare,
        MaximoIntegration
    ) {
        return declare(null, {

            serverUpdatesHandler: null,

            constructor: function (options, map) {
                this.options = options;
                this.map = map;
                this.maximo = new MaximoIntegration(options);
            },

            getMapConf: function() {
                return this.options.mapConf;
            },

            getRouteConf: function(){
                return this.options.routeConf;
            },

            getMaximoIntegration: function() {
                return this.maximo;
            },

            subscribeServerUpdates: function(handler) {
                this.serverUpdatesHandler = handler;
            },

            onServerUpdates: function(eventName, eventParams) {
                if (!this.serverUpdatesHandler) {
                    return;
                }

                this.serverUpdatesHandler(eventName, eventParams);
            },

            subscribeMapLoaded: function(handler) {
                this.mapLoadedHandler = handler;
            },

            onMapLoaded: function() {
                if (!this.mapLoadedHandler) {
                    return;
                }

                this.mapLoadedHandler();
            },

            setRoutesStore: function(routesStore) {
                this.routesStore = routesStore
            },

            initRoutes: function() {
                if (!this.routesStore) {
                    return;
                }

                this.routesStore.init();
            },

            drawRoutes: function(routes) {
                if (!this.routesStore) {
                    return;
                }

                this.routesStore.drawRoutes(routes);
            },

            clearRoutes: function() {
                this.routesStore.clearRoutes();
            },

            setLinearStoreAndInit: function(linearStore) {
                var mapConf = this.getMapConf();
                this.linearStore = linearStore;
                this.linearStore.init(mapConf.parentApplication);
                this.drawLinearSegments();
                this.linearStore.subscribeToOpen(dojo.hitch(this, this.openLinearVisualControl));
                this.linearStore.subscribeToClose(dojo.hitch(this, this.closeLinearVisualControl));
            },

            openLinearVisualControl: function(assetnum) {
                dojo.publish("linear.map.visibility", [{
                    enabled: true,
                    trow: assetnum,
                    currentTabId: 'mxmap',
                    mapObj: this.map
                }]);
            },

            closeLinearVisualControl: function(assetnum) {
                dojo.publish("linear.map.visibility", [{
                    enabled: false,
                    trow: assetnum,
                    currentTabId: 'mxmap',
                    mapObj: this.map
                }]);
            },

            highlightLinearFeature: function(linearFeature) {
                this.linearStore.highlightLinearFeature(linearFeature);
            },

            drawLinearSegments: function() {
                var mapConf = this.getMapConf();
                var linearConf = mapConf.maplinearConf;
                this.linearStore.drawSegments(linearConf.maplinearLayers)
            }

        });
    } 
);

},
'ibm/tivoli/fwm/mxmap/layers/LayerPanelWidget':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/main","dijit/main",
		"dojo/_base/declare","ibm/tivoli/fwm/mxmap/_Base",
		"dijit/_Widget",
		"dijit/_Templated",
		"ibm/tivoli/fwm/mxmap/panels/MobileInfoPanelDialog",
		"ibm/tivoli/fwm/mxmap/layers/LayerWidget",
		"ibm/tivoli/fwm/mxmap/layers/LegendLayer",
		"ibm/tivoli/fwm/mxmap/layers/SymbologyLayer"], 
		function(dojo, dijit, declare, _Base, _Widget, _Templated, MobileInfoPanelDialog, LayerWidget, LegendLayer, SymbologyLayer) {
	
	var LayerPanelWidget = declare([_Widget, _Templated, _Base], {
		templateString: dojo.cache("ibm.tivoli.fwm.mxmap", "templates/LayerPanelWidget.html", "<div class=\"text\">\n\t<div data-dojo-attach-point=\"layers\"></div>\n</div>"),
		infoPanel: null,
		map: null,
		_layers: null,
		_title: null,
		_div: null,
		constructor: function(params) 
		{
			dojo.mixin(this, params);
			this._layers = [];
			this._title = params.title;
			if((params.tool != undefined) && (params.tool != null))
			{
				params.tool.setPanelWidget(this);
			}
			// this._title = ibm.tivoli.fwm.i18n.getMaxMsg("map", "layers");
		},
		postCreate: function()
		{
		},
		// newLayers can be any type of Layer object (layer, symbology, legend)
		updateLayers: function(newLayers /* [] of Layer */)
		{
			if (dojo.config.fwm.debug == true)
			{
				console.log("[LayerPanelWidget] Update Layers: ", newLayers);
			}
			dojo.forEach(this._layers, function(layer)
			{
				layer.destroyRecursive(true);
			});
			var div = dojo.create("div");
			
			
			dojo.style(div, {
				borderBottom : '1px solid #E0E0E0'
			});
			
			this._layers = [];

			for ( var i = 0; i < newLayers.length; i++)
			{
				if (newLayers[i].isVisibleInUI()) // Don't show empty layers
				{
					var layerWidget = new LayerWidget({
						layer: newLayers[i],
						layerPanel: this,
						closeOnAction: false
					});
					dojo.place(layerWidget.domNode, div, 'last');
					this._layers.push(layerWidget);
				}
			}
			dojo.place(div, this.layers, 'only');
			
			var customButtonArray = [];
			var resetBtn = null;
			var resetButtonLabel = ibm.tivoli.fwm.i18n.getMaxMsg("map", "resetlayers");
			var backBtn = null;
			var backButtonLabel = ibm.tivoli.fwm.i18n.getMaxMsg("map", "layersbackbtn");

			// Change the title of the panel according to the type of symbology
			if (newLayers[0] instanceof SymbologyLayer)
			{
				this._title = this._title || ibm.tivoli.fwm.i18n.getMaxMsg("map", "symbologydialogtitle");
				// Button to reset all symbologies for a layer
				resetBtn = this.createButtonParams(
					dojo.hitch(this, 
						function()
						{
							var layer = newLayers[0].getParentLayer();
							this.map.getLayersManager().resetSymbologies(layer);
							this.updateIcons();
						}
					),
					resetButtonLabel
				);
				customButtonArray.push(resetBtn);
			}
			else if (newLayers[0] instanceof LegendLayer)
			{
				this._title = this._title || ibm.tivoli.fwm.i18n.getMaxMsg("map", "legenddialogtitle");
				// Button to go back to the symbology dialog
				backBtn = this.createButtonParams(
					dojo.hitch(this, 
						function()
						{
							// The idea here is to get the Layer (which is the grandparent of legend - Layer->Symbology->Legend)  
							var layer = newLayers[0].getParentLayer().getParentLayer();
							if(layer != null)
							{
								// Create another dialog for the children of layer (symbologies)
								var panel = new LayerPanelWidget({map: this.map, tool: this.tool, title: layer.getChildrenTitle()});	
								// populate the dialog with the simbologies
								panel.updateLayers(layer.getChildren());
								// Close the current dialog
								this.close();
							}
						}
					),
					backButtonLabel
				);
				customButtonArray.push(backBtn);

				// Button to reset all legends for a symbology
				resetBtn = this.createButtonParams(
					dojo.hitch(this, 
						function()
						{
							var symbology = newLayers[0].getParentLayer();
							this.map.getLayersManager().resetLegends(symbology);
							this.updateIcons();
						}
					),
					resetButtonLabel
				);
				customButtonArray.push(resetBtn);
			}
			else
			{
				this._title = this._title || ibm.tivoli.fwm.i18n.getMaxMsg("map", "layers");
				// Button to reset all layers
				resetBtn = this.createButtonParams(
					dojo.hitch(this, 
						function()
						{
							this.map.getLayersManager().resetLayers();
							this.updateIcons();
						}
					),
					resetButtonLabel
				);
				customButtonArray.push(resetBtn);
			}

			this.close();

			this.infoPanel = new MobileInfoPanelDialog({
				map: this.map,
				title: this._title,
				nonModal: true,
				customButtons: customButtonArray
			});
			this.infoPanel.setContent(this.domNode);
			this.infoPanel.show(true);
		},
		close: function()
		{
			if (this.infoPanel)
			{
				this.infoPanel.close();
				this.infoPanel = null;
			}
		},
		updateIcons: function()
		{
			dojo.forEach(this._layers, function(layer)
					{
						layer.setLeftIcon();
					});
		},
		createButtonParams: function(action, label)
		{
			return btnParams = {
				label: label,
				onClick: dojo.hitch(this, function()
				{
					action();
				})
			};
		}
	});
	
	return LayerPanelWidget;
});

},
'dijit/_MenuBase':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.indexOf
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant domClass.replace
	"dojo/dom-attr",
	"dojo/dom-class", // domClass.replace
	"dojo/_base/lang", // lang.hitch
	"dojo/mouse", // mouse.enter, mouse.leave
	"dojo/on",
	"dojo/window",
	"./a11yclick",
	"./registry",
	"./_Widget",
	"./_CssStateMixin",
	"./_KeyNavContainer",
	"./_TemplatedMixin"
], function(array, declare, dom, domAttr, domClass, lang, mouse, on, winUtils, a11yclick,
			registry, _Widget, _CssStateMixin, _KeyNavContainer, _TemplatedMixin){

	// module:
	//		dijit/_MenuBase

	return declare("dijit._MenuBase", [_Widget, _TemplatedMixin, _KeyNavContainer, _CssStateMixin], {
		// summary:
		//		Abstract base class for Menu and MenuBar.
		//		Subclass should implement _onUpArrow(), _onDownArrow(), _onLeftArrow(), and _onRightArrow().

		// selected: dijit/MenuItem
		//		Currently selected (a.k.a. highlighted) MenuItem, or null if no MenuItem is selected.
		//		If a submenu is open, will be set to MenuItem that displayed the submenu.   OTOH, if
		//		this Menu is in passive mode (i.e. hasn't been clicked yet), will be null, because
		//		"selected" is not merely "hovered".
		selected: null,
		_setSelectedAttr: function(item){
			if(this.selected != item){
				if(this.selected){
					this.selected._setSelected(false);
					this._onChildDeselect(this.selected);
				}
				if(item){
					item._setSelected(true);
				}
				this._set("selected", item);
			}
		},

		// activated: [readonly] Boolean
		//		This Menu has been clicked (mouse or via space/arrow key) or opened as a submenu,
		//		so mere mouseover will open submenus.  Focusing a menu via TAB does NOT automatically make it active
		//		since TAB is a navigation operation and not a selection one.
		//		For Windows apps, pressing the ALT key focuses the menubar menus (similar to TAB navigation) but the
		//		menu is not active (ie no dropdown) until an item is clicked.
		activated: false,
		_setActivatedAttr: function(val){
			domClass.toggle(this.domNode, "dijitMenuActive", val);
			domClass.toggle(this.domNode, "dijitMenuPassive", !val);
			this._set("activated", val);
		},

		// parentMenu: [readonly] Widget
		//		pointer to menu that displayed me
		parentMenu: null,

		// popupDelay: Integer
		//		After a menu has been activated (by clicking on it etc.), number of milliseconds before hovering
		//		(without clicking) another MenuItem causes that MenuItem's popup to automatically open.
		popupDelay: 500,

		// passivePopupDelay: Integer
		//		For a passive (unclicked) Menu, number of milliseconds before hovering (without clicking) will cause
		//		the popup to open.  Default is Infinity, meaning you need to click the menu to open it.
		passivePopupDelay: Infinity,

		// autoFocus: Boolean
		//		A toggle to control whether or not a Menu gets focused when opened as a drop down from a MenuBar
		//		or DropDownButton/ComboButton.   Note though that it always get focused when opened via the keyboard.
		autoFocus: false,

		childSelector: function(/*DOMNode*/ node){
			// summary:
			//		Selector (passed to on.selector()) used to identify MenuItem child widgets, but exclude inert children
			//		like MenuSeparator.  If subclass overrides to a string (ex: "> *"), the subclass must require dojo/query.
			// tags:
			//		protected

			var widget = registry.byNode(node);
			return node.parentNode == this.containerNode && widget && widget.focus;
		},

		postCreate: function(){
			var self = this,
				matches = typeof this.childSelector == "string" ? this.childSelector : lang.hitch(this, "childSelector");
			this.own(
				on(this.containerNode, on.selector(matches, mouse.enter), function(){
					self.onItemHover(registry.byNode(this));
				}),
				on(this.containerNode, on.selector(matches, mouse.leave), function(){
					self.onItemUnhover(registry.byNode(this));
				}),
				on(this.containerNode, on.selector(matches, a11yclick), function(evt){
					self.onItemClick(registry.byNode(this), evt);
					evt.stopPropagation();
				}),
				on(this.containerNode, on.selector(matches, "focusin"), function(){
					self._onItemFocus(registry.byNode(this));
				})
			);
			this.inherited(arguments);
		},

		onKeyboardSearch: function(/*MenuItem*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){
			// summary:
			//		Attach point for notification about when a menu item has been searched for
			//		via the keyboard search mechanism.
			// tags:
			//		protected
			this.inherited(arguments);
			if(!!item && (numMatches == -1 || (!!item.popup && numMatches == 1))){
				this.onItemClick(item, evt);
			}
		},

		_keyboardSearchCompare: function(/*dijit/_WidgetBase*/ item, /*String*/ searchString){
			// summary:
			//		Compares the searchString to the widget's text label, returning:
			//		-1: a high priority match and stop searching
			//		 0: no match
			//		 1: a match but keep looking for a higher priority match
			// tags:
			//		private
			if(!!item.shortcutKey){
				// accessKey matches have priority
				return searchString == item.shortcutKey.toLowerCase() ? -1 : 0;
			}
			return this.inherited(arguments) ? 1 : 0; // change return value of -1 to 1 so that searching continues
		},

		onExecute: function(){
			// summary:
			//		Attach point for notification about when a menu item has been executed.
			//		This is an internal mechanism used for Menus to signal to their parent to
			//		close them, because they are about to execute the onClick handler.  In
			//		general developers should not attach to or override this method.
			// tags:
			//		protected
		},

		onCancel: function(/*Boolean*/ /*===== closeAll =====*/){
			// summary:
			//		Attach point for notification about when the user cancels the current menu
			//		This is an internal mechanism used for Menus to signal to their parent to
			//		close them.  In general developers should not attach to or override this method.
			// tags:
			//		protected
		},

		_moveToPopup: function(/*Event*/ evt){
			// summary:
			//		This handles the right arrow key (left arrow key on RTL systems),
			//		which will either open a submenu, or move to the next item in the
			//		ancestor MenuBar
			// tags:
			//		private

			if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
				this.onItemClick(this.focusedChild, evt);
			}else{
				var topMenu = this._getTopMenu();
				if(topMenu && topMenu._isMenuBar){
					topMenu.focusNext();
				}
			}
		},

		_onPopupHover: function(/*Event*/ /*===== evt =====*/){
			// summary:
			//		This handler is called when the mouse moves over the popup.
			// tags:
			//		private

			// if the mouse hovers over a menu popup that is in pending-close state,
			// then stop the close operation.
			// This can't be done in onItemHover since some popup targets don't have MenuItems (e.g. ColorPicker)

			// highlight the parent menu item pointing to this popup (in case user temporarily moused over another MenuItem)
			this.set("selected", this.currentPopupItem);

			// cancel the pending close (if there is one) (in case user temporarily moused over another MenuItem)
			this._stopPendingCloseTimer();
		},

		onItemHover: function(/*MenuItem*/ item){
			// summary:
			//		Called when cursor is over a MenuItem.
			// tags:
			//		protected

			// Don't do anything unless user has "activated" the menu by:
			//		1) clicking it
			//		2) opening it from a parent menu (which automatically activates it)

			if(this.activated){
				this.set("selected", item);
				if(item.popup && !item.disabled && !this.hover_timer){
					this.hover_timer = this.defer(function(){
						this._openItemPopup(item);
					}, this.popupDelay);
				}
			}else if(this.passivePopupDelay < Infinity){
				if(this.passive_hover_timer){
					this.passive_hover_timer.remove();
				}
				this.passive_hover_timer = this.defer(function(){
					this.onItemClick(item, {type: "click"});
				}, this.passivePopupDelay);
			}

			this._hoveredChild = item;

			item._set("hovering", true);
		},

		_onChildDeselect: function(item){
			// summary:
			//		Called when a child MenuItem becomes deselected.   Setup timer to close its popup.

			this._stopPopupTimer();

			// Setup timer to close all popups that are open and descendants of this menu.
			// Will be canceled if user quickly moves the mouse over the popup.
			if(this.currentPopupItem == item){
				this._stopPendingCloseTimer();
				this._pendingClose_timer = this.defer(function(){
					this._pendingClose_timer = null;
					this.currentPopupItem = null;
					item._closePopup(); // this calls onClose
				}, this.popupDelay);
			}
		},

		onItemUnhover: function(/*MenuItem*/ item){
			// summary:
			//		Callback fires when mouse exits a MenuItem
			// tags:
			//		protected

			if(this._hoveredChild == item){
				this._hoveredChild = null;
			}

			if(this.passive_hover_timer){
				this.passive_hover_timer.remove();
				this.passive_hover_timer = null;
			}

			item._set("hovering", false);
		},

		_stopPopupTimer: function(){
			// summary:
			//		Cancels the popup timer because the user has stop hovering
			//		on the MenuItem, etc.
			// tags:
			//		private

			if(this.hover_timer){
				this.hover_timer = this.hover_timer.remove();
			}
		},

		_stopPendingCloseTimer: function(){
			// summary:
			//		Cancels the pending-close timer because the close has been preempted
			// tags:
			//		private
			if(this._pendingClose_timer){
				this._pendingClose_timer = this._pendingClose_timer.remove();
			}
		},

		_getTopMenu: function(){
			// summary:
			//		Returns the top menu in this chain of Menus
			// tags:
			//		private
			for(var top = this; top.parentMenu; top = top.parentMenu){}
			return top;
		},

		onItemClick: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt){
			// summary:
			//		Handle clicks on an item.
			// tags:
			//		private

			if(this.passive_hover_timer){
				this.passive_hover_timer.remove();
			}

			this.focusChild(item);

			if(item.disabled){
				return false;
			}

			if(item.popup){
				this.set("selected", item);
				this.set("activated", true);
				var byKeyboard = /^key/.test(evt._origType || evt.type) ||
					(evt.clientX == 0 && evt.clientY == 0);	// detects accessKey like ALT+SHIFT+F, where type is "click"
				this._openItemPopup(item, byKeyboard);
			}else{
				// before calling user defined handler, close hierarchy of menus
				// and restore focus to place it was when menu was opened
				this.onExecute();

				// user defined handler for click
				item._onClick ? item._onClick(evt) : item.onClick(evt);
			}
		},

		_openItemPopup: function(/*dijit/MenuItem*/ from_item, /*Boolean*/ focus){
			// summary:
			//		Open the popup to the side of/underneath the current menu item, and optionally focus first item
			// tags:
			//		protected

			if(from_item == this.currentPopupItem){
				// Specified popup is already being shown, so just return
				return;
			}
			if(this.currentPopupItem){
				// If another popup is currently shown, then close it
				this._stopPendingCloseTimer();
				this.currentPopupItem._closePopup();
			}
			this._stopPopupTimer();

			var popup = from_item.popup;
			popup.parentMenu = this;

			// detect mouseover of the popup to handle lazy mouse movements that temporarily focus other menu items\c
			this.own(this._mouseoverHandle = on.once(popup.domNode, "mouseover", lang.hitch(this, "_onPopupHover")));

			var self = this;
			from_item._openPopup({
				parent: this,
				orient: this._orient || ["after", "before"],
				onCancel: function(){ // called when the child menu is canceled
					if(focus){
						// put focus back on my node before focused node is hidden
						self.focusChild(from_item);
					}

					// close the submenu (be sure this is done _after_ focus is moved)
					self._cleanUp();
				},
				onExecute: lang.hitch(this, "_cleanUp", true),
				onClose: function(){
					// Remove handler created by onItemHover
					if(self._mouseoverHandle){
						self._mouseoverHandle.remove();
						delete self._mouseoverHandle;
					}
				}
			}, focus);

			this.currentPopupItem = from_item;

			// TODO: focusing a popup should clear tabIndex on Menu (and it's child MenuItems), so that neither
			// TAB nor SHIFT-TAB returns to the menu.  Only ESC or ENTER should return to the menu.
		},

		onOpen: function(/*Event*/ /*===== e =====*/){
			// summary:
			//		Callback when this menu is opened.
			//		This is called by the popup manager as notification that the menu
			//		was opened.
			// tags:
			//		private

			this.isShowingNow = true;
			this.set("activated", true);
		},

		onClose: function(){
			// summary:
			//		Callback when this menu is closed.
			//		This is called by the popup manager as notification that the menu
			//		was closed.
			// tags:
			//		private

			this.set("activated", false);
			this.set("selected", null);
			this.isShowingNow = false;
			this.parentMenu = null;
		},

		_closeChild: function(){
			// summary:
			//		Called when submenu is clicked or focus is lost.  Close hierarchy of menus.
			// tags:
			//		private
			this._stopPopupTimer();

			if(this.currentPopupItem){
				// If focus is on a descendant MenuItem then move focus to me,
				// because IE doesn't like it when you display:none a node with focus,
				// and also so keyboard users don't lose control.
				// Likely, immediately after a user defined onClick handler will move focus somewhere
				// else, like a Dialog.
				if(this.focused){
					domAttr.set(this.selected.focusNode, "tabIndex", this.tabIndex);
					this.selected.focusNode.focus();
				}

				// Close all popups that are open and descendants of this menu
				this.currentPopupItem._closePopup();
				this.currentPopupItem = null;
			}
		},

		_onItemFocus: function(/*MenuItem*/ item){
			// summary:
			//		Called when child of this Menu gets focus from:
			//
			//		1. clicking it
			//		2. tabbing into it
			//		3. being opened by a parent menu.
			//
			//		This is not called just from mouse hover.

			if(this._hoveredChild && this._hoveredChild != item){
				this.onItemUnhover(this._hoveredChild);	// any previous mouse movement is trumped by focus selection
			}
			this.set("selected", item);
		},

		_onBlur: function(){
			// summary:
			//		Called when focus is moved away from this Menu and it's submenus.
			// tags:
			//		protected

			this._cleanUp(true);
			this.inherited(arguments);
		},

		_cleanUp: function(/*Boolean*/ clearSelectedItem){
			// summary:
			//		Called when the user is done with this menu.  Closes hierarchy of menus.
			// tags:
			//		private

			this._closeChild(); // don't call this.onClose since that's incorrect for MenuBar's that never close
			if(typeof this.isShowingNow == 'undefined'){ // non-popup menu doesn't call onClose
				this.set("activated", false);
			}

			if(clearSelectedItem){
				this.set("selected", null);
			}
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/impl/point/BingLatLonPoint':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_LatLonPoint"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

dojo.require("ibm.tivoli.fwm.mxmap._LatLonPoint");
dojo.provide("ibm.tivoli.fwm.mxmap.impl.point.BingLatLonPoint");

/**
 * BingLatLonPoint
 */
dojo.declare("ibm.tivoli.fwm.mxmap.impl.point.BingLatLonPoint", ibm.tivoli.fwm.mxmap._LatLonPoint, {
	
	/**
	 * Returns a new proprietary instance of Microsoft.Maps.Location object.
	 */
	toProprietary: function()
	{
		return new Microsoft.Maps.Location(this.lat, this.lon);
	},

	/**
	 * Encapsulates the latitute/longitude coordinates into lat/lon
	 * mapstraction attributes.
	 */
	fromProprietary: function(mpoint)
	{
		// Converts from Microsoft Point to LatLng
		if((mpoint.latitude != undefined) && (mpoint.latitude != undefined))
		{
			this.lat = mpoint.latitude;
			this.lon = mpoint.longitude;
			this.lng = mpoint.longitude;
		}
		// Just another way of parsing the lat/lon point (MS Point returned from Bing REST API)
		else if(mpoint.coordinates != undefined)
		{
			this.lat = mpoint.coordinates[0];
			this.lon = mpoint.coordinates[1];
			this.lng = mpoint.coordinates[1];
		}
	}
	
});

});

},
'dijit/focus':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom", // domAttr.get dom.isDescendant
	"dojo/dom-attr", // domAttr.get dom.isDescendant
	"dojo/dom-class",
	"dojo/dom-construct", // connect to domConstruct.empty, domConstruct.destroy
	"dojo/Evented",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/domReady",
	"dojo/sniff", // has("ie")
	"dojo/Stateful",
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.get
	"./a11y",	// a11y.isTabNavigable
	"./registry",	// registry.byId
	"./main"		// to set dijit.focus
], function(aspect, declare, dom, domAttr, domClass, domConstruct, Evented, lang, on, domReady, has, Stateful, win, winUtils,
			a11y, registry, dijit){

	// module:
	//		dijit/focus

	// Time of the last focusin event
	var lastFocusin;

	// Time of the last touch/mousedown or focusin event
	var lastTouchOrFocusin;

	var FocusManager = declare([Stateful, Evented], {
		// summary:
		//		Tracks the currently focused node, and which widgets are currently "active".
		//		Access via require(["dijit/focus"], function(focus){ ... }).
		//
		//		A widget is considered active if it or a descendant widget has focus,
		//		or if a non-focusable node of this widget or a descendant was recently clicked.
		//
		//		Call focus.watch("curNode", callback) to track the current focused DOMNode,
		//		or focus.watch("activeStack", callback) to track the currently focused stack of widgets.
		//
		//		Call focus.on("widget-blur", func) or focus.on("widget-focus", ...) to monitor when
		//		when widgets become active/inactive
		//
		//		Finally, focus(node) will focus a node, suppressing errors if the node doesn't exist.

		// curNode: DomNode
		//		Currently focused item on screen
		curNode: null,

		// activeStack: dijit/_WidgetBase[]
		//		List of currently active widgets (focused widget and it's ancestors)
		activeStack: [],

		constructor: function(){
			// Don't leave curNode/prevNode pointing to bogus elements
			var check = lang.hitch(this, function(node){
				if(dom.isDescendant(this.curNode, node)){
					this.set("curNode", null);
				}
				if(dom.isDescendant(this.prevNode, node)){
					this.set("prevNode", null);
				}
			});
			aspect.before(domConstruct, "empty", check);
			aspect.before(domConstruct, "destroy", check);
		},

		registerIframe: function(/*DomNode*/ iframe){
			// summary:
			//		Registers listeners on the specified iframe so that any click
			//		or focus event on that iframe (or anything in it) is reported
			//		as a focus/click event on the `<iframe>` itself.
			// description:
			//		Currently only used by editor.
			// returns:
			//		Handle with remove() method to deregister.
			return this.registerWin(iframe.contentWindow, iframe);
		},

		registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow:
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode:
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle with remove() method to deregister.

			// TODO: make this function private in 2.0; Editor/users should call registerIframe(),

			// Listen for blur and focus events on targetWindow's document.
			var _this = this,
				body = targetWindow.document && targetWindow.document.body;

			if(body){
				// Listen for touches or mousedowns... could also use dojo/touch.press here.
				var event = has("pointer-events") ? "pointerdown" : has("MSPointer") ? "MSPointerDown" :
					has("touch-events") ? "mousedown, touchstart" : "mousedown";
				var mdh = on(targetWindow.document, event, function(evt){
					// workaround weird IE bug where the click is on an orphaned node
					// (first time clicking a Select/DropDownButton inside a TooltipDialog).
					// actually, strangely this is happening on latest chrome too.
					if(evt && evt.target && evt.target.parentNode == null){
						return;
					}

					_this._onTouchNode(effectiveNode || evt.target, "mouse");
				});

				var fih = on(body, 'focusin', function(evt){
					// When you refocus the browser window, IE gives an event with an empty srcElement
					if(!evt.target.tagName) { return; }

					// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
					// ignore those events
					var tag = evt.target.tagName.toLowerCase();
					if(tag == "#document" || tag == "body"){ return; }

					if(a11y.isFocusable(evt.target)){
						_this._onFocusNode(effectiveNode || evt.target);
					}else{
						// Previous code called _onTouchNode() for any activate event on a non-focusable node.   Can
						// probably just ignore such an event as it will be handled by onmousedown handler above, but
						// leaving the code for now.
						_this._onTouchNode(effectiveNode || evt.target);
					}
				});

				var foh = on(body, 'focusout', function(evt){
					_this._onBlurNode(effectiveNode || evt.target);
				});

				return {
					remove: function(){
						mdh.remove();
						fih.remove();
						foh.remove();
						mdh = fih = foh = null;
						body = null;	// prevent memory leak (apparent circular reference via closure)
					}
				};
			}
		},

		_onBlurNode: function(/*DomNode*/ node){
			// summary:
			//		Called when focus leaves a node.
			//		Usually ignored, _unless_ it *isn't* followed by touching another node,
			//		which indicates that we tabbed off the last field on the page,
			//		in which case every widget is marked inactive

			var now = (new Date()).getTime();

			// IE9+ and chrome have a problem where focusout events come after the corresponding focusin event.
			// For chrome problem see https://bugs.dojotoolkit.org/ticket/17668.
			// IE problem happens when moving focus from the Editor's <iframe> to a normal DOMNode.
			if(now < lastFocusin + 100){
				return;
			}

			// If the blur event isn't followed by a focus event, it means the user clicked on something unfocusable,
			// so clear focus.
			if(this._clearFocusTimer){
				clearTimeout(this._clearFocusTimer);
			}
			this._clearFocusTimer = setTimeout(lang.hitch(this, function(){
				this.set("prevNode", this.curNode);
				this.set("curNode", null);
			}), 0);

			// Unset timer to zero-out widget stack; we'll reset it below if appropriate.
			if(this._clearActiveWidgetsTimer){
				clearTimeout(this._clearActiveWidgetsTimer);
			}

			if(now < lastTouchOrFocusin + 100){
				// This blur event is coming late (after the call to _onTouchNode() rather than before.
				// So let _onTouchNode() handle setting the widget stack.
				// See https://bugs.dojotoolkit.org/ticket/17668
				return;
			}

			// If the blur event isn't followed (or preceded) by a focus or touch event then mark all widgets as inactive.
			this._clearActiveWidgetsTimer = setTimeout(lang.hitch(this, function(){
				delete this._clearActiveWidgetsTimer;
				this._setStack([]);
			}), 0);
		},

		_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
			// summary:
			//		Callback when node is focused or touched.
			//		Note that _onFocusNode() calls _onTouchNode().
			// node:
			//		The node that was touched.
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			// Keep track of time of last focusin or touch event.
			lastTouchOrFocusin = (new Date()).getTime();

			if(this._clearActiveWidgetsTimer){
				// forget the recent blur event
				clearTimeout(this._clearActiveWidgetsTimer);
				delete this._clearActiveWidgetsTimer;
			}

			// if the click occurred on the scrollbar of a dropdown, treat it as a click on the dropdown,
			// even though the scrollbar is technically on the popup wrapper (see #10631)
			if(domClass.contains(node, "dijitPopup")){
				node = node.firstChild;
			}

			// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
			var newStack=[];
			try{
				while(node){
					var popupParent = domAttr.get(node, "dijitPopupParent");
					if(popupParent){
						node=registry.byId(popupParent).domNode;
					}else if(node.tagName && node.tagName.toLowerCase() == "body"){
						// is this the root of the document or just the root of an iframe?
						if(node === win.body()){
							// node is the root of the main document
							break;
						}
						// otherwise, find the iframe this node refers to (can't access it via parentNode,
						// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
						node=winUtils.get(node.ownerDocument).frameElement;
					}else{
						// if this node is the root node of a widget, then add widget id to stack,
						// except ignore clicks on disabled widgets (actually focusing a disabled widget still works,
						// to support MenuItem)
						var id = node.getAttribute && node.getAttribute("widgetId"),
							widget = id && registry.byId(id);
						if(widget && !(by == "mouse" && widget.get("disabled"))){
							newStack.unshift(id);
						}
						node=node.parentNode;
					}
				}
			}catch(e){ /* squelch */ }

			this._setStack(newStack, by);
		},

		_onFocusNode: function(/*DomNode*/ node){
			// summary:
			//		Callback when node is focused

			if(!node){
				return;
			}

			if(node.nodeType == 9){
				// Ignore focus events on the document itself.  This is here so that
				// (for example) clicking the up/down arrows of a spinner
				// (which don't get focus) won't cause that widget to blur. (FF issue)
				return;
			}

			// Keep track of time of last focusin event.
			lastFocusin = (new Date()).getTime();

			// There was probably a blur event right before this event, but since we have a new focus,
			// forget about the blur
			if(this._clearFocusTimer){
				clearTimeout(this._clearFocusTimer);
				delete this._clearFocusTimer;
			}

			this._onTouchNode(node);

			if(node == this.curNode){ return; }
			this.set("prevNode", this.curNode);
			this.set("curNode", node);
		},

		_setStack: function(/*String[]*/ newStack, /*String*/ by){
			// summary:
			//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
			// newStack:
			//		array of widget id's, starting from the top (outermost) widget
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			var oldStack = this.activeStack, lastOldIdx = oldStack.length - 1, lastNewIdx = newStack.length - 1;

			if(newStack[lastNewIdx] == oldStack[lastOldIdx]){
				// no changes, return now to avoid spurious notifications about changes to activeStack
				return;
			}

			this.set("activeStack", newStack);

			var widget, i;

			// for all elements that have gone out of focus, set focused=false
			for(i = lastOldIdx; i >= 0 && oldStack[i] != newStack[i]; i--){
				widget = registry.byId(oldStack[i]);
				if(widget){
					widget._hasBeenBlurred = true;		// TODO: used by form widgets, should be moved there
					widget.set("focused", false);
					if(widget._focusManager == this){
						widget._onBlur(by);
					}
					this.emit("widget-blur", widget, by);
				}
			}

			// for all element that have come into focus, set focused=true
			for(i++; i <= lastNewIdx; i++){
				widget = registry.byId(newStack[i]);
				if(widget){
					widget.set("focused", true);
					if(widget._focusManager == this){
						widget._onFocus(by);
					}
					this.emit("widget-focus", widget, by);
				}
			}
		},

		focus: function(node){
			// summary:
			//		Focus the specified node, suppressing errors if they occur
			if(node){
				try{ node.focus(); }catch(e){/*quiet*/}
			}
		}
	});

	var singleton = new FocusManager();

	// register top window and all the iframes it contains
	domReady(function(){
		var handle = singleton.registerWin(winUtils.get(document));
		if(has("ie")){
			on(window, "unload", function(){
				if(handle){	// because this gets called twice when doh.robot is running
					handle.remove();
					handle = null;
				}
			});
		}
	});

	// Setup dijit.focus as a pointer to the singleton but also (for backwards compatibility)
	// as a function to set focus.   Remove for 2.0.
	dijit.focus = function(node){
		singleton.focus(node);	// indirection here allows dijit/_base/focus.js to override behavior
	};
	for(var attr in singleton){
		if(!/^_/.test(attr)){
			dijit.focus[attr] = typeof singleton[attr] == "function" ? lang.hitch(singleton, attr) : singleton[attr];
		}
	}
	singleton.watch(function(attr, oldVal, newVal){
		dijit.focus[attr] = newVal;
	});

	return singleton;
});

},
'dojo/i18n':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["./_base/kernel", "require", "./has", "./_base/array", "./_base/config", "./_base/lang", "./_base/xhr", "./json", "module"],
	function(dojo, require, has, array, config, lang, xhr, json, module){

	// module:
	//		dojo/i18n

	has.add("dojo-preload-i18n-Api",
		// if true, define the preload localizations machinery
		1
	);

	 1 || has.add("dojo-v1x-i18n-Api",
		// if true, define the v1.x i18n functions
		1
	);

	var
		thisModule = dojo.i18n =
			{
				// summary:
				//		This module implements the dojo/i18n! plugin and the v1.6- i18n API
				// description:
				//		We choose to include our own plugin to leverage functionality already contained in dojo
				//		and thereby reduce the size of the plugin compared to various loader implementations. Also, this
				//		allows foreign AMD loaders to be used without their plugins.
			},

		nlsRe =
			// regexp for reconstructing the master bundle name from parts of the regexp match
			// nlsRe.exec("foo/bar/baz/nls/en-ca/foo") gives:
			// ["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "/", "/", "en-ca", "foo"]
			// nlsRe.exec("foo/bar/baz/nls/foo") gives:
			// ["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "/", "/", "foo", ""]
			// so, if match[5] is blank, it means this is the top bundle definition.
			// courtesy of http://requirejs.org
			/(^.*(^|\/)nls)(\/|$)([^\/]*)\/?([^\/]*)/,

		getAvailableLocales = function(
			root,
			locale,
			bundlePath,
			bundleName
		){
			// summary:
			//		return a vector of module ids containing all available locales with respect to the target locale
			//		For example, assuming:
			//
			//		- the root bundle indicates specific bundles for "fr" and "fr-ca",
			//		-  bundlePath is "myPackage/nls"
			//		- bundleName is "myBundle"
			//
			//		Then a locale argument of "fr-ca" would return
			//
			//			["myPackage/nls/myBundle", "myPackage/nls/fr/myBundle", "myPackage/nls/fr-ca/myBundle"]
			//
			//		Notice that bundles are returned least-specific to most-specific, starting with the root.
			//
			//		If root===false indicates we're working with a pre-AMD i18n bundle that doesn't tell about the available locales;
			//		therefore, assume everything is available and get 404 errors that indicate a particular localization is not available

			for(var result = [bundlePath + bundleName], localeParts = locale.split("-"), current = "", i = 0; i<localeParts.length; i++){
				current += (current ? "-" : "") + localeParts[i];
				if(!root || root[current]){
					result.push(bundlePath + current + "/" + bundleName);
					result.specificity = current;
				}
			}
			return result;
		},

		cache = {},

		getBundleName = function(moduleName, bundleName, locale){
			locale = locale ? locale.toLowerCase() : dojo.locale;
			moduleName = moduleName.replace(/\./g, "/");
			bundleName = bundleName.replace(/\./g, "/");
			return (/root/i.test(locale)) ?
				(moduleName + "/nls/" + bundleName) :
				(moduleName + "/nls/" + locale + "/" + bundleName);
		},

		getL10nName = dojo.getL10nName = function(moduleName, bundleName, locale){
			return moduleName = module.id + "!" + getBundleName(moduleName, bundleName, locale);
		},

		doLoad = function(require, bundlePathAndName, bundlePath, bundleName, locale, load){
			// summary:
			//		get the root bundle which instructs which other bundles are required to construct the localized bundle
			require([bundlePathAndName], function(root){
				var current = lang.clone(root.root || root.ROOT),// 1.6 built bundle defined ROOT
					availableLocales = getAvailableLocales(!root._v1x && root, locale, bundlePath, bundleName);
				require(availableLocales, function(){
					for (var i = 1; i<availableLocales.length; i++){
						current = lang.mixin(lang.clone(current), arguments[i]);
					}
					// target may not have been resolve (e.g., maybe only "fr" exists when "fr-ca" was requested)
					var target = bundlePathAndName + "/" + locale;
					cache[target] = current;
					current.$locale = availableLocales.specificity;
					load();
				});
			});
		},

		normalize = function(id, toAbsMid){
			// summary:
			//		id may be relative.
			//		preload has form `*preload*<path>/nls/<module>*<flattened locales>` and
			//		therefore never looks like a relative
			return /^\./.test(id) ? toAbsMid(id) : id;
		},

		getLocalesToLoad = function(targetLocale){
			var list = config.extraLocale || [];
			list = lang.isArray(list) ? list : [list];
			list.push(targetLocale);
			return list;
		},

		load = function(id, require, load){
			// summary:
			//		id is in one of the following formats
			//
			//		1. <path>/nls/<bundle>
			//			=> load the bundle, localized to config.locale; load all bundles localized to
			//			config.extraLocale (if any); return the loaded bundle localized to config.locale.
			//
			//		2. <path>/nls/<locale>/<bundle>
			//			=> load then return the bundle localized to <locale>
			//
			//		3. *preload*<path>/nls/<module>*<JSON array of available locales>
			//			=> for config.locale and all config.extraLocale, load all bundles found
			//			in the best-matching bundle rollup. A value of 1 is returned, which
			//			is meaningless other than to say the plugin is executing the requested
			//			preloads
			//
			//		In cases 1 and 2, <path> is always normalized to an absolute module id upon entry; see
			//		normalize. In case 3, it <path> is assumed to be absolute; this is arranged by the builder.
			//
			//		To load a bundle means to insert the bundle into the plugin's cache and publish the bundle
			//		value to the loader. Given <path>, <bundle>, and a particular <locale>, the cache key
			//
			//			<path>/nls/<bundle>/<locale>
			//
			//		will hold the value. Similarly, then plugin will publish this value to the loader by
			//
			//			define("<path>/nls/<bundle>/<locale>", <bundle-value>);
			//
			//		Given this algorithm, other machinery can provide fast load paths be preplacing
			//		values in the plugin's cache, which is public. When a load is demanded the
			//		cache is inspected before starting any loading. Explicitly placing values in the plugin
			//		cache is an advanced/experimental feature that should not be needed; use at your own risk.
			//
			//		For the normal AMD algorithm, the root bundle is loaded first, which instructs the
			//		plugin what additional localized bundles are required for a particular locale. These
			//		additional locales are loaded and a mix of the root and each progressively-specific
			//		locale is returned. For example:
			//
			//		1. The client demands "dojo/i18n!some/path/nls/someBundle
			//
			//		2. The loader demands load(some/path/nls/someBundle)
			//
			//		3. This plugin require's "some/path/nls/someBundle", which is the root bundle.
			//
			//		4. Assuming config.locale is "ab-cd-ef" and the root bundle indicates that localizations
			//		are available for "ab" and "ab-cd-ef" (note the missing "ab-cd", then the plugin
			//		requires "some/path/nls/ab/someBundle" and "some/path/nls/ab-cd-ef/someBundle"
			//
			//		5. Upon receiving all required bundles, the plugin constructs the value of the bundle
			//		ab-cd-ef as...
			//
			//				mixin(mixin(mixin({}, require("some/path/nls/someBundle"),
			//		  			require("some/path/nls/ab/someBundle")),
			//					require("some/path/nls/ab-cd-ef/someBundle"));
			//
			//		This value is inserted into the cache and published to the loader at the
			//		key/module-id some/path/nls/someBundle/ab-cd-ef.
			//
			//		The special preload signature (case 3) instructs the plugin to stop servicing all normal requests
			//		(further preload requests will be serviced) until all ongoing preloading has completed.
			//
			//		The preload signature instructs the plugin that a special rollup module is available that contains
			//		one or more flattened, localized bundles. The JSON array of available locales indicates which locales
			//		are available. Here is an example:
			//
			//			*preload*some/path/nls/someModule*["root", "ab", "ab-cd-ef"]
			//
			//		This indicates the following rollup modules are available:
			//
			//			some/path/nls/someModule_ROOT
			//			some/path/nls/someModule_ab
			//			some/path/nls/someModule_ab-cd-ef
			//
			//		Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.
			//		For example, assume someModule contained the bundles some/bundle/path/someBundle and
			//		some/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:
			//
			//			define({
			//				some/bundle/path/someBundle:<value of someBundle, flattened with respect to locale ab>,
			//				some/bundle/path/someOtherBundle:<value of someOtherBundle, flattened with respect to locale ab>,
			//			});
			//
			//		E.g., given this design, preloading for locale=="ab" can execute the following algorithm:
			//
			//			require(["some/path/nls/someModule_ab"], function(rollup){
			//				for(var p in rollup){
			//					var id = p + "/ab",
			//					cache[id] = rollup[p];
			//					define(id, rollup[p]);
			//				}
			//			});
			//
			//		Similarly, if "ab-cd" is requested, the algorithm can determine that "ab" is the best available and
			//		load accordingly.
			//
			//		The builder will write such rollups for every layer if a non-empty localeList  profile property is
			//		provided. Further, the builder will include the following cache entry in the cache associated with
			//		any layer.
			//
			//			"*now":function(r){r(['dojo/i18n!*preload*<path>/nls/<module>*<JSON array of available locales>']);}
			//
			//		The *now special cache module instructs the loader to apply the provided function to context-require
			//		with respect to the particular layer being defined. This causes the plugin to hold all normal service
			//		requests until all preloading is complete.
			//
			//		Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case
			//		where the target locale has a single segment and a layer depends on a single bundle:
			//
			//		Without Preloads:
			//
			//		1. Layer loads root bundle.
			//		2. bundle is demanded; plugin loads single localized bundle.
			//
			//		With Preloads:
			//
			//		1. Layer causes preloading of target bundle.
			//		2. bundle is demanded; service is delayed until preloading complete; bundle is returned.
			//
			//		In each case a single transaction is required to load the target bundle. In cases where multiple bundles
			//		are required and/or the locale has multiple segments, preloads still requires a single transaction whereas
			//		the normal path requires an additional transaction for each additional bundle/locale-segment. However all
			//		of these additional transactions can be done concurrently. Owing to this analysis, the entire preloading
			//		algorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.

			var match = nlsRe.exec(id),
				bundlePath = match[1] + "/",
				bundleName = match[5] || match[4],
				bundlePathAndName = bundlePath + bundleName,
				localeSpecified = (match[5] && match[4]),
				targetLocale =	localeSpecified || dojo.locale || "",
				loadTarget = bundlePathAndName + "/" + targetLocale,
				loadList = localeSpecified ? [targetLocale] : getLocalesToLoad(targetLocale),
				remaining = loadList.length,
				finish = function(){
					if(!--remaining){
						load(lang.delegate(cache[loadTarget]));
					}
				},
				split = id.split("*"),
				preloadDemand = split[1] == "preload";

			if(has("dojo-preload-i18n-Api")){
				if(preloadDemand){
					if(!cache[id]){
						// use cache[id] to prevent multiple preloads of the same preload; this shouldn't happen, but
						// who knows what over-aggressive human optimizers may attempt
						cache[id] = 1;
						preloadL10n(split[2], json.parse(split[3]), 1, require);
					}
					// don't stall the loader!
					load(1);
				}
				if(preloadDemand || (waitForPreloads(id, require, load) && !cache[loadTarget])){
					return;
				}
			}
			else if (preloadDemand) {
				// If a build is created with nls resources and 'dojo-preload-i18n-Api' has not been set to false,
				// the built file will include a preload in the cache (which looks about like so:)
				// '*now':function(r){r(['dojo/i18n!*preload*dojo/nls/dojo*["ar","ca","cs","da","de","el","en-gb","en-us","es-es","fi-fi","fr-fr","he-il","hu","it-it","ja-jp","ko-kr","nl-nl","nb","pl","pt-br","pt-pt","ru","sk","sl","sv","th","tr","zh-tw","zh-cn","ROOT"]']);}
				// If the consumer of the build sets 'dojo-preload-i18n-Api' to false in the Dojo config, the cached
				// preload will not be parsed and will result in an attempt to call 'require' passing it the unparsed
				// preload, which is not a valid module id.
				// In this case we should skip this request.
				load(1);

				return;
			}

			array.forEach(loadList, function(locale){
				var target = bundlePathAndName + "/" + locale;
				if(has("dojo-preload-i18n-Api")){
					checkForLegacyModules(target);
				}
				if(!cache[target]){
					doLoad(require, bundlePathAndName, bundlePath, bundleName, locale, finish);
				}else{
					finish();
				}
			});
		};

	if(has("dojo-preload-i18n-Api") ||  1 ){
		var normalizeLocale = thisModule.normalizeLocale = function(locale){
				var result = locale ? locale.toLowerCase() : dojo.locale;
				return result == "root" ? "ROOT" : result;
			},

			isXd = function(mid, contextRequire){
				return ( 1  &&  1 ) ?
					contextRequire.isXdUrl(require.toUrl(mid + ".js")) :
					true;
			},

			preloading = 0,

			preloadWaitQueue = [],

			preloadL10n = thisModule._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated, /*boolean?*/ guaranteedAmdFormat, /*function?*/ contextRequire){
				// summary:
				//		Load available flattened resource bundles associated with a particular module for dojo/locale and all dojo/config.extraLocale (if any)
				// description:
				//		Only called by built layer files. The entire locale hierarchy is loaded. For example,
				//		if locale=="ab-cd", then ROOT, "ab", and "ab-cd" are loaded. This is different than v1.6-
				//		in that the v1.6- would only load ab-cd...which was *always* flattened.
				//
				//		If guaranteedAmdFormat is true, then the module can be loaded with require thereby circumventing the detection algorithm
				//		and the extra possible extra transaction.

				// If this function is called from legacy code, then guaranteedAmdFormat and contextRequire will be undefined. Since the function
				// needs a require in order to resolve module ids, fall back to the context-require associated with this dojo/i18n module, which
				// itself may have been mapped.
				contextRequire = contextRequire || require;

				function doRequire(mid, callback){
					if(isXd(mid, contextRequire) || guaranteedAmdFormat){
						contextRequire([mid], callback);
					}else{
						syncRequire([mid], callback, contextRequire);
					}
				}

				function forEachLocale(locale, func){
					// given locale= "ab-cd-ef", calls func on "ab-cd-ef", "ab-cd", "ab", "ROOT"; stops calling the first time func returns truthy
					var parts = locale.split("-");
					while(parts.length){
						if(func(parts.join("-"))){
							return;
						}
						parts.pop();
					}
					func("ROOT");
				}

					function preloadingAddLock(){
						preloading++;
					}

					function preloadingRelLock(){
						--preloading;
						while(!preloading && preloadWaitQueue.length){
							load.apply(null, preloadWaitQueue.shift());
						}
					}

					function cacheId(path, name, loc, require){
						// path is assumed to have a trailing "/"
						return require.toAbsMid(path + name + "/" + loc)
					}

					function preload(locale){
						locale = normalizeLocale(locale);
						forEachLocale(locale, function(loc){
							if(array.indexOf(localesGenerated, loc) >= 0){
								var mid = bundlePrefix.replace(/\./g, "/") + "_" + loc;
								preloadingAddLock();
								doRequire(mid, function(rollup){
									for(var p in rollup){
										var bundle = rollup[p],
											match = p.match(/(.+)\/([^\/]+)$/),
											bundleName, bundlePath;

											// If there is no match, the bundle is not a regular bundle from an AMD layer.
											if (!match){continue;}

											bundleName = match[2];
											bundlePath = match[1] + "/";

										// backcompat
										if(!bundle._localized){continue;}

										var localized;
										if(loc === "ROOT"){
											var root = localized = bundle._localized;
											delete bundle._localized;
											root.root = bundle;
											cache[require.toAbsMid(p)] = root;
										}else{
											localized = bundle._localized;
											cache[cacheId(bundlePath, bundleName, loc, require)] = bundle;
										}

										if(loc !== locale){
											// capture some locale variables
											var improveBundle = function improveBundle(bundlePath, bundleName, bundle, localized){
												// locale was not flattened and we've fallen back to a less-specific locale that was flattened
												// for example, we had a flattened 'fr', a 'fr-ca' is available for at least this bundle, and
												// locale==='fr-ca'; therefore, we must improve the bundle as retrieved from the rollup by
												// manually loading the fr-ca version of the bundle and mixing this into the already-retrieved 'fr'
												// version of the bundle.
												//
												// Remember, different bundles may have different sets of locales available.
												//
												// we are really falling back on the regular algorithm here, but--hopefully--starting with most
												// of the required bundles already on board as given by the rollup and we need to "manually" load
												// only one locale from a few bundles...or even better...we won't find anything better to load.
												// This algorithm ensures there is nothing better to load even when we can only load a less-specific rollup.
												//
												// note: this feature is only available in async mode

												// inspect the loaded bundle that came from the rollup to see if something better is available
												// for any bundle in a rollup, more-specific available locales are given at localized.
												var requiredBundles = [],
													cacheIds = [];
												forEachLocale(locale, function(loc){
													if(localized[loc]){
														requiredBundles.push(require.toAbsMid(bundlePath + loc + "/" + bundleName));
														cacheIds.push(cacheId(bundlePath, bundleName, loc, require));
													}
												});

												if(requiredBundles.length){
													preloadingAddLock();
													contextRequire(requiredBundles, function(){
														// requiredBundles was constructed by forEachLocale so it contains locales from
														// less specific to most specific.
														// the loop starts with the most specific locale, the last one.
														for(var i = requiredBundles.length - 1; i >= 0 ; i--){
															bundle = lang.mixin(lang.clone(bundle), arguments[i]);
															cache[cacheIds[i]] = bundle;
														}
														// this is the best possible (maybe a perfect match, maybe not), accept it
														cache[cacheId(bundlePath, bundleName, locale, require)] = lang.clone(bundle);
														preloadingRelLock();
													});
												}else{
													// this is the best possible (definitely not a perfect match), accept it
													cache[cacheId(bundlePath, bundleName, locale, require)] = bundle;
												}
											};
											improveBundle(bundlePath, bundleName, bundle, localized);
										}
									}
									preloadingRelLock();
								});
								return true;
							}
							return false;
						});
					}

				preload();
				array.forEach(dojo.config.extraLocale, preload);
			},

			waitForPreloads = function(id, require, load){
				if(preloading){
					preloadWaitQueue.push([id, require, load]);
				}
				return preloading;
			},

			checkForLegacyModules = function()
				{};
	}

	if( 1 ){
		// this code path assumes the dojo loader and won't work with a standard AMD loader
		var amdValue = {},
			l10nCache = {},
			evalBundle,

			syncRequire = function(deps, callback, require){
				var results = [];
				array.forEach(deps, function(mid){
					var url = require.toUrl(mid + ".js");

					function load(text){
						if (!evalBundle) {
							// use the function ctor to keep the minifiers away (also come close to global scope, but this is secondary)
							evalBundle = new Function(
								"__bundle",				   // the bundle to evalutate
								"__checkForLegacyModules", // a function that checks if __bundle defined __mid in the global space
								"__mid",				   // the mid that __bundle is intended to define
								"__amdValue",

								// returns one of:
								//		1 => the bundle was an AMD bundle
								//		a legacy bundle object that is the value of __mid
								//		instance of Error => could not figure out how to evaluate bundle

								// used to detect when __bundle calls define
								"var define = function(mid, factory){define.called = 1; __amdValue.result = factory || mid;},"
								+ "	   require = function(){define.called = 1;};"

								+ "try{"
								+		"define.called = 0;"
								+		"eval(__bundle);"
								+		"if(define.called==1)"
											// bundle called define; therefore signal it's an AMD bundle
								+			"return __amdValue;"

								+		"if((__checkForLegacyModules = __checkForLegacyModules(__mid)))"
											// bundle was probably a v1.6- built NLS flattened NLS bundle that defined __mid in the global space
								+			"return __checkForLegacyModules;"

								+ "}catch(e){}"
								// evaulating the bundle was *neither* an AMD *nor* a legacy flattened bundle
								// either way, re-eval *after* surrounding with parentheses

								+ "try{"
								+		"return eval('('+__bundle+')');"
								+ "}catch(e){"
								+		"return e;"
								+ "}"
							);
						}
						var result = evalBundle(text, checkForLegacyModules, mid, amdValue);
						if(result===amdValue){
							// the bundle was an AMD module; re-inject it through the normal AMD path
							// we gotta do this since it could be an anonymous module and simply evaluating
							// the text here won't provide the loader with the context to know what
							// module is being defined()'d. With browser caching, this should be free; further
							// this entire code path can be circumvented by using the AMD format to begin with
							results.push(cache[url] = amdValue.result);
						}else{
							if(result instanceof Error){
								console.error("failed to evaluate i18n bundle; url=" + url, result);
								result = {};
							}
							// nls/<locale>/<bundle-name> indicates not the root.
							results.push(cache[url] = (/nls\/[^\/]+\/[^\/]+$/.test(url) ? result : {root:result, _v1x:1}));
						}
					}

					if(cache[url]){
						results.push(cache[url]);
					}else{
						var bundle = require.syncLoadNls(mid);
						// need to check for legacy module here because there might be a legacy module for a
						// less specific locale (which was not looked up during the first checkForLegacyModules
						// call in load()).
						// Also need to reverse the locale and the module name in the mid because syncRequire
						// deps parameters uses the AMD style package/nls/locale/module while legacy code uses
						// package/nls/module/locale.
						if(!bundle){
							bundle = checkForLegacyModules(mid.replace(/nls\/([^\/]*)\/([^\/]*)$/, "nls/$2/$1"));
						}
						if(bundle){
							results.push(bundle);
						}else{
							if(!xhr){
								try{
									require.getText(url, true, load);
								}catch(e){
									results.push(cache[url] = {});
								}
							}else{
								xhr.get({
									url:url,
									sync:true,
									load:load,
									error:function(){
										results.push(cache[url] = {});
									}
								});
							}
						}
					}
				});
				callback && callback.apply(null, results);
			};

		checkForLegacyModules = function(target){
			// legacy code may have already loaded [e.g] the raw bundle x/y/z at x.y.z; when true, push into the cache
			for(var result, names = target.split("/"), object = dojo.global[names[0]], i = 1; object && i<names.length-1; object = object[names[i++]]){}
			if(object){
				result = object[names[i]];
				if(!result){
					// fallback for incorrect bundle build of 1.6
					result = object[names[i].replace(/-/g,"_")];
				}
				if(result){
					cache[target] = result;
				}
			}
			return result;
		};

		thisModule.getLocalization = function(moduleName, bundleName, locale){
			var result,
				l10nName = getBundleName(moduleName, bundleName, locale);

			if (l10nCache[l10nName]) {
				return l10nCache[l10nName];
			}

			load(
				l10nName,

				// isXd() and syncRequire() need a context-require in order to resolve the mid with respect to a reference module.
				// Since this legacy function does not have the concept of a reference module, resolve with respect to this
				// dojo/i18n module, which, itself may have been mapped.
				(!isXd(l10nName, require) ? function(deps, callback){ syncRequire(deps, callback, require); } : require),

				function(result_){
					l10nCache[l10nName] = result_;
					result = result_;
				}
			);
			return result;
		};
	}
	else {
		thisModule.getLocalization = function(moduleName, bundleName, locale){
			var key = moduleName.replace(/\./g, '/') + '/nls/' + bundleName + '/' + (locale || config.locale);
			return this.cache[key];
		};
	}

	return lang.mixin(thisModule, {
		dynamic:true,
		normalize:normalize,
		load:load,
		cache:cache,
		getL10nName: getL10nName
	});
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/_ToolTemplate':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/_base/declare", 
	"dojo/main",  "dijit/main",
	"ibm/tivoli/fwm/mxmap/_Base",
	"dijit/form/Button"], 
		function(declare, dojo, dijit, _Base, Button) {
	return declare([_Base], {
		map: null,
		label: "",
		_button: null,
		iconClass: "basicMapToolbarBtn",
		constructor: function(params)
		{
			dojo.mixin(this, params);
			this._handlers=[];
		},
		createToolbarButton: function()
		{
			this._button = new Button({
				label: this.label,
				showLabel: false,
				iconClass: this.iconClass,
				onClick: dojo.hitch(this, function()
						{
					this.execute();
						})

			});
			return this._button;

		},
		execute: function()
		{
			console.error("to be implemented");
		},
		disable: function()
		{
			// does nothing
			console.error("to be implemented");
		},
		destroy: function()
		{
			this._button.destroyRecursive();
			// equivalent to super.destroyRecursive()
			// arguments is mandatory
			this.inherited(arguments);
			this.destroyRecursive();
		}
	});
});

},
'dijit/hccss':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["dojo/dom-class", "dojo/hccss", "dojo/domReady", "dojo/_base/window"], function(domClass, has, domReady, win){

	// module:
	//		dijit/hccss

	/*=====
	return function(){
		// summary:
		//		Test if computer is in high contrast mode, and sets `dijit_a11y` flag on `<body>` if it is.
		//		Deprecated, use ``dojo/hccss`` instead.
	};
	=====*/

	domReady(function(){
		if(has("highcontrast")){
			domClass.add(win.body(), "dijit_a11y");
		}
	});

	return has;
});

},
'ibm/tivoli/fwm/mxmap/routing/itinerary/ItineraryManager':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
define(["dojo/_base/declare", "ibm/tivoli/fwm/mxmap/_Base", "dijit/_Widget", "dijit/_Templated", 
	"dijit/form/CheckBox", "dijit/form/RadioButton", "ibm/tivoli/fwm/mxmap/panels/MobileInfoPanelDialog",
	"ibm/tivoli/fwm/mxmap/routing/itinerary/Leg","ibm/tivoli/fwm/mxmap/routing/itinerary/Step",
	"ibm/tivoli/fwm/mxmap/impl/BingMaps"], 
	function(declare, _Base, _Widget, _Templated, CheckBox, RadioButton, MobileInfoPanelDialog, Leg, Step, BingMaps) {

	ibm.tivoli.fwm.mxmap.routing.itinerary.MobileInput = declare([ ], {
		_checkbox: null,
		constructor: function(type, args, container)
		{
			container.innerHTML += '<input type="' + type + '" name="' + args.name + '" value="' + args.value + '"/>';
			var checkbox = container.childNodes[0];
			checkbox.checked = args.checked;
			var onchange = args.onChange;
			checkbox.onchange = function(evt) {
				onchange(evt.target.checked);
			};

			args.label.onclick = function() { checkbox.click(); };

			this._checkbox = checkbox;
		},
		get: function(name)
		{
			if (name == "value")
			{
				return this._checkbox.checked;
			}
		},
		set: function(name, value)
		{
			// Do nothing, as this is being called in the onclick by dojo after the state has already changed
		},
		setDisabled: function(state)
		{
			this._checkbox.disabled = state;
		}

	});

	/**
	 * Controls the route step by step information and dialog
	 * 
	 */
	ibm.tivoli.fwm.mxmap.routing.itinerary.ItineraryManager = declare([_Widget, _Templated, _Base], {
		templateString: dojo.cache("ibm.tivoli.fwm.mxmap", "templates/ItineraryManager.html", "<div style=\"width:100%;overflow: auto;\">\n\t<div data-dojo-attach-point=\"controls\" style=\"background-color: #FFFFFF;border: 1px solid #E0E0E0;padding: 10px;margin-left: 4px; margin-right: 4px;\">\n\t\t<div style=\"float:left;width:50%;\" data-dojo-attach-point=\"avoidersNode\">\n\t\t\t<div data-dojo-attach-point=\"highdiv\" data-dojo-attach-event=\"ondijitclick:_highClick\" style=\"padding-top:0px;padding-bottom:10px\">\n\t\t\t\t<span data-dojo-attach-point=\"ahNode\" style=\"padding-left:10px;padding-right:10px\"></span> <div data-dojo-attach-point=\"avoidhighwaysdiv\" style=\"display:inline\"><label data-dojo-attach-point=\"itineraryavoidhighways\" for=\"avoidhighways\">Avoid highways</label></div><br/>\n\t\t\t</div>\n\t\t\t<div data-dojo-attach-point=\"tollsdiv\" data-dojo-attach-event=\"ondijitclick:_tollsClick\" style=\"padding-top: 10px; padding-bottom:0px\">\n\t\t\t\t<span data-dojo-attach-point=\"atNode\" style=\"padding-left:10px;padding-right:10px\"></span> <div data-dojo-attach-point=\"avoidtollsdiv\" style=\"display:inline\"><label data-dojo-attach-point=\"itineraryavoidtolls\" for=\"avoidtolls\">Avoid tolls</label></div><br/>\n\t\t\t</div>\n\t\t</div>\n\t\t<div data-dojo-attach-point=\"kmdiv\" data-dojo-attach-event=\"ondijitclick:_kmClick\" style=\"padding-top:0px;padding-bottom:10px\">\n\t\t\t<span data-dojo-attach-point=\"kmNode\" style=\"padding-left:10px;padding-right:10px\"></span><label data-dojo-attach-point=\"itinerarykm\" for=\"km\">Kilometers</label>\n\t\t</div>\n\t\t<div data-dojo-attach-point=\"milesdiv\" data-dojo-attach-event=\"ondijitclick:_milesClick\" style=\"padding-top:10px;padding-bottom:0px\">\n\t\t\t<span data-dojo-attach-point=\"miNode\" style=\"padding-left:10px;padding-right:10px\"></span><label data-dojo-attach-point=\"itinerarymiles\" for=\"miles\">Miles</label>\n\t\t</div>\n\t</div>\n\t<div data-dojo-attach-point=\"markerNode\" style=\"float:left;\" data-dojo-attach-event=\"ondijitclick:_onInitialLocClick\"></div>\n\t<div data-dojo-attach-point=\"startLocation\" style=\"margin: 1px;padding: 7px 2px;\" ></div>\n\t<div data-dojo-attach-point=\"routeInfo\" style=\"padding: 2px;\">\n\t</div>\n</div>"),
		infoPanel: null,
		map: null,
		legs: [],
		constructor: function(params)
		{
			dojo.mixin(this, params);
		},
		highway: null,
		toll: null,
		km: null,
		miles: null,
		_lastHighwayState: null,
		_lastAvoidTollsState: null,
		_isBingAndIE: null,
		postCreate: function()
		{
			// Dojo's checkboxes don't work well on Android, so we use native ones instead
			var isAndroid = navigator.userAgent.indexOf("Android") > -1;
			// Defect 58403: For some mysterious reason, the onChange event is not fired when clicking on
			// dijit RadioButtons and CheckBoxes when using IE8 + Bing maps, so we force the execution 
			// of methods upon ondijitclick events 
			this._isBingAndIE = (dojo.isIE && this.map instanceof ibm.tivoli.fwm.mxmap.impl.BingMaps ) ? true : false;
			var checkboxBuilder = (isAndroid 
					? function(params, container)
							{
				return new ibm.tivoli.fwm.mxmap.routing.itinerary.MobileInput("checkbox", params, container);
							}
			: function(params, container)
			{
				return new CheckBox(params, container);
			});
			var radioBuilder = (isAndroid 
					? function(params, container)
							{
				return new ibm.tivoli.fwm.mxmap.routing.itinerary.MobileInput("radio", params, container);
							}
			: function(params, container)
			{
				return new RadioButton(params, container);
			});

			this._lastHighwayState = false;
			this.highway = checkboxBuilder({
				name: "highway",
				value: "highway",
				checked: this._lastHighwayState,
				onChange: dojo.hitch(this, this.onHighWayChanged),
				label: this.itineraryavoidhighways // only used by the mobile version
			}, this.ahNode);
			//this.itineraryavoidhighwaysdiv
			this._lastAvoidTollsState = false;
			this.toll = checkboxBuilder({
				name: "toll",
				value: "toll",
				checked: this._lastAvoidTollsState,
				onChange: dojo.hitch(this, this.onTollChanged),
				label: this.itineraryavoidtolls // only used by the mobile version
			}, this.atNode);
			var defaultLengthUnit = this.map.getDefaultLengthUnit();

			this.km = radioBuilder({
				checked: (defaultLengthUnit == "KILOMETERS"),
				value: "km",
				name: "unit",
				onChange: dojo.hitch(this, this.onUnitChanged),
				label: this.itinerarykm // only used by the mobile version
			}, this.kmNode);
			this.miles = radioBuilder({
				checked: (defaultLengthUnit == "MILES"),
				value: "mi",
				name: "unit",
				onChange: dojo.hitch(this, this.onUnitChanged),
				label: this.itinerarymiles // only used by the mobile version
			}, this.miNode);

			// Translate the texts in the dialog
			this.itineraryavoidhighways.innerHTML = ibm.tivoli.fwm.i18n.getMaxMsg("map", "itineraryavoidhw");
			this.itineraryavoidtolls.innerHTML = ibm.tivoli.fwm.i18n.getMaxMsg("map", "itineraryavoidtolls");
			this.itinerarykm.innerHTML = ibm.tivoli.fwm.i18n.getMaxMsg("map", "itinerarykm");
			this.itinerarymiles.innerHTML = ibm.tivoli.fwm.i18n.getMaxMsg("map", "itinerarymiles");
			this.addressLoading = ibm.tivoli.fwm.i18n.getMaxMsg("map", "address_being_loaded");
			this.failedToLoadAddress = ibm.tivoli.fwm.i18n.getMaxMsg("map", "address_info_not_found");

		},
		_highClick:function(){
			this._lastHighwayState = !this._lastHighwayState;
			this.highway.set("checked", this._lastHighwayState);
			// Defect 58403: For some mysterious reason, the onChange event is not fired when clicking on
			// dijit RadioButtons and CheckBoxes when using IE8 + Bing maps, so we force the execution 
			// of methods upon ondijitclick events 
			if(this._isBingAndIE == true)
			{
				this.onHighWayChanged(this._lastHighwayState);
			}
		},
		_tollsClick:function(){
			this._lastAvoidTollsState = !this._lastAvoidTollsState;
			this.toll.set("checked", this._lastAvoidTollsState);
			// Defect 58403: For some mysterious reason, the onChange event is not fired when clicking on
			// dijit RadioButtons and CheckBoxes when using IE8 + Bing maps, so we force the execution 
			// of methods upon ondijitclick events 
			if(this._isBingAndIE == true)
			{
				this.onTollChanged(this._lastAvoidTollsState);
			}
		},
		_kmClick:function(){
			this.km.set("checked",true);
			// Defect 58403: For some mysterious reason, the onChange event is not fired when clicking on
			// dijit RadioButtons and CheckBoxes when using IE8 + Bing maps, so we force the execution 
			// of methods upon ondijitclick events 
			if(this._isBingAndIE == true)
			{
				this.onUnitChanged(true);
			}
		},
		_milesClick:function(){
			this.miles.set("checked",true);
			// Defect 58403: For some mysterious reason, the onChange event is not fired when clicking on
			// dijit RadioButtons and CheckBoxes when using IE8 + Bing maps, so we force the execution 
			// of methods upon ondijitclick events 
			if(this._isBingAndIE == true)
			{
				this.onUnitChanged(true);
			}
		},
		onUnitChanged: function(enabled)
		{
			/*
			 * because it's a radio button and there are only 2 options if one
			 * changes the other changes too (to true and to false) so we jsut
			 * trigger on the enablement
			 */
			if (enabled == true)
			{
				this.onRouteControlsChanged(false);
			}
		},
		onTollChanged: function()
		{
			this.onRouteControlsChanged(true);
		},
		onHighWayChanged: function(arg)
		{
			this.onRouteControlsChanged(true);
		},	
		enableControls:function(enable){
			this.miles.setDisabled(!enable);
			this.km.setDisabled(!enable);
			this.highway.setDisabled(!enable);
			this.toll.setDisabled(!enable);
		},
		onRouteControlsChanged: function(needsToReRoute)
		{
			this.enableControls(false);
			var custom = this.getControls();
			var conf = this.route.inputInfo;
			var me = this;
			if (!this.infoPanel)
			{
				console.info("info panel", this.infoPanel);
				this._getInfoPanel();
			}

			var fct = function(route)
			{
				var routeId = me.route.id;
				if (needsToReRoute == true)
				{
					me.routeManager.replaceRoute(route, routeId);
					route.show();
				}
				me.updateRouteItinerary(route.itinerary, me.routeManager, route);

				me.enableControls(true);
			};
			var errFct = function(error){
				me.enableControls(true);
				conf.errorCb(error);
			};

			if (needsToReRoute == true)
			{

				dojo.empty(this.routeInfo);
				dojo.create("img", {
					src: dojo.config.fwm.ctxRoot + "/webclient/skins/tivoli09/images/progressbar.gif"
				}, this.routeInfo);
				this.routeManager.reGenerate(this.route, custom, fct, errFct);
			}
			else
			{
				this.route.originalRouter.customConf = custom;
				fct(this.route);
			}
		},
		getControls: function()
		{
			var state = {};
			if (this.highway.get('value') != false)
			{
				state.avoidHighway = true;
			}
			else
			{
				state.avoidHighway = false;
			}
			if (this.toll.get('value') != false)
			{
				state.avoidToll = true;
			}
			else
			{
				state.avoidToll = false;
			}
			var km = this.km.get("value") != false;
			var miles = this.miles.get("value") != false;
			if (km == true)
			{
				state.distanceUnit = ibm.tivoli.fwm.mxmap.routing.DistanceUnit.KM;
			}
			else
			{
				state.distanceUnit = ibm.tivoli.fwm.mxmap.routing.DistanceUnit.MILES;
			}
			return state;
		},
		routeManager: null,
		route: null,
		_createLegFromInitialLocation: function(initialLocation)
		{
			var leg = initialLocation;
			leg.marker = this.route.getMarkerForStop(0);
			leg.map = this.map;
			leg.distanceUnit = this.getControls().distanceUnit;
			var legWidget = new Leg(leg);
			return legWidget;
		},
		updateRouteItinerary: function(itinerary, routeManager, route)
		{
			this.routeManager = routeManager;
			this.route = route;
			if (this.route == null)
			{
				this.enableControls(false);
				return;
			}
			this.enableControls(true);
			if (this.route.avoidTollsSupported == false && this.route.avoidHighwaysSupported == false)
			{
				console.log("not visible");
				dojo.style(this.avoidersNode, "display", "none");
			}
			else
			{
				dojo.style(this.avoidersNode, "display", "block");
			}
			this.legs = [];
			var initialLocation = itinerary.getInitialLocation();
			var fct = function()
			{
				this.infoPanel.close();
			};
			if (initialLocation)
			{
				initialLocation.marker = this.route.getMarkerForStop(0);
				initialLocation.closeDialog = dojo.hitch(this, fct);

				var legWidget = this._createLegFromInitialLocation(initialLocation);
				dojo.place(legWidget.domNode, this.startLocation, 'only');

			}
			// to force an empty list

			dojo.empty(this.routeInfo);

			for ( var i = 0; i < itinerary.legs.length; i++)
			{
				var leg = itinerary.legs[i];
				leg.marker = this.route.getMarkerForStop(i + 1);
				leg.map = this.map;
				leg.distanceUnit = this.getControls().distanceUnit;
				leg.closeDialog = dojo.hitch(this, fct);
				var legWidget = new Leg(leg);

				dojo.place(legWidget.domNode, this.routeInfo, 'last');
				this.legs.push(legWidget);
			}

		},
		_onInitialLocClick: function(args)
		{
			var _loc = this.route.itinerary.getInitialLocation().location;
			this.map.setCenter(_loc);
		},
		isIt: false,
		showPanel: function()
		{
			if (this.isIt == false)
			{
				this.isIt = true;
				this._getInfoPanel();
				this.infoPanel.setContent(this.domNode);
			}
			if(this.route==null){
				this.enableControls(false);
			}else{
				this.enableControls(true);
			}
			this.infoPanel.show();
		},
		_getInfoPanel: function()
		{
			if (this.infoPanel)
			{
				this.infoPanel.close();
				this.infoPanel = null;
			}
			this.infoPanel = new MobileInfoPanelDialog({
				map: this.map,
				fitHeight: true
			});
			// sets the height of the content to provide right scroll. removes 40 to
			// better display it
			/*
			 * var height = this.infoPanel.getCalculatedHeight() - 40; if (height <=
			 * 0) { height = 10; }
			 * 
			 * dojo.style(this.domNode, { "height": height + "px" });
			 */
			return this.infoPanel;
		}

	});
	return ibm.tivoli.fwm.mxmap.routing.itinerary.ItineraryManager;

});






},
'ibm/tivoli/fwm/mxmap/panels/MobileInfoPanelLine':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/_base/declare",
	"dijit/_Widget",
	"dijit/_Templated"],
	 function(declare, _Widget, _Templated  ) {
	
	return declare([_Widget, _Templated], {
		templateString:"<tr role=\"row\" style=\"display: ;\" dojoAttachPoint=\"row\">\n\t<th>\n\t\t<img src=\"blank.gif\" style=\"display: none\" class=\"tablerow_blank_icon\" title=\"\" alt=\"\">\n\t</th>\n\t<td role=\"gridcell\" control=\"true\" dojoAttachPoint=\"clickable\" onmouseover=\"appendClass(this.parentNode,'trh')\" onmouseout=\"removeClass(this.parentNode,'trh')\" style=\"padding-left: 5px;\" class=\"tc hl cursor_hand\">\n\t\t<table role=\"presentation\" style=\"display: inline;\">\n\t\t\t<tbody>\n\t\t\t\t<tr>\n\t\t\t\t\t<td nowrap=\"nowrap\" valign=\"top\" style=\"vertical-align: top;\">\n\t\t\t\t\t\t<table role=\"presentation\" control=\"true\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" class=\" \" summary=\"\" style=\"width: 100%; vertical-align: top\">\n\t\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t\t<tr control=\"true\" style=\"vertical-align: top;\">\n\t\t\t\t\t\t\t\t\t<td nowrap=\"nowrap\" align=\"left\" valign=\"top\" style=\"vertical-align: top;\">\n\t\t\t\t\t\t\t\t\t\t<div aria-live=\"polite\" class=\"bc\">\n\t\t\t\t\t\t\t\t\t\t\t<span ctype=\"label\" tabindex=\"0\" \n\t\t\t\t\t\t\t\t\t\t\tclass=\"text txtplain  label  \" \n\t\t\t\t\t\t\t\t\t\t\tstyle=\"cursor: pointer;\"\n\t\t\t\t\t\t\t\t\t\t\ttitle=\"\">\n\t\t\t\t\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"content\"></div>\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t</tbody>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</table>\n\t</td>\n</tr>",	
		domNode:null,
		row: null,
		content: null,
		clickable: null,	
		constructor : function(options) {
			dojo.mixin(this,options);
		},
		postCreate:function(){
			dojo.parser.parse(this.domNode);		
		},	
		setCallbackFunction: function(callback)
		{
			this.clickable.onclick = callback;
		},
		setRowClass: function(newClass)
		{
			dojo.addClass(this.row, newClass);
		},
		setContent: function(content)
		{
			this.content.textContent = content;
		}
	});

});

},
'ibm/tivoli/fwm/mxmap/MapTipsManager':function(){
/*
 * IBM Confidential
 * 
 * OCO Source Materials
 * 
 * 5724-U18, 5737-M66
 * 
 * (C) COPYRIGHT IBM CORP. 2011,2024
 * 
 * The source code for this program is not published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with the U.S.
 * Copyright Office.
 */


define(["dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/_Base",
	"ibm/tivoli/fwm/i18n",
	"dijit/form/Select",
	"ibm/tivoli/fwm/mxmap/InfoSummaryPanelWidget",
	"ibm/tivoli/fwm/mxmap/InfoSummaryWidget"],
	function(declare, _Base, i18n, Select, InfoSummaryPanelWidget, InfoSummaryWidget ) {

	/**
	 * Implement the logic for loading, parsing and caching Maptips. A marker
	 * can be enabled to show maptips. This marker must be associated with a Maximo
	 * record so based on the mxdata the maptip can be loaded.
	 * 
	 * This manager will cache any already loaded maptip (based on objectname/id).
	 * The maptip is loaded based on the rest format 'maptip' from the rest
	 * interface.
	 * 
	 */
	return declare([_Base], {
		_templateCache: {},
		_summaryTemplateCache: {},
		_menuCache: {},
		maximo: null,
		constructor: function(params)
		{
			dojo.mixin(this, params);
			this._templateCache = {};
			this._summaryTemplateCache = {};
			this._menuCache = {};
		},
		_cloneMarkerOpenBubbleImplementation: function(marker)
		{
			// here is the trick
			// replace the marker's openBubble function by a function that
			// first tries to load the maptip from maximo, set the
			// infoBubble and only then call the original openBubble.
			//
			marker.openBubble.clone = function()
			{
				var that = this;
				var temp = function temporary()
				{
					return that.apply(this, arguments);
				};
				for (key in this)
				{
					temp[key] = this[key];
				}
				return temp;
			};
			var obclone = marker.openBubble.clone();
			return obclone;
		},
		/**
		 * It enables the infowindow replacement with the associated maptip
		 * 
		 * @param mapstraction
		 *            marker
		 * @param mxdata
		 *            json object with this structure: { mboName://NAME OF THE
		 *            MAXIMO OBJECT, uid: { name://NAME OF THE COLUMN WITH THE MBO
		 *            UID value: //VALUE THE MBO UID } * }
		 */
		enableMarker: function(marker, mxdata, mapTipOverrides)
		{
			marker.obclone = this._cloneMarkerOpenBubbleImplementation(marker);
			var me = this;
			marker.openBubble = function()
			{
				me._handleOpenBubble(marker, mxdata, mapTipOverrides, marker.obclone);
			};
		},
		updateMultiMarkerOpenBubbleHandler: function(marker, mboInfoArray)
		{
			var me = this;
			marker.clearReferencedMarkers();
			for(var i=0; i<mboInfoArray.length; i++)
			{
				if(mboInfoArray[i].marker)
				{
					// Set the marker as a "referenced marker" of the multimarker so that, when the maptip
					// summary is closed, any other maptips that belong to the referenced markers will
					// be closed as well
					marker.addReferencedMarker(mboInfoArray[i].marker);
				}
			}
			marker.openBubble = function()
			{
				me._handleMultiMarkerOpenBubble(marker, mboInfoArray, marker.obclone);
			};
		},
		enableMultiMarker: function(marker, mboInfoArray)
		{
			marker.obclone = this._cloneMarkerOpenBubbleImplementation(marker);
			this.updateMultiMarkerOpenBubbleHandler(marker, mboInfoArray);
		},
		// checks if a maptip template was already loaded
		_isTemplateLoaded: function(objectname, id)
		{
			return this._templateCache[objectname] && this._templateCache[objectname][id];
		},
		// checks if a maptip summary template was already loaded
		_isSummaryTemplateLoaded: function(objectname, id)
		{
			return this._summaryTemplateCache[objectname] && this._summaryTemplateCache[objectname][id];
		},
		// gets a maptip template
		// * it assumes the template is loaded.
		_getTemplate: function(objectname, id)
		{
			return this._templateCache[objectname][id];
		},
		_getSummaryTemplate: function(objectname, id)
		{
			return this._summaryTemplateCache[objectname][id];
		},
		// gets a maptip template summary (only the first html line)
		// * it assumes the template is loaded.
		_getSummaryTemplateWidget: function(objectname, id)
		{
			var templateSummary = this._getSummaryTemplate(objectname, id);

			var summaryWidget = new InfoSummaryWidget();
			summaryWidget.setContent(templateSummary);

			return summaryWidget;
		},

		// after loading the template from the server it
		// updates the cache and trigger the openMapTip
		_onTemplateLoaded: function(html, marker, mxdata, fct)
		{
			var objectname = mxdata.mboName;
			var id = mxdata.uid.value;
			this._updateTemplate(objectname, id, html);
			this._openMapTip(objectname, id, marker, fct);
		},
		// update the cache with template data
		_updateTemplate: function(objectname, id, html)
		{
			if (!this._templateCache.hasOwnProperty(objectname))
			{
				this._templateCache[objectname] = {};
			}
			this._templateCache[objectname][id] = html;
		},
		// update the cache with maptip summary template data
		_updateSummaryTemplate: function(objectname, id, html)
		{
			if (!this._summaryTemplateCache.hasOwnProperty(objectname))
			{
				this._summaryTemplateCache[objectname] = {};
			}
			this._summaryTemplateCache[objectname][id] = html;
		},
		// triggers the specific marker openbubble method
		// * it assumes the template is loaded.
		_openMapTip: function(objectname, id, marker, fct)
		{
			var html = this._getTemplate(objectname, id);
			var menuData = this._getMenuData(objectname);
			var infoDOM = this._createInfoDOM(html, menuData, objectname, id);
			marker.setInfoBubble(infoDOM);
			fct.apply(marker);
		},
		// triggers the specific multi marker openbubble method
		// * it assumes the template is loaded.
		_openMapTipSummary: function(mboInfoArray, marker, fct)
		{
			var maptipSummaryPanel = new InfoSummaryPanelWidget();
			var div = dojo.create("div");
			for(var i=0; i<mboInfoArray.length; i++)
			{
				var objectname = mboInfoArray[i].mxdata.mboName;
				var id = mboInfoArray[i].mxdata.uid.value;
				var templateSummaryWidget = this._getSummaryTemplateWidget(objectname, id);
				if(mboInfoArray[i].marker)
				{
					// Set the marker's openBubble function as the handling function when the maptip
					// summary is clicked
					templateSummaryWidget.setMarkerOpenBubbleFunction(mboInfoArray[i].marker.openBubble);
				}
				dojo.place(templateSummaryWidget.domNode, div, 'last');

				// Add a line separator for all mxdata summary entries, but for the last one
				if(i < (mboInfoArray.length - 1))
				{
					dojo.place("<hr>", div, 'last');
					// Defect 67359 - Horizontal line makes the width of the div
					// as large as it can be... only in IE, of course...
					// Limiting the width so that it is larger than 200px only if necessary
					// Remember, IE does not recognize "max-" and "min-" properties...
					if(dojo.isIE)
					{
						dojo.style(div, "width", "200px");
					}
				}
			}
			dojo.place(div, maptipSummaryPanel.infoSummaryPanel, 'last');
			// Defect 66760 - Adding an outer div with overflow set to auto
			// so that a vertical scroll bar can show up when the content height
			// is bigger than the infoWindow height
			var outerDiv = dojo.create("div", {
				style: {
					overflow: "auto",
					marginTop: "8px",
					maxHeight: "300px"
				}
			});

			dojo.place(maptipSummaryPanel.infoSummaryPanel, outerDiv, 'only');

			marker.setInfoBubble(outerDiv);
			fct.apply(marker);
		},
		_createInfoDOM: function(html, menuData, objectName, objectId)
		{
			var outerDiv = dojo.create("div", {
				style: {
					overflow: "auto",
					marginTop: "8px",
					maxHeight: "300px"
				}
			});

			var htmlDiv = dojo.create("div", {
				innerHTML: html
			}, outerDiv);

			if (menuData)
			{
				var menuDiv = dojo.create("div", null, outerDiv);
				this._newSelect(menuData, menuDiv, objectName, objectId);
			}
			return outerDiv;

		},
		// on request to open the marker bubble we try to update the maptip
		// content;
		// fct - is the original open bubble function from the specific marker implementation.
		_handleOpenBubble: function(marker, mxdata, mapTipOverrides, fct)
		{
			var objectname = mxdata.mboName;
			console.log("objectname",objectname);
			// it's important to always load the info on server so we are skipping
			// the cache on the template
			/*
			 * // if the template has already been is loaded, then the menu had been
			 * loaded // before. if (this._isTemplateLoaded(objectname, id)) {
			 * console.info("Cache hit for " + objectname + ":" + id);
			 * this._openMapTip(objectname, id, marker, fct); } // if the template
			 * is not loaded, confirm the menu has already // been loaded for
			 * another // record. // if the menu was not loaded, load it and then
			 * load the // template afterwards. else {
			 */
			if (this._isMenuLoaded(objectname))
			{
				this._loadTemplate(mxdata, mapTipOverrides, marker, fct);
			}
			else
			{
				this._loadMenu(mxdata, mapTipOverrides, marker, fct);
			}
			// }

		},
		// on request to open the marker bubble we try to update the maptip
		// content;
		// fct - is the original open bubble function from the specific marker implementation.
		_handleMultiMarkerOpenBubble: function(marker, mboInfoArray, fct)
		{
			this._loadMultipleSummaryTemplate(mboInfoArray, marker, fct);
		},
		_loadMenu: function(mxdata, mapTipOverrides, marker, fct)
		{
			var fctSuccess = dojo.hitch(this, function(data)
					{
				this._onMenuLoaded(data, marker, mxdata, mapTipOverrides, fct);
					});
			var fctError = dojo.hitch(this, function(error)
					{
				this._onMenuLoadError(error, marker, mxdata, fct);
					});
			this.maximo.loadMapTipItems(fctSuccess, fctError);
		},
		_loadTemplate: function(mxdata, mapTipOverrides, marker, fct)
		{

			var fctSuccess = dojo.hitch(this, function(data)
					{
				this._onTemplateLoaded(data, marker, mxdata, fct);
					});
			var fctError = dojo.hitch(this, function(error)
					{
				this._onTemplateLoadError(error, marker, mxdata, fct);
					});
			// must load it.
			this.maximo.loadMapTipTemplate(mxdata, mapTipOverrides, fctSuccess, fctError);

		},
		_loadMultipleSummaryTemplate: function(mboInfoArray, marker, fct)
		{

			var mboInfoCount = 0;
			var fctError = dojo.hitch(this, function(error)
					{
				this._onTemplateLoadError(error, marker, fct);
					});
			var fctSuccess = dojo.hitch(this, function(data)
					{
				var objectname = mboInfoArray[mboInfoCount].mxdata.mboName;
				var id = mboInfoArray[mboInfoCount].mxdata.uid.value;
				this._updateSummaryTemplate(objectname, id, data);
				mboInfoCount += 1;
				if(mboInfoCount < mboInfoArray.length)
				{
					this.maximo.loadMapTipSummaryTemplate(mboInfoArray[mboInfoCount].mxdata, mboInfoArray[mboInfoCount].maptipoverrides, fctSuccess, fctError);
				}
				else
				{
					this._openMapTipSummary(mboInfoArray, marker, fct);
				}
					});
			// must load it.
			this.maximo.loadMapTipSummaryTemplate(mboInfoArray[mboInfoCount].mxdata, mboInfoArray[mboInfoCount].maptipoverrides, fctSuccess, fctError);

		},

		// on any error we just set the maptip content with the error
		_onTemplateLoadError: function(error, marker, fct)
		{
			marker.setInfoBubble("Error loading maptip " + error);
			fct.apply(marker);
		},
		// on any error we just set the maptipmenu content with the error
		_onMenuLoadError: function(error, marker, mxdata, fct)
		{
			marker.setInfoBubble("Error loading maptipmenu " + error);
			fct.apply(marker);
		},
		_onMenuLoaded: function(menusJSON, marker, mxdata, mapTipOverrides, fct)
		{
			for ( var objName in menusJSON)
			{
				var menuItems = menusJSON[objName];
				console.log(objName, menuItems);
				this._updateMenu(objName, menuItems);
			}
			this._loadTemplate(mxdata, mapTipOverrides, marker, fct);
		},
		_updateMenu: function(objectname, menuJSON)
		{
			var moreDetails = ibm.tivoli.fwm.i18n.getMaxMsg("map", "moredetailsaboutrecord");
			var items = [ {
				value: 'noaction',
				label: moreDetails,
				selected: true
			} ];
			for ( var itemMenu in menuJSON)
			{

				var itemInfo = {
						value: menuJSON[itemMenu],
						label: menuJSON[itemMenu].name
				};
				itemInfo.itemData = menuJSON[itemMenu];
				items.push(itemInfo);
			}
			this._menuCache[objectname] = items;
		},
		_isMenuLoaded: function(objectname)
		{
			return this._menuCache[objectname] != null;
		},
		_newSelect: function(menuJSON, div, objectName, objectId)
		{
			console.log(menuJSON);
			var select;
			var fctOnChange = dojo.hitch(this, function(item)
					{
				if ('noaction' != '' + item)
				{
					console.log("dialog", item);
					this.maximo.showMaximoDialog(item.dialogid, objectName, objectId, item.relationship);
					select.reset();
				}
					});
			select = new Select({
				onChange: fctOnChange
			}, div);
			select.addOption(menuJSON);
			select.reset();
			select.startup();

			// Issue 12-12797
			if (navigator.userAgent.indexOf("Android") > -1)
			{
				var mobileHeight = "40px";
				select.domNode.style.height = mobileHeight;
				var openDropDown = select.openDropDown;
				select.openDropDown = function() {
					var items = select.dropDown.getChildren();
					items.forEach(function(item)
							{
						item.domNode.style.height = mobileHeight;
							});
					openDropDown.apply(select, arguments);
				};
			}
		},
		_getMenuData: function(objectName)
		{
			return this._menuCache[objectName];
		},
		destroyRecursive: function()
		{
			this._templateCache = {};
			this._summaryTemplateCache = {};
		}
	});
});


},
'ibm/tivoli/fwm/mxmap/toolbar/ext/QueryUnassignedWorkDispatcherTool':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */


define(["dojo/main", "dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/toolbar/ext/QueryUnassignedWorkTool", 
	"dijit/form/Button"], function(dojo, declare, QueryUnassignedWorkTool, Button) {
	
	/**
	 * Specialized query unassigned work tool for the Dispatcher view. Bypasses the
	 * dialog and uses the data received by the calendar applet.
	 */
	return declare([QueryUnassignedWorkTool], {
		lastDateIntervalsData: null,
		dispatcherDefaultRefreshOptions: null,
		constructor: function(params)
		{
			this.inherited(arguments);
			this.addSubscription("onMapRefresh_"+this.map.getId(), dojo.hitch(this, this._onMapRefresh));
			this.addSubscription("onDispatcherRefresh_"+this.map.getId(), dojo.hitch(this, this._onDispatcherRefresh));
			// Hardcoded refresh options for every Unassigned WO update when this tool is active
			// (don't show any warning message and don't disable the tool automatically)
			this.dispatcherDefaultRefreshOptions = {
					zoom: false,
					disableMsgs: false,
					automatic: true
				};
		},
		// Uses the last data received by the calendar applet to update the unassigned WOs
		executeOn: function(params)
		{			
			if(this.lastDateIntervalsData != null)
			{
				this.map.getMaximo().queryUnassignedWorkDispatcher(this.lastDateIntervalsData, 
						dojo.hitch(this, function(data) {
							this.queryReturned(data, this.dispatcherDefaultRefreshOptions);
						}),
						dojo.hitch(this, this.cancelQuery));
			}
			
		},
		_onMapRefresh: function(refreshOpts){
			this._refreshUnassignedWorkOrders();
		},
		// Method that is called when the calendar applet
		// sends unassigned WO data
		_onDispatcherRefresh: function(data)
		{
			this.lastDateIntervalsData = {queryData: data};
			this._refreshUnassignedWorkOrders();
		},
		// Disable the tool and reenable it
		_refreshUnassignedWorkOrders: function()
		{
			if(this.isActive() == true){
				this.executeOff();
				this.executeOn({refreshOptions: this.dispatcherDefaultRefreshOptions});
			}
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/layers/LegendLayer':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

/**
 * Represents a symbology legend
 * 
 * The constructor receive the following parameters:
 * 
 * {layerName: a string e.g.: "Approved",
 *  parentLayer: the layer that is creating this layer,
 * }
 */
define(["dojo/_base/declare", "ibm/tivoli/fwm/mxmap/layers/Layer"], function(declare, Layer) {
	return declare([Layer], {
		symbol: null,
		minValue: null,
		maxValue: null,
		isDefault: false,
		/**
		 * Sets the right icon (legend marker)
		 */
		init: function()
		{
			this._disabled = false;
			this.inherited(arguments);
			this._setRightIconURL();
		},
		/**
		 * Updates the status of the legend but do not redraw markers
		 */
		enableButDontRedrawMarkers: function()
		{
			this._disabled = false;
			this._setLeftIconURL();
		},

		/**
		 * Shows markers of this legend
		 */
		enable: function()
		{
			this.enableButDontRedrawMarkers()
			this._map.getLayersManager().redrawMarkers();
		},
		/**
		 * Shows markers of this legend
		 */
		disable: function()
		{
			this._disabled = true;
			this._setLeftIconURL();
			this._map.getLayersManager().redrawMarkers();
		},
		getSymbolURL: function()
		{
			var symbolURL = null;
			if (this.symbol != null){
				symbolURL = this.symbol.url;
			}
			return symbolURL;
		},
		getMinValue: function()
		{
			return this.minValue;
		},
		getMaxValue: function()
		{
			return this.maxValue;
		},
		isDefaultLegend: function()
		{
			return this.isDefault;
		},
		/**
		 * Sets the right icon (legend marker)
		 */
		_setRightIconURL: function()
		{
			this._rightIconURL = this.getSymbolURL();
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/layers/manager/LayersManager':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

/**
 * Controls the map layers
 * 
 * Creates/removes layers based on the records added to them.<br>
 * Sets the records symbologies when added<br>
 */
define([
	"dojo/main",
	"dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/_Base",
	"ibm/tivoli/fwm/mxmap/layers/Layer",
	"ibm/tivoli/fwm/mxmap/ImageLibraryManager",
	"ibm/tivoli/fwm/mxmap/layers/VirtualLayer"
	], function(dojo, declare, _Base, Layer, ImageLibraryManager, VirtualLayer) {
	return declare([_Base], {
		_layers: null,
		_layersById: null,
		symbManager: null,
		_map: null,
		_mboMarkerOptions: null,
		_visibleLayers: null,
		constructor: function(options)
		{
			dojo.mixin(this, options);
			this._layers = {};
			this._layersById = {};
			this._visibleLayers = [];
			this._map = options.map;
			this._multiMarkerOptions = new this.MultiMarkerOptionsTable();
			this.addSubscription("addRecordsToLayer_" + this._map.getId(), dojo.hitch(this, this.addRecordCustomLayer));
			this.addSubscription("removeRecordsFromLayer_" + this._map.getId(), dojo.hitch(this, this.removeRecordsFromLayer));
			this.addSubscription("removeLayer_" + this._map.getId(), dojo.hitch(this, this.removeLayerByName));
			this.addSubscription("changeLayerLatLngSource_" + this._map.getId(), dojo.hitch(this, this.changeLayerLatLngSource));

		},
		getVisibleLayers: function()
		{
			return this._visibleLayers;
		},
		addVisibleLayer: function(layerId)
		{
			var index = this._visibleLayers.indexOf(layerId);
			if (index < 0)
			{
				this._visibleLayers.push(layerId);
			}
			if (this._visibleLayers.length === 0) {
				this._visibleLayers.push(-1);
			}
		},	
		removeVisibleLayer: function(layerId)
		{
			var index = this._visibleLayers.indexOf(layerId);
			if (index > -1)
			{
				this._visibleLayers.splice(index, 1);
			}
			if (this._visibleLayers.length === 0) {
				this._visibleLayers.push(-1);
			}		
		},	
		addRecord: function(mboInfo, markerOptions)
		{
			var layer = this._getLayerForMbo(mboInfo);
			layer.addRecord(mboInfo, markerOptions);
		},
		// find layerid based on the objectname
		_getLayerForMbo: function(mboInfo)
		{
			var mboName = mboInfo.mxdata.mboName;
			return this.getLayerForObjectName(mboName);
		},
		getLayerForObjectName: function(mboName)
		{

			var layer = this.getLayerById(mboName);
			if (layer == null)
			{
				// create Layer
				layer = new Layer({
					layerId: mboName.toLowerCase(),
					layerType: ibm.tivoli.fwm.mxmap.layers.LayerType.LAYER,
					symbManager: this.symbManager,
					map: this.map
				});
				this.addLayer(layer, false);
				layer.enable();
			}
			return layer;
		},
		getLayerIdForMbo: function(mboInfo)
		{
			var mboName = mboInfo.mxdata.mboName;
			return this.getLayerForObjectName(mboName).getLayerId();
		},
		removeRecord: function(mboInfo)
		{
			var mboName = mboInfo.mxdata.mboName;
			var layer = this.getLayerById(mboName);
			if (layer != null)
			{
				layer.removeRecord(mboInfo);
			}
		},
		addRecordCustomLayer: function(layerName, data, cleanBeforeAdd, layerId, childrenTitle, avoidLayerEnabled)
		{
			if (data.length > 0)
			{
				var virtualLayer = this.getLayerById(layerName);
				if (virtualLayer == null)
				{
					virtualLayer = new VirtualLayer({
						layerId: layerName,
						layerType: ibm.tivoli.fwm.mxmap.layers.LayerType.VIRTUAL_LAYER,
						symbManager: this.symbManager,
						map: this.map,
						objectType: data[0].mxdata.mboName
					});
				}
				this.resetLayer(virtualLayer, avoidLayerEnabled);

				for ( var i in data)
				{
					virtualLayer.addRecord(data[i]);
				}

			}
		},
		removeLayerByName: function(layerName, keepLayerEntry, layerId)
		{
			var _layer = this.getLayer(layerName);

			if (_layer)
			{
				_layer.removeMXRecordSetData();
				if (keepLayerEntry != true)
				{
					this._layers[layerName] = null;
					delete this._layers[layerName];
				}
			}

			if (layerId && this._layersById[layerId])
			{
				this._layersById[layerId] = null;
			}

		},
		removeLayer: function(layer)
		{
			delete this._layersById[layer.getLayerId()];
			delete this._layers[layer.getLayerName()];
		},
		addLayer: function(layer, cleanBeforeAdd)
		{
			var layerName = layer.getLayerName();
			var layerId = layer.getLayerId();
			if (dojo.config.fwm.debug == true)
			{
				console.log("[mxmap.layers.LayersManager.addLayer] LayerId: " + layerId);
			}
			var _layer = this.getLayer(layerName);
			if (_layer)
			{
				if (cleanBeforeAdd)
				{
					this.removeLayerByName(layerName, false, layerId);
				}
				_layer.addMXRecordSet(layer.getMXRecordSet());
			}
			else
			{
				this._layers[layerName] = layer;
				if (layerId)
				{
					this._layersById[layerId] = layer;
				}
			}
		},
		resetLayer: function(layer, avoidLayerEnabled)
		{
			var layerName = layer.getLayerName();
			var layerId = layer.getLayerId();
			var _layer = this.getLayer(layerName);
			if (_layer)
			{
				this.removeLayerByName(layerName, false, layerId);
			}
			if (layerName)
			{
				this._layers[layerName] = layer;
			}
			if (layerId)
			{
				this._layersById[layerId] = layer;
			}
			if (layer.isDisabled() && avoidLayerEnabled != true)
			{
				layer.enable();
			}

		},
		showLayer: function(layerName)
		{
			var layer = this.getLayer(layerName);
			if (layer)
			{
				layer.show();
			}
			else
			{
				console.warn("[LayersManager] Cannot show layer " + layerName + " because it was not found.");
			}
		},
		hideLayer: function(layerName)
		{
			var layer = this.getLayer(layerName);
			if (layer)
			{
				layer.hide();
			}
			else
			{
				console.warn("[LayersManager] Cannot hide layer " + layerName + " because it was not found.");
			}
		},
		getLayer: function(layerName)
		{
			if (this._layers.hasOwnProperty(layerName) == true)
			{
				return this._layers[layerName];
			}
			return null;
		},
		redrawMarkers: function()
		{
			for ( var key in this._layers)
			{
				this._layers[key].redrawMarkers();
			}
		},
		getLayerById: function(layerId)
		{
			layerId = layerId.toLowerCase();

			for (id in this._layersById)
			{
				var idLowerCase = id.toLowerCase();
				if (idLowerCase == layerId)
				{
					return this._layersById[id];
				}
			}
			return null;
		},
		/* returns an array with all the existing layers */
		getLayers: function()
		{
			var array = [];
			for ( var key in this._layers)
			{
				array.push(this._layers[key]);
			}
			return array;
		},
		removeRecordsFromLayer: function(layerName, data)
		{
			var layer = this.getLayer(layerName);
			if (layer)
			{
				for ( var i = 0; i < data.length; i++)
				{
					layer.removeRecord(data[i]);
				}
			}
			else
			{
				console.log("[LayerManager] Layer " + layerName + " not found to remove records.");
			}
			this._map.refreshMap();
		},
		_getLayerByIdOrDefaultForMbo: function(layerId, mboInfo)
		{
			if (layerId)
			{
				return this.getLayerById(layerId);
			}
			else
			{
				return this._getLayerForMbo(mboInfo);
			}
		},
		setMboMarkerInfo: function(mboInfo, opt, layerId)
		{
			var layer = this._getLayerByIdOrDefaultForMbo(layerId, mboInfo);
			return layer.setMboMarkerInfo(mboInfo, opt);
		},
		getMboMarkerInfo: function(mboInfo, layerId)
		{
			var layer = this._getLayerByIdOrDefaultForMbo(layerId, mboInfo);
			return layer.getMboMarkerInfo(mboInfo);
		},
		// Retrieves the legend for the mboInfo
		getLegendForRecord: function(mboInfo, layer)
		{
			var lyr = layer;
			var symbology = null;
			var legend = null;
			var activeSymbology = this.symbManager.getActiveSymbology(lyr.getLayerId());
			// Check if active symbology is null because some layers do not
			// have symbologies (like route, traffic and nearby labors/crews)
			if(activeSymbology == null)
			{
				// If symbology is null for the given layer, check if the mbo belongs to any other layer
				// because if it does, then that layer may have a symbology and legends
				// that can be either enabled or disabled. This is true for unassigned work orders.
				lyr = this.getLayerById(mboInfo.mxdata.mboName);
				if(lyr)
				{
					activeSymbology = this.symbManager.getActiveSymbology(lyr.getLayerId());
				}
			}

			if(activeSymbology != null)
			{
				symbologyFound = dojo.filter(lyr.getChildren(), function(child)
						{
					return (child.getLayerId() == activeSymbology.id);
						});
				if (symbologyFound.length > 0)
				{
					var symbology = symbologyFound[0];

					if (activeSymbology.id == "fwm_default")
					{
						// Symbology type: default
						// We assume there's only one value and return it.
						legend = this._getDefaultLegend(symbology);
					}
					else
					{
						if (activeSymbology.type == "numeric")
						{
							legend =  this._getNumericLegend(mboInfo, symbology);
						}
						else if (activeSymbology.type == "domainvalue" || activeSymbology.type == "tablevalue")
						{
							legend =  this._getDomainLegend(mboInfo, symbology);
						}
						else
						{
							// Shouldn't ever happen, but just in case...
							legend = this._getDefaultLegend(symbology);
						}
					}
				}
			}
			return legend;
		},
		/*
		 * Returns the default legend for the given symbology.
		 */
		_getDefaultLegend: function(symbology)
		{
			var legends = symbology.getChildren();

			var defaultLegend = dojo.filter(legends, function(legend)
					{
				return legend.getLayerConfig().isDefault == true;
					});
			return defaultLegend.length > 0 ? defaultLegend[0] : null;
		},
		/*
		 * Returns the legend for the given object in the given symbology,
		 * based on the relevant attribute's value and the configured ranges.
		 */
		_getNumericLegend: function(object, symbology)
		{
			// Symbology type: numeric
			// We try to convert the value to a number and find a range that
			// contains that number. If either fails we return the legend.
			var legends = symbology.getChildren();
			var val = object.mxdata.attributes[symbology.getLayerId()];
			if (val == "")
			{
				val = "null";
				var legendFound = dojo.filter(legends, function(legend)
						{
					return (legend.getLayerId() == val);
						});
				return (legendFound.length > 0 ? legendFound[0] : this._getDefaultLegend(symbology));
			}
			else if (!val)
			{
				return this._getDefaultLegend(symbology);
			}
			else
			{
				var attrVal = parseInt(val);
				var legendFound = dojo.filter(legends, function(legend)
						{
					return (attrVal >= parseInt(legend.getLayerConfig().minValue) && attrVal <= parseInt(legend.getLayerConfig().maxValue));
						});
				return (legendFound.length > 0 ? legendFound[0] : this._getDefaultLegend(symbology));
			}
		},
		/*
		 * Returns the right symbol for the given object in the given symbology,
		 * based on the relevant attribute's value and the configured value/symbol
		 * pairs.
		 */
		_getDomainLegend: function(object, symbology)
		{
			var legends = symbology.getChildren();
			var attrVal = String(object.mxdata.attributes[symbology.getLayerId()]).toLowerCase();
			if (attrVal == "")
				attrVal = "null";
			var legendFound = dojo.filter(legends, function(legend)
					{
				return (legend.getLayerId() == attrVal);
					});
			return (legendFound.length > 0 ? legendFound[0] : this._getDefaultLegend(symbology));
		},
		isLegendEnabledForRecord: function(legend)
		{
			// By default, show the mbo marker, unless it's legend is disabled
			var legendEnabled = true;
			if(legend != null)
			{
				if(legend.isDisabled() == true)
				{
					legendEnabled = false;
				}
			}
			return legendEnabled;
		},
		// Resets all layers (enable) for symbology
		resetLegends: function(symbology, dontRedrawMarkers)
		{
			var legends = symbology.getChildren();
			for(var i = 0; i < legends.length; i++)
			{
				legends[i].enableButDontRedrawMarkers();
			}
			if(!dontRedrawMarkers)
			{
				this.redrawMarkers();
			}
		},
		// Resets the symbology (enable the default one) for a given layer
		// and reset all their legends (enable them)
		resetSymbologies: function(layer, dontRedrawMarkers)
		{
			var symbologies = layer.getChildren();
			for(var i = 0; i < symbologies.length; i++)
			{
				this.resetLegends(symbologies[i], true);
				if(symbologies[i].isDefault())
				{
					symbologies[i].toggleStateButDontRedrawMarkers();
				}
			}
			if(!dontRedrawMarkers)
			{
				this.redrawMarkers();
			}
		},
		// Resets the layers, symbologies and legends to default values
		// Layers: All of them enabled except for Traffic
		// Symbologies: Enable the default one for each layer
		// Legends: Enable all of them
		resetLayers: function()
		{
			for ( var layerKey in this._layers)
			{
				var layer = this._layers[layerKey];
				// Reset all layers but for the traffic layer 
				if(layer.getLayerId() != "traffic")
				{
					this.resetSymbologies(layer, true);
					if(layer.isDisabled())
					{
						layer.enable();
					}
					else
					{
						layer.redrawMarkers();
					}
				}
				else
				{
					// The traffic layer is disabled by default
					layer.disable();
				}
			}
		},
		iterateOverAllRecords: function(fct)
		{
			for (var layerKey in this._layers)
			{
				var layer = this._layers[layerKey];
				var records = layer.getRecords();
				for (var i = 0; i < records.length; i++)
				{
					if(fct)
					{
						fct(records[i]);
					}
				}
			}
		},
		// Compares lat/lon of this record with the lat/lon of all the other existing records
		// If any other record is at the same spot as this one, add references to both of them. 
		// Returns an array with the records at the same spot as newRecord (including newRecord)
		addRecordsAtTheSameSpotReferences: function(newRecord)
		{
			recordsAtTheSameSpot = [];
			this.iterateOverAllRecords(dojo.hitch(this, function(existingRecord){
				// The existing record needs to be currently showing up on the map
				if((existingRecord.isOnMap == true))
				{
					// There is no point in comparing the records if they are the same... duh!
					if(!this.areMboInfosEqual(newRecord, existingRecord))
					{
						// Check lat/lon values for both records, if they are exactly the same,
						// then add references to both
						if(this.areMbosAtTheSameSpot(newRecord, existingRecord))
						{
							// Just in case the array has not yet been defined
							if(newRecord.recordsAtTheSameSpot == undefined)
							{
								newRecord.recordsAtTheSameSpot = [];
							}
							if(existingRecord.recordsAtTheSameSpot == undefined)
							{
								existingRecord.recordsAtTheSameSpot = [];
							}
							// Add the references
							newRecord.recordsAtTheSameSpot.push(existingRecord);
							existingRecord.recordsAtTheSameSpot.push(newRecord);
							recordsAtTheSameSpot.push(existingRecord);
						}
					}
				}
			}));
			recordsAtTheSameSpot.push(newRecord);
			return recordsAtTheSameSpot;
		},
		// Removes the references to records at the same spot when removing a record from the map
		// Returns an array with the remaining records at the same spot as removedRecord
		removeRecordsAtTheSameSpotReferences: function(removedRecord)
		{
			var remainingRecordsAtTheSpot = [];
			var referencedRecord = null;
			if(removedRecord.recordsAtTheSameSpot != undefined)
			{
				// Remove all the references from removedRecord
				// and also remove the reference to removedRecord from all other records that are at the same spot
				if(removedRecord.recordsAtTheSameSpot.length > 0)
				{
					while(removedRecord.recordsAtTheSameSpot.length)
					{
						// Remove the reference from removedRecord
						referencedRecord = removedRecord.recordsAtTheSameSpot.shift();
						// Now, search all references in referencedRecord and remove the one
						// pointing to removedRecord
						if(referencedRecord.recordsAtTheSameSpot != undefined)
						{
							remainingRecordsAtTheSpot.push(referencedRecord);
							for(var i=0; i<referencedRecord.recordsAtTheSameSpot.length; i++)
							{
								if(this.areMboInfosEqual(removedRecord, referencedRecord.recordsAtTheSameSpot[i]))
								{
									referencedRecord.recordsAtTheSameSpot.splice(i,1);
									i--;
								}
							}
						}
					}
				}
			}
			return remainingRecordsAtTheSpot;
		},
		// Check if a mboInfo1 and mboInfo2 are the same record
		areMboInfosEqual: function(mboInfo1, mboInfo2)
		{
			var mbosEqual = (mboInfo1.mxdata.mboName == mboInfo2.mxdata.mboName) && (mboInfo1.mxdata.uid.value == mboInfo2.mxdata.uid.value);
			if((mboInfo1.extrakey != null) && (mboInfo1.extrakey != undefined) && (mboInfo2.extrakey != null) && (mboInfo2.extrakey != undefined))
			{
				if(mboInfo1.extrakey != mboInfo2.extrakey)
				{
					mbosEqual = false;
				}
			}
			return (mbosEqual);
		},
		// Check if mboInfo1 and mboInfo2 are at the same lat/lng
		areMbosAtTheSameSpot: function(mboInfo1, mboInfo2)
		{
			var sameSpot = false;
			var point1 = this.map.getLatLngFromMboInfo(mboInfo1);
			var point2 = this.map.getLatLngFromMboInfo(mboInfo2);
			if((point1 != null) && (point2 != null))
			{
				sameSpot = ((point1.lat == point2.lat) && (point1.lng == point2.lng)); 
			}
			return sameSpot;
		},
		setMultiMarkerInfo: function(mboInfo, opt)
		{
			return this._multiMarkerOptions.setMultiMarkerInfo(mboInfo, opt);
		},
		getMultiMarkerInfo: function(mboInfo)
		{
			return this._multiMarkerOptions.getMultiMarkerInfo(mboInfo);
		},
		// If useLBSPosition is true for a layer, it means that lat/lng
		// should be retrieved from the mbo's "lbsdata" instead of "gisdata"
		changeLayerLatLngSource: function(layerId, useLBSPosition)
		{
			var layer = this.getLayerById(layerId);
			if(layer)
			{
				layer.setUseLBSPosition(useLBSPosition);
				this._map.refreshMap();
			}
		},
		getMultiMarkerInfoUsingGisData: function(mbo)
		{
			return this._multiMarkerOptions.getMultiMarkerInfoUsingGisData(mbo);
		},
		// Same as MboMultiMarkerOptionsTable in Layer.js but this one uses
		// the lat/lng as hash key
		MultiMarkerOptionsTable: function ()  {
			this.multiMarkersOnMap = {};
			/*
			 * Stores a reference for the given multimarker with the given options. If a
			 * reference already exists, updates all of its properties with the given
			 * ones.
			 */
			this.setMultiMarkerInfo = function(mboInfo, opt)
			{
				this._createMultiMarkerHashRecord(mboInfo);
				for ( var propName in opt)
				{
					this.multiMarkersOnMap[mboInfo.pointInCurrentSR.lat][mboInfo.pointInCurrentSR.lng][propName] = opt[propName];
				}

			};
			/*
			 * Creates a reference for the given MBO in the map's MBO marker map. The
			 * reference count is initialized to 0.
			 */
			this._createMultiMarkerHashRecord = function(mboInfo)
			{
				if (!this.multiMarkersOnMap[mboInfo.pointInCurrentSR.lat])
				{
					this.multiMarkersOnMap[mboInfo.pointInCurrentSR.lat] = {};
				}
				if (!this.multiMarkersOnMap[mboInfo.pointInCurrentSR.lat][mboInfo.pointInCurrentSR.lng])
				{
					this.multiMarkersOnMap[mboInfo.pointInCurrentSR.lat][mboInfo.pointInCurrentSR.lng] = {};
				}
			};
			/*
			 * Returns the stored multi marker info for the given MBO.
			 */
			this.getMultiMarkerInfo = function(mboInfo)
			{
				if (mboInfo == null || !mboInfo.pointInCurrentSR)
				{
					return null;
				}
				if (!this.multiMarkersOnMap[mboInfo.pointInCurrentSR.lat])
				{
					return null;
				}
				if (!this.multiMarkersOnMap[mboInfo.pointInCurrentSR.lat][mboInfo.pointInCurrentSR.lng])
				{
					return null;
				}
				return this.multiMarkersOnMap[mboInfo.pointInCurrentSR.lat][mboInfo.pointInCurrentSR.lng];
			};

			/*
			 * Returns the stored multi marker info for the given MBO. 
			 * This function uses the lat/lng in gisdata to retrieve the info 
			 * instead of the lat/lng in pointInCurrentSR.
			 */
			this.getMultiMarkerInfoUsingGisData = function(mbo)
			{
				if (mbo == null || !mbo.gisdata)
				{
					return null;
				}
				if (!this.multiMarkersOnMap[mbo.gisdata.lat])
				{
					return null;
				}
				if (!this.multiMarkersOnMap[mbo.gisdata.lat][mbo.gisdata.lng])
				{
					return null;
				}
				return this.multiMarkersOnMap[mbo.gisdata.lat][mbo.gisdata.lng];
			};
		}
	});

});

},
'ibm/tivoli/fwm/mxmap/helpers/GeocoderHelper':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */



define(["dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/_Base",
	"ibm/tivoli/fwm/mxmap/util/AddressCandidatesFormatter",
	"ibm/tivoli/fwm/mxmap/panels/MobileInfoPanelDialog",
	"ibm/tivoli/fwm/i18n"],
	function(declare, _Base, AddressCandidatesFormatter, MobileInfoPanelDialog, i18n  ) {

	ibm.tivoli.fwm.mxmap.GeoCodeErrorCodes={
		ZERO_RESULTS:"ZERO_RESULTS",
		INVALID_REQUEST:"INVALID_REQUEST",
		REQUEST_DENIED:"REQUEST_DENIED",
		OVER_LIMIT:"OVER_LIMIT",	
		UNKNOWN:"UNKNOWN"
	};
	
	/**
	 * Maximo geocoder helper class.
	 */
	return declare([_Base], {
		
		map: null,	 
		key: null, //some GeoCoder provider demand a Key to be passed to the geocoder interface
		_geocode : null,
		_candidateDialog: null,

		/**
		 * Adds the listener to the mxmap_geocoder event which triggers the
		 * findlocation action
		 * 
		 * @param options
		 */
		constructor : function(options) {
			dojo.mixin(this, options);
			this.addSubscription("mxmap_geocoder_"+this.map.getId(), dojo.hitch(this, this.findLocation));
			this.addSubscription("addressCandidateSelectedOnMapId_" + this.map.getId(), dojo.hitch(this, this._addressCandidateSelected));
		},

		/**
		 * Find a location on the map based on the address string.<br>
		 * 
		 * In case it fails to find an address it displays the returned Geocode
		 * status message.
		 * 
		 * @param address -
		 *            the address string to be geocoded
		 * @param callback -
		 *            If any success function must handle the results other than the
		 *            default one. By default it sets the returned data (coords and
		 *            address) into the current SA record.
		 * @see Geocoder.returnFindLocation
		 * @param errorCallback -
		 *            If any error function must handle the results other than the
		 *            default one.
		 * @see Geocoder.errorDuringGeocode
		 */
		findLocation : function(address, callback, errorCallback) {
			if(!address || address.length==0){
				return;
			}
			if (!errorCallback) {
				errorCallback = dojo.hitch(this, this.errorDuringGeocode);
			}
			if (!callback) {
				callback = dojo.hitch(this, this.returnFindLocation);
			}
			this.map.geocode(callback, errorCallback, this.key, address);
		},

		/**
		 * Reverse geocode based on lat/lng coordinates. <br>
		 * 
		 * @param lat -
		 *            Latitude
		 * @param lng -
		 *            Longitude
		 * @param callback -
		 *            If any success function must handle the results other than the
		 *            default one. By default it sets back the currentSA record
		 *            address.
		 * @see Geocoder.returnUpdateAddress
		 * @param errorCallback -
		 *            If any error function must handle the results other than the
		 *            default one.
		 * @see Geocoder.returnFindLocation
		 */
		reverseGeocode : function(lat, lng, callback, errorCallback) {
			if (!errorCallback) {
				errorCallback = dojo.hitch(this, this.errorDuringGeocode);
			}
			if (!callback) {
				callback = dojo.hitch(this, this.returnUpdateAddress);
			}

			this.map.reverseGeocode(callback, errorCallback, this.key, lat, lng);
		},

		convertGeocodedAddressIntoFormattedAddress : function(location) {
			return location.formattedAddress;
		},

		/**
		 * Having a location with coords data, set the current SA record coords.
		 * 
		 * @param addressCandidates 
		 */
		returnFindLocation: function(addressCandidates) {
			if ( this.map.mapConf.provider == "spatial") { 
				this.map.hideLoadingImg();
			}
			if (dojo.config.fwm.debug == true)
			{
				console.log("[Geocoder] Address candidates: ", addressCandidates);
			}
			if(addressCandidates.length == 1){
				var location1 = addressCandidates[0];
				this.map.getMaximo().setCurrentRecordLocation({
					lat : location1.point.lat,
					lng : location1.point.lng,
					address : this.convertGeocodedAddressIntoFormattedAddress(location1)
				});
				dojo.publish('findLocationSelected',[])
			}else{
				var me = this;
				var title = ibm.tivoli.fwm.i18n.getMaxMsg("map", "addresscandidates");
				var zInd=100000;
				if(this._candidateDialog==null){
					this._candidateDialog = new MobileInfoPanelDialog({map: me.map, title: title, nonModal: true}); 
				}
				var content1 = AddressCandidatesFormatter
				.createHTMLDOMWithList(
						addressCandidates,
						this.map.getId(),
						this._candidateDialog.getCalculatedWidth(),
						this._candidateDialog.getCalculatedHeight());			
				this._candidateDialog.setContent(content1);
				this._candidateDialog.show();
				this._candidateDialog._theDialog.domNode.style.zIndex=zInd;
			}
		},

		/**
		 * Having a location with address data, set the current SA record formattted
		 * address.
		 * 
		 * @param object
		 *            with address information.
		 */
		returnUpdateAddress : function(location) {
			this.map.getMaximo().setCurrentRecordLocation({
				address : this.convertGeocodedAddressIntoFormattedAddress(location)
			});
		},

		/**
		 * Handles geocoding errors and display msgs accordingly
		 * 
		 * @param String
		 *            with error value
		 */
		errorDuringGeocode : function(errorCode) {
			switch (errorCode) {

			case ibm.tivoli.fwm.mxmap.GeoCodeErrorCodes.ZERO_RESULTS:
				this.map.getMaximo().showMessage("mapserver", "geocode_noresults");
				break;
			case ibm.tivoli.fwm.mxmap.GeoCodeErrorCodes.INVALID_REQUEST:
				this.map.getMaximo().showMessage("mapserver", "geocode_invalid_req");
				break;
			case ibm.tivoli.fwm.mxmap.GeoCodeErrorCodes.REQUEST_DENIED:
				this.map.getMaximo().showMessage("mapserver", "geocode_req_denied");
				break;
			case ibm.tivoli.fwm.mxmap.GeoCodeErrorCodes.OVER_LIMIT:
				this.map.getMaximo().showMessage("mapserver", "geocode_limits_exceed");
				break;

			case ibm.tivoli.fwm.mxmap.GeoCodeErrorCodes.UNKNOWN:
				this.map.getMaximo().showMessage("mapserver", "geocode_unknown_error");
				break;

			default:
				this.map.getMaximo().showMessage("mapserver", "geocode_unknown_error");
			break;
			}		
			if ( this.map.mapConf.provider == "spatial") { 
				this.map.hideLoadingImg();
			}
			console.info("[Geocoder] Geocoder Service returned an error code: ", errorCode);
		},

		/**
		 * Callback method for address selected from the address candidate dialog 
		 * address.
		 * 
		 * @param object with address information.
		 */
		_addressCandidateSelected: function(addressSelected)
		{
			if(this._candidateDialog){			
				this._candidateDialog.close();
				this._candidateDialog = null;
			}
			this.returnFindLocation([addressSelected]);
		}
	});
});

},
'dojo/parser':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"require", "./_base/kernel", "./_base/lang", "./_base/array", "./_base/config", "./dom", "./_base/window",
	"./_base/url", "./aspect", "./promise/all", "./date/stamp", "./Deferred", "./has", "./json5", "./query", "./on",
	"./ready"
], function(require, dojo, dlang, darray, config, dom, dwindow, _Url, aspect, all, dates, Deferred, has, json5, query,
	don, ready){

	// module:
	//		dojo/parser

	new Date("X"); // workaround for #11279, new Date("") == NaN

	var myEval;
	if(has('csp-restrictions')) {
		// JSON5 data attributes can be parsed without using eval; JS expressions will throw an error
		myEval = json5.parse;
	}
	else {
		myEval = function(text){
			// data-dojo-props etc. is not restricted to JSON, it can be any javascript
			/* jshint -W061 */
			return eval("(" + text + ")");
		};
	}

	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget's parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	var extendCnt = 0;
	aspect.after(dlang, "extend", function(){
		extendCnt++;
	}, true);

	function getNameMap(ctor){
		// summary:
		//		Returns map from lowercase name to attribute name in class, ex: {onclick: "onClick"}
		var map = ctor._nameCaseMap, proto = ctor.prototype;

		// Create the map if it's undefined.
		// Refresh the map if a superclass was possibly extended with new methods since the map was created.
		if(!map || map._extendCnt < extendCnt){
			map = ctor._nameCaseMap = {};
			for(var name in proto){
				if(name.charAt(0) === "_"){
					continue;
				}	// skip internal properties
				map[name.toLowerCase()] = name;
			}
			map._extendCnt = extendCnt;
		}
		return map;
	}

	function getCtor(/*String[]*/ types, /*Function?*/ contextRequire){
		// summary:
		//		Retrieves a constructor.  If the types array contains more than one class/MID then the
		//		subsequent classes will be mixed into the first class and a unique constructor will be
		//		returned for that array.

		if(!contextRequire){
			contextRequire = require;
		}

		// Map from widget name or list of widget names(ex: "dijit/form/Button,acme/MyMixin") to a constructor.
		// Keep separate map for each requireContext to avoid false matches (ex: "./Foo" can mean different things
		// depending on context.)
		var ctorMap = contextRequire._dojoParserCtorMap || (contextRequire._dojoParserCtorMap = {});

		var ts = types.join();
		if(!ctorMap[ts]){
			var mixins = [];
			for(var i = 0, l = types.length; i < l; i++){
				var t = types[i];
				// TODO: Consider swapping getObject and require in the future
				mixins[mixins.length] = (ctorMap[t] = ctorMap[t] || (dlang.getObject(t) || (~t.indexOf('/') &&
					contextRequire(t))));
			}
			var ctor = mixins.shift();
			ctorMap[ts] = mixins.length ? (ctor.createSubclass ? ctor.createSubclass(mixins) : ctor.extend.apply(ctor, mixins)) : ctor;
		}

		return ctorMap[ts];
	}

	var parser = {
		// summary:
		//		The Dom/Widget parsing package

		_clearCache: function(){
			// summary:
			//		Clear cached data.   Used mainly for benchmarking.
			extendCnt++;
			_ctorMap = {};
		},

		_functionFromScript: function(script, attrData){
			// summary:
			//		Convert a `<script type="dojo/method" args="a, b, c"> ... </script>`
			//		into a function
			// script: DOMNode
			//		The `<script>` DOMNode
			// attrData: String
			//		For HTML5 compliance, searches for attrData + "args" (typically
			//		"data-dojo-args") instead of "args"
			var preamble = "",
				suffix = "",
				argsStr = (script.getAttribute(attrData + "args") || script.getAttribute("args")),
				withStr = script.getAttribute("with");

			// Convert any arguments supplied in script tag into an array to be passed to the
			var fnArgs = (argsStr || "").split(/\s*,\s*/);

			if(withStr && withStr.length){
				darray.forEach(withStr.split(/\s*,\s*/), function(part){
					preamble += "with(" + part + "){";
					suffix += "}";
				});
			}

			return new Function(fnArgs, preamble + script.innerHTML + suffix);
		},

		instantiate: function(nodes, mixin, options){
			// summary:
			//		Takes array of nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of DOM nodes
			// mixin: Object?
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object?
			//		An object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returns:
			//		Array of instances.

			mixin = mixin || {};
			options = options || {};

			var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
				attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
				dataDojoType = attrData + "type", // typically "data-dojo-type"
				dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"

			var list = [];
			darray.forEach(nodes, function(node){
				var type = dojoType in mixin ? mixin[dojoType] : node.getAttribute(dataDojoType) || node.getAttribute(dojoType);
				if(type){
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					list.push({
						node: node,
						types: types
					});
				}
			});

			// Instantiate the nodes and return the list of instances.
			return this._instantiate(list, mixin, options);
		},

		_instantiate: function(nodes, mixin, options, returnPromise){
			// summary:
			//		Takes array of objects representing nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of objects like
			//	|		{
			//	|			ctor: Function (may be null)
			//	|			types: ["dijit/form/Button", "acme/MyMixin"] (used if ctor not specified)
			//	|			node: DOMNode,
			//	|			scripts: [ ... ],	// array of <script type="dojo/..."> children of node
			//	|			inherited: { ... }	// settings inherited from ancestors like dir, theme, etc.
			//	|		}
			// mixin: Object
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object
			//		An options object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returnPromise: Boolean
			//		Return a Promise rather than the instance; supports asynchronous widget creation.
			// returns:
			//		Array of instances, or if returnPromise is true, a promise for array of instances
			//		that resolves when instances have finished initializing.

			// Call widget constructors.   Some may be asynchronous and return promises.
			var thelist = darray.map(nodes, function(obj){
				var ctor = obj.ctor || getCtor(obj.types, options.contextRequire);
				// If we still haven't resolved a ctor, it is fatal now
				if(!ctor){
					throw new Error("Unable to resolve constructor for: '" + obj.types.join() + "'");
				}
				return this.construct(ctor, obj.node, mixin, options, obj.scripts, obj.inherited);
			}, this);

			// After all widget construction finishes, call startup on each top level instance if it makes sense (as for
			// widgets).  Parent widgets will recursively call startup on their (non-top level) children
			function onConstruct(thelist){
				if(!mixin._started && !options.noStart){
					darray.forEach(thelist, function(instance){
						if(typeof instance.startup === "function" && !instance._started){
							instance.startup();
						}
					});
				}

				return thelist;
			}

			if(returnPromise){
				return all(thelist).then(onConstruct);
			}else{
				// Back-compat path, remove for 2.0
				return onConstruct(thelist);
			}
		},

		construct: function(ctor, node, mixin, options, scripts, inherited){
			// summary:
			//		Calls new ctor(params, node), where params is the hash of parameters specified on the node,
			//		excluding data-dojo-type and data-dojo-mixins.   Does not call startup().
			// ctor: Function
			//		Widget constructor.
			// node: DOMNode
			//		This node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.
			// mixin: Object?
			//		Attributes in this object will be passed as parameters to ctor,
			//		overriding attributes specified on the node.
			// options: Object?
			//		An options object used to hold kwArgs for instantiation.   See parse.options argument for details.
			// scripts: DomNode[]?
			//		Array of `<script type="dojo/*">` DOMNodes.  If not specified, will search for `<script>` tags inside node.
			// inherited: Object?
			//		Settings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.
			// returns:
			//		Instance or Promise for the instance, if markupFactory() itself returned a promise

			var proto = ctor && ctor.prototype;
			options = options || {};

			// Setup hash to hold parameter settings for this widget.	Start with the parameter
			// settings inherited from ancestors ("dir" and "lang").
			// Inherited setting may later be overridden by explicit settings on node itself.
			var params = {};

			if(options.defaults){
				// settings for the document itself (or whatever subtree is being parsed)
				dlang.mixin(params, options.defaults);
			}
			if(inherited){
				// settings from dir=rtl or lang=... on a node above this node
				dlang.mixin(params, inherited);
			}

			// Get list of attributes explicitly listed in the markup
			var attributes;
			if(has("dom-attributes-explicit")){
				// Standard path to get list of user specified attributes
				attributes = node.attributes;
			}else if(has("dom-attributes-specified-flag")){
				// Special processing needed for IE8, to skip a few faux values in attributes[]
				attributes = darray.filter(node.attributes, function(a){
					return a.specified;
				});
			}else{
				// Special path for IE6-7, avoid (sometimes >100) bogus entries in node.attributes
				var clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false),
					attrs = clone.outerHTML.replace(/=[^\s"']+|="[^"]*"|='[^']*'/g, "").replace(/^\s*<[a-zA-Z0-9]*\s*/, "").replace(/\s*>.*$/, "");

				attributes = darray.map(attrs.split(/\s+/), function(name){
					var lcName = name.toLowerCase();
					return {
						name: name,
						// getAttribute() doesn't work for button.value, returns innerHTML of button.
						// but getAttributeNode().value doesn't work for the form.encType or li.value
						value: (node.nodeName == "LI" && name == "value") || lcName == "enctype" ?
							node.getAttribute(lcName) : node.getAttributeNode(lcName).value
					};
				});
			}

			// Hash to convert scoped attribute name (ex: data-dojo17-params) to something friendly (ex: data-dojo-params)
			// TODO: remove scope for 2.0
			var scope = options.scope || dojo._scopeName,
				attrData = "data-" + scope + "-", // typically "data-dojo-"
				hash = {};
			if(scope !== "dojo"){
				hash[attrData + "props"] = "data-dojo-props";
				hash[attrData + "type"] = "data-dojo-type";
				hash[attrData + "mixins"] = "data-dojo-mixins";
				hash[scope + "type"] = "dojotype";
				hash[attrData + "id"] = "data-dojo-id";
			}

			// Read in attributes and process them, including data-dojo-props, data-dojo-type,
			// dojoAttachPoint, etc., as well as normal foo=bar attributes.
			var i = 0, item, funcAttrs = [], jsname, extra;
			while(item = attributes[i++]){
				var name = item.name,
					lcName = name.toLowerCase(),
					value = item.value;

				switch(hash[lcName] || lcName){
				// Already processed, just ignore
				case "data-dojo-type":
				case "dojotype":
				case "data-dojo-mixins":
					break;

				// Data-dojo-props.   Save for later to make sure it overrides direct foo=bar settings
				case "data-dojo-props":
					extra = value;
					break;

				// data-dojo-id or jsId. TODO: drop jsId in 2.0
				case "data-dojo-id":
				case "jsid":
					jsname = value;
					break;

				// For the benefit of _Templated
				case "data-dojo-attach-point":
				case "dojoattachpoint":
					params.dojoAttachPoint = value;
					break;
				case "data-dojo-attach-event":
				case "dojoattachevent":
					params.dojoAttachEvent = value;
					break;

				// Special parameter handling needed for IE
				case "class":
					params["class"] = node.className;
					break;
				case "style":
					params["style"] = node.style && node.style.cssText;
					break;
				default:
					// Normal attribute, ex: value="123"

					// Find attribute in widget corresponding to specified name.
					// May involve case conversion, ex: onclick --> onClick
					if(!(name in proto)){
						var map = getNameMap(ctor);
						name = map[lcName] || name;
					}

					// Set params[name] to value, doing type conversion
					if(name in proto){
						switch(typeof proto[name]){
						case "string":
							params[name] = value;
							break;
						case "number":
							params[name] = value.length ? Number(value) : NaN;
							break;
						case "boolean":
							// for checked/disabled value might be "" or "checked".	 interpret as true.
							params[name] = value.toLowerCase() != "false";
							break;
						case "function":
							if(value === "" || value.search(/[^\w\.]+/i) != -1){
								// The user has specified some text for a function like "return x+5"
								params[name] = new Function(value);
							}else{
								// The user has specified the name of a global function like "myOnClick"
								// or a single word function "return"
								params[name] = dlang.getObject(value, false) || new Function(value);
							}
							funcAttrs.push(name);	// prevent "double connect", see #15026
							break;
						default:
							var pVal = proto[name];
							try{
								params[name] =
									(pVal && "length" in pVal) ? (value ? value.split(/\s*,\s*/) : []) :	// array
										(pVal instanceof Date) ?
											(value == "" ? new Date("") :	// the NaN of dates
											value == "now" ? new Date() :	// current date
											dates.fromISOString(value)) :
									(pVal instanceof _Url) ? (dojo.baseUrl + value) :
									myEval(value);
							}
							catch(error){
								console.error(error);
							}
						}
					}else{
						params[name] = value;
					}
				}
			}

			// Remove function attributes from DOMNode to prevent "double connect" problem, see #15026.
			// Do this as a separate loop since attributes[] is often a live collection (depends on the browser though).
			for(var j = 0; j < funcAttrs.length; j++){
				var lcfname = funcAttrs[j].toLowerCase();
				node.removeAttribute(lcfname);
				node[lcfname] = null;
			}

			// Mix things found in data-dojo-props into the params, overriding any direct settings
			if(extra){
				try{
					extra = myEval.call(options.propsThis, "{" + extra + "}");
					dlang.mixin(params, extra);
				}catch(e){
					// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?
					throw new Error(e.toString() + " in data-dojo-props='" + extra + "'");
				}
			}

			// Any parameters specified in "mixin" override everything else.
			dlang.mixin(params, mixin);

			// Get <script> nodes associated with this widget, if they weren't specified explicitly
			if(!scripts){
				scripts = (ctor && (ctor._noScript || proto._noScript) ? [] : query("> script[type^='dojo/']", node));
			}

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" data-dojo-event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" data-dojo-event="foo"> tags are dojo.connected after instantiation,
			// and likewise with <script type="dojo/aspect" data-dojo-method="foo">
			// <script type="dojo/watch" data-dojo-prop="foo"> tags are dojo.watch after instantiation
			// <script type="dojo/on" data-dojo-event="foo"> tags are dojo.on after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			var aspects = [],	// aspects to connect after instantiation
				calls = [],		// functions to call after instantiation
				watches = [],  // functions to watch after instantiation
				ons = []; // functions to on after instantiation

			if(scripts){
				for(i = 0; i < scripts.length; i++){
					var script = scripts[i];
					node.removeChild(script);
					// FIXME: drop event="" support in 2.0. use data-dojo-event="" instead
					var event = (script.getAttribute(attrData + "event") || script.getAttribute("event")),
						prop = script.getAttribute(attrData + "prop"),
						method = script.getAttribute(attrData + "method"),
						advice = script.getAttribute(attrData + "advice"),
						scriptType = script.getAttribute("type"),
						nf = this._functionFromScript(script, attrData);
					if(event){
						if(scriptType == "dojo/connect"){
							aspects.push({ method: event, func: nf });
						}else if(scriptType == "dojo/on"){
							ons.push({ event: event, func: nf });
						}else{
							// <script type="dojo/method" data-dojo-event="foo">
							// TODO for 2.0: use data-dojo-method="foo" instead (also affects dijit/Declaration)
							params[event] = nf;
						}
					}else if(scriptType == "dojo/aspect"){
						aspects.push({ method: method, advice: advice, func: nf });
					}else if(scriptType == "dojo/watch"){
						watches.push({ prop: prop, func: nf });
					}else{
						calls.push(nf);
					}
				}
			}

			// create the instance
			var markupFactory = ctor.markupFactory || proto.markupFactory;
			var instance = markupFactory ? markupFactory(params, node, ctor) : new ctor(params, node);

			function onInstantiate(instance){
				// map it to the JS namespace if that makes sense
				if(jsname){
					dlang.setObject(jsname, instance);
				}

				// process connections and startup functions
				for(i = 0; i < aspects.length; i++){
					aspect[aspects[i].advice || "after"](instance, aspects[i].method, dlang.hitch(instance, aspects[i].func), true);
				}
				for(i = 0; i < calls.length; i++){
					calls[i].call(instance);
				}
				for(i = 0; i < watches.length; i++){
					instance.watch(watches[i].prop, watches[i].func);
				}
				for(i = 0; i < ons.length; i++){
					don(instance, ons[i].event, ons[i].func);
				}

				return instance;
			}

			if(instance.then){
				return instance.then(onInstantiate);
			}else{
				return onInstantiate(instance);
			}
		},

		scan: function(root, options){
			// summary:
			//		Scan a DOM tree and return an array of objects representing the DOMNodes
			//		that need to be turned into widgets.
			// description:
			//		Search specified node (or document root node) recursively for class instances
			//		and return an array of objects that represent potential widgets to be
			//		instantiated. Searches for either data-dojo-type="MID" or dojoType="MID" where
			//		"MID" is a module ID like "dijit/form/Button" or a fully qualified Class name
			//		like "dijit/form/Button".  If the MID is not currently available, scan will
			//		attempt to require() in the module.
			//
			//		See parser.parse() for details of markup.
			// root: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object
			//		a kwArgs options object, see parse() for details
			//
			// returns: Promise
			//		A promise that is resolved with the nodes that have been parsed.

			var list = [], // Output List
				mids = [], // An array of modules that are not yet loaded
				midsHash = {}; // Used to keep the mids array unique

			var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
				attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
				dataDojoType = attrData + "type", // typically "data-dojo-type"
				dataDojoTextDir = attrData + "textdir", // typically "data-dojo-textdir"
				dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"

			// Info on DOMNode currently being processed
			var node = root.firstChild;

			// Info on parent of DOMNode currently being processed
			//	- inherited: dir, lang, and textDir setting of parent, or inherited by parent
			//	- parent: pointer to identical structure for my parent (or null if no parent)
			//	- scripts: if specified, collects <script type="dojo/..."> type nodes from children
			var inherited = options.inherited;
			if(!inherited){
				var findAncestorAttr = function findAncestorAttr(node, attr){
					return (node.getAttribute && node.getAttribute(attr)) ||
						(node.parentNode && findAncestorAttr(node.parentNode, attr));
				};

				inherited = {
					dir: findAncestorAttr(root, "dir"),
					lang: findAncestorAttr(root, "lang"),
					textDir: findAncestorAttr(root, dataDojoTextDir)
				};
				for(var key in inherited){
					if(!inherited[key]){
						delete inherited[key];
					}
				}
			}

			// Metadata about parent node
			var parent = {
				inherited: inherited
			};

			// For collecting <script type="dojo/..."> type nodes (when null, we don't need to collect)
			var scripts;

			// when true, only look for <script type="dojo/..."> tags, and don't recurse to children
			var scriptsOnly;

			function getEffective(parent){
				// summary:
				//		Get effective dir, lang, textDir settings for specified obj
				//		(matching "parent" object structure above), and do caching.
				//		Take care not to return null entries.
				if(!parent.inherited){
					parent.inherited = {};
					var node = parent.node,
						grandparent = getEffective(parent.parent);
					var inherited = {
						dir: node.getAttribute("dir") || grandparent.dir,
						lang: node.getAttribute("lang") || grandparent.lang,
						textDir: node.getAttribute(dataDojoTextDir) || grandparent.textDir
					};
					for(var key in inherited){
						if(inherited[key]){
							parent.inherited[key] = inherited[key];
						}
					}
				}
				return parent.inherited;
			}

			// DFS on DOM tree, collecting nodes with data-dojo-type specified.
			while(true){
				if(!node){
					// Finished this level, continue to parent's next sibling
					if(!parent || !parent.node){
						break;
					}
					node = parent.node.nextSibling;
					scriptsOnly = false;
					parent = parent.parent;
					scripts = parent.scripts;
					continue;
				}

				if(node.nodeType != 1){
					// Text or comment node, skip to next sibling
					node = node.nextSibling;
					continue;
				}

				if(scripts && node.nodeName.toLowerCase() == "script"){
					// Save <script type="dojo/..."> for parent, then continue to next sibling
					type = node.getAttribute("type");
					if(type && /^dojo\/\w/i.test(type)){
						scripts.push(node);
					}
					node = node.nextSibling;
					continue;
				}
				if(scriptsOnly){
					// scriptsOnly flag is set, we have already collected scripts if the parent wants them, so now we shouldn't
					// continue further analysis of the node and will continue to the next sibling
					node = node.nextSibling;
					continue;
				}

				// Check for data-dojo-type attribute, fallback to backward compatible dojoType
				// TODO: Remove dojoType in 2.0
				var type = node.getAttribute(dataDojoType) || node.getAttribute(dojoType);

				// Short circuit for leaf nodes containing nothing [but text]
				var firstChild = node.firstChild;
				if(!type && (!firstChild || (firstChild.nodeType == 3 && !firstChild.nextSibling))){
					node = node.nextSibling;
					continue;
				}

				// Meta data about current node
				var current;

				var ctor = null;
				if(type){
					// If dojoType/data-dojo-type specified, add to output array of nodes to instantiate.
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					// Note: won't find classes declared via dojo/Declaration or any modules that haven't been
					// loaded yet so use try/catch to avoid throw from require()
					try{
						ctor = getCtor(types, options.contextRequire);
					}catch(e){}

					// If the constructor was not found, check to see if it has modules that can be loaded
					if(!ctor){
						darray.forEach(types, function(t){
							if(~t.indexOf('/') && !midsHash[t]){
								// If the type looks like a MID and it currently isn't in the array of MIDs to load, add it.
								midsHash[t] = true;
								mids[mids.length] = t;
							}
						});
					}

					var childScripts = ctor && !ctor.prototype._noScript ? [] : null; // <script> nodes that are parent's children

					// Setup meta data about this widget node, and save it to list of nodes to instantiate
					current = {
						types: types,
						ctor: ctor,
						parent: parent,
						node: node,
						scripts: childScripts
					};
					current.inherited = getEffective(current); // dir & lang settings for current node, explicit or inherited
					list.push(current);
				}else{
					// Meta data about this non-widget node
					current = {
						node: node,
						scripts: scripts,
						parent: parent
					};
				}

				// Recurse, collecting <script type="dojo/..."> children, and also looking for
				// descendant nodes with dojoType specified (unless the widget has the stopParser flag).
				// When finished with children, go to my next sibling.
				scripts = childScripts;
				scriptsOnly = node.stopParser || (ctor && ctor.prototype.stopParser && !(options.template));
				parent = current;
				node = firstChild;
			}

			var d = new Deferred();

			// If there are modules to load then require them in
			if(mids.length){
				// Warn that there are modules being auto-required
				if(has("dojo-debug-messages")){
					console.warn("WARNING: Modules being Auto-Required: " + mids.join(", "));
				}
				var r = options.contextRequire || require;
				r(mids, function(){
					// Go through list of widget nodes, filling in missing constructors, and filtering out nodes that shouldn't
					// be instantiated due to a stopParser flag on an ancestor that we belatedly learned about due to
					// auto-require of a module like ContentPane.   Assumes list is in DFS order.
					d.resolve(darray.filter(list, function(widget){
						if(!widget.ctor){
							// Attempt to find the constructor again.   Still won't find classes defined via
							// dijit/Declaration so need to try/catch.
							try{
								widget.ctor = getCtor(widget.types, options.contextRequire);
							}catch(e){}
						}

						// Get the parent widget
						var parent = widget.parent;
						while(parent && !parent.types){
							parent = parent.parent;
						}

						// Return false if this node should be skipped due to stopParser on an ancestor.
						// Since list[] is in DFS order, this loop will always set parent.instantiateChildren before
						// trying to compute widget.instantiate.
						var proto = widget.ctor && widget.ctor.prototype;
						widget.instantiateChildren = !(proto && proto.stopParser && !(options.template));
						widget.instantiate = !parent || (parent.instantiate && parent.instantiateChildren);
						return widget.instantiate;
					}));
				});
			}else{
				// There were no modules to load, so just resolve with the parsed nodes.   This separate code path is for
				// efficiency, to avoid running the require() and the callback code above.
				d.resolve(list);
			}

			// Return the promise
			return d.promise;
		},

		_require: function(/*DOMNode*/ script, /*Object?*/ options){
			// summary:
			//		Helper for _scanAMD().  Takes a `<script type=dojo/require>bar: "acme/bar", ...</script>` node,
			//		calls require() to load the specified modules and (asynchronously) assign them to the specified global
			//		variables, and returns a Promise for when that operation completes.
			//
			//		In the example above, it is effectively doing a require(["acme/bar", ...], function(a){ bar = a; }).

			var hash = myEval("{" + script.innerHTML + "}"), // can't use dojo/json::parse() because maybe no quotes
				vars = [],
				mids = [],
				d = new Deferred();

			var contextRequire = (options && options.contextRequire) || require;

			for(var name in hash){
				vars.push(name);
				mids.push(hash[name]);
			}

			contextRequire(mids, function(){
				for(var i = 0; i < vars.length; i++){
					dlang.setObject(vars[i], arguments[i]);
				}
				d.resolve(arguments);
			});

			return d.promise;
		},

		_scanAmd: function(root, options){
			// summary:
			//		Scans the DOM for any declarative requires and returns their values.
			// description:
			//		Looks for `<script type=dojo/require>bar: "acme/bar", ...</script>` node, calls require() to load the
			//		specified modules and (asynchronously) assign them to the specified global variables,
			//		and returns a Promise for when those operations complete.
			// root: DomNode
			//		The node to base the scan from.
			// options: Object?
			//		a kwArgs options object, see parse() for details

			// Promise that resolves when all the <script type=dojo/require> nodes have finished loading.
			var deferred = new Deferred(),
				promise = deferred.promise;
			deferred.resolve(true);

			var self = this;
			query("script[type='dojo/require']", root).forEach(function(node){
				// Fire off require() call for specified modules.  Chain this require to fire after
				// any previous requires complete, so that layers can be loaded before individual module require()'s fire.
				promise = promise.then(function(){
					return self._require(node, options);
				});

				// Remove from DOM so it isn't seen again
				node.parentNode.removeChild(node);
			});

			return promise;
		},

		parse: function(rootNode, options){
			// summary:
			//		Scan the DOM for class instances, and instantiate them.
			// description:
			//		Search specified node (or root node) recursively for class instances,
			//		and instantiate them. Searches for either data-dojo-type="Class" or
			//		dojoType="Class" where "Class" is a a fully qualified class name,
			//		like `dijit/form/Button`
			//
			//		Using `data-dojo-type`:
			//		Attributes using can be mixed into the parameters used to instantiate the
			//		Class by using a `data-dojo-props` attribute on the node being converted.
			//		`data-dojo-props` should be a string attribute to be converted from JSON.
			//
			//		Using `dojoType`:
			//		Attributes are read from the original domNode and converted to appropriate
			//		types by looking up the Class prototype values. This is the default behavior
			//		from Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will
			//		go away in Dojo 2.0.
			// rootNode: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object?
			//		A hash of options.
			//
			//		- noStart: Boolean?:
			//			when set will prevent the parser from calling .startup()
			//			when locating the nodes.
			//		- rootNode: DomNode?:
			//			identical to the function's `rootNode` argument, though
			//			allowed to be passed in via this `options object.
			//		- template: Boolean:
			//			If true, ignores ContentPane's stopParser flag and parses contents inside of
			//			a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
			//			nested inside the ContentPane to work.
			//		- inherited: Object:
			//			Hash possibly containing dir and lang settings to be applied to
			//			parsed widgets, unless there's another setting on a sub-node that overrides
			//		- scope: String:
			//			Root for attribute names to search for.   If scopeName is dojo,
			//			will search for data-dojo-type (or dojoType).   For backwards compatibility
			//			reasons defaults to dojo._scopeName (which is "dojo" except when
			//			multi-version support is used, when it will be something like dojo16, dojo20, etc.)
			//		- propsThis: Object:
			//			If specified, "this" referenced from data-dojo-props will refer to propsThis.
			//			Intended for use from the widgets-in-template feature of `dijit._WidgetsInTemplateMixin`
			//		- contextRequire: Function:
			//			If specified, this require is utilised for looking resolving modules instead of the
			//			`dojo/parser` context `require()`.  Intended for use from the widgets-in-template feature of
			//			`dijit._WidgetsInTemplateMixin`.
			// returns: Mixed
			//		Returns a blended object that is an array of the instantiated objects, but also can include
			//		a promise that is resolved with the instantiated objects.  This is done for backwards
			//		compatibility.  If the parser auto-requires modules, it will always behave in a promise
			//		fashion and `parser.parse().then(function(instances){...})` should be used.
			// example:
			//		Parse all widgets on a page:
			//	|		parser.parse();
			// example:
			//		Parse all classes within the node with id="foo"
			//	|		parser.parse(dojo.byId('foo'));
			// example:
			//		Parse all classes in a page, but do not call .startup() on any
			//		child
			//	|		parser.parse({ noStart: true })
			// example:
			//		Parse all classes in a node, but do not call .startup()
			//	|		parser.parse(someNode, { noStart:true });
			//	|		// or
			//	|		parser.parse({ noStart:true, rootNode: someNode });

			// determine the root node and options based on the passed arguments.
			if(rootNode && typeof rootNode != "string" && !("nodeType" in rootNode)){
				// If called as parse(options) rather than parse(), parse(rootNode), or parse(rootNode, options)...
				options = rootNode;
				rootNode = options.rootNode;
			}
			var root = rootNode ? dom.byId(rootNode) : dwindow.body();
			options = options || {};

			var mixin = options.template ? { template: true } : {},
				instances = [],
				self = this;

			// First scan for any <script type=dojo/require> nodes, and execute.
			// Then scan for all nodes with data-dojo-type, and load any unloaded modules.
			// Then build the object instances.  Add instances to already existing (but empty) instances[] array,
			// which may already have been returned to caller.  Also, use otherwise to collect and throw any errors
			// that occur during the parse().
			var p =
				this._scanAmd(root, options).then(function(){
					return self.scan(root, options);
				}).then(function(parsedNodes){
					return self._instantiate(parsedNodes, mixin, options, true);
				}).then(function(_instances){
					// Copy the instances into the instances[] array we declared above, and are accessing as
					// our return value.
					return instances = instances.concat(_instances);
				}).otherwise(function(e){
					// TODO Modify to follow better pattern for promise error management when available
					console.error("dojo/parser::parse() error", e);
					throw e;
				});

			// Blend the array with the promise
			dlang.mixin(instances, p);
			return instances;
		}
	};

	if( 1 ){
		dojo.parser = parser;
	}

	// Register the parser callback. It should be the first callback
	// after the a11y test.
	if(config.parseOnLoad){
		ready(100, parser, "parse");
	}

	return parser;
});

},
'dijit/form/ToggleButton':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"./Button",
	"./_ToggleButtonMixin"
], function(declare, kernel, Button, _ToggleButtonMixin){

	// module:
	//		dijit/form/ToggleButton


	return declare("dijit.form.ToggleButton", [Button, _ToggleButtonMixin], {
		// summary:
		//		A templated button widget that can be in two states (checked or not).
		//		Can be base class for things like tabs or checkbox or radio buttons.

		baseClass: "dijitToggleButton",

		setChecked: function(/*Boolean*/ checked){
			// summary:
			//		Deprecated.  Use set('checked', true/false) instead.
			kernel.deprecated("setChecked("+checked+") is deprecated. Use set('checked',"+checked+") instead.", "", "2.0");
			this.set('checked', checked);
		}
	});
});

},
'dojo/date/stamp':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["../_base/lang", "../_base/array"], function(lang, array){

// module:
//		dojo/date/stamp

var stamp = {
	// summary:
	//		TODOC
};
lang.setObject("dojo.date.stamp", stamp);

// Methods to convert dates to or from a wire (string) format using well-known conventions

stamp.fromISOString = function(/*String*/ formattedString, /*Number?*/ defaultTime){
	// summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	// description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//		- dates only
	//			- yyyy
	//			- yyyy-MM
	//			- yyyy-MM-dd
	//		- times only, with an optional time zone appended
	//			- THH:mm
	//			- THH:mm:ss
	//			- THH:mm:ss.SSS
	//		- and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	//		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
  	// formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	// defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!stamp._isoRegExp){
		stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = stamp._isoRegExp.exec(formattedString),
		result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			array.forEach(array.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}), function(value, index){
				match[index] = match[index] || value;
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
		if(match[0] < 100){
			result.setFullYear(match[0] || 1970);
		}

		var offset = 0,
			zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
};

/*=====
var __Options = {
	// selector: String
	//		"date" or "time" for partial formatting of the Date object.
	//		Both date and time will be formatted by default.
	// zulu: Boolean
	//		if true, UTC/GMT is used for a timezone
	// milliseconds: Boolean
	//		if true, output milliseconds
};
=====*/

stamp.toISOString = function(/*Date*/ dateObject, /*__Options?*/ options){
	// summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	// description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	// dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [],
		getter = options.zulu ? "getUTC" : "get",
		date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") +
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
};

return stamp;
});

},
'ibm/tivoli/fwm/mxmap/impl/marker/BingMarker':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Marker"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

dojo.require("ibm.tivoli.fwm.mxmap._Marker");
dojo.provide("ibm.tivoli.fwm.mxmap.impl.marker.BingMarker");

/**
 * Marker
 */
dojo.declare("ibm.tivoli.fwm.mxmap.impl.marker.BingMarker", ibm.tivoli.fwm.mxmap._Marker, {
	
	/**
	 * Returns a new proprietary instance of Microsoft.Maps.Pushpin object.
	 */
	toProprietary: function()
	{
		var pin;
		var map = this.map;
		
		var pinOptions = {
			draggable: this.draggable,
			visible: true
		};
		if (this.labelText != null && this.labelText.length > 0)
		{
			pinOptions.text = this.labelText;
			pinOptions.textOffset = new Microsoft.Maps.Point(2, 6);
		}
	
		if (this.iconUrl)
		{
			pinOptions.icon = this.iconUrl;
		}
		if (this.iconSize)
		{
			pinOptions.height = this.iconSize[1] + "px";
			pinOptions.width = this.iconSize[0] + "px";
		}
	
		if (this.iconAnchor)
		{				
			pinOptions.anchor = new Microsoft.Maps.Point(this.iconAnchor[0] - 2, this.iconAnchor[1] - 2);
		}
		pin = new Microsoft.Maps.Pushpin(this.location.toProprietary(), pinOptions);
		
		var me = this;
	
		Microsoft.Maps.Events.addHandler(pin, "mouseout", function()
		{
			pin.mxmapMarker.dragging = false;
		});
	
		var rootElement = map.getRootElement();
		if (this.infoBubble)
		{
			// Passing in the marker as well so that, when the infoIndow is closed,
			// it will be possible to detect which marker generated this event
			var infoWindow = new ibm.tivoli.fwm.mxmap.InfoWindow({
				map: map,
				mapId: me.compId,
				rootElement: rootElement,
				marker: me,
				isMobile: this.isMobile
			});
			this.proprietary_infowindow = infoWindow;
	
			Microsoft.Maps.Events.addHandler(pin, "click", function(e)
			{
				dojo.publish("onMarkerClicked_" + me.compId, [ {
					marker: pin.mxmapMarker
				} ]);
				// 12-10255
				if (pin.mxmapMarker.dragging == true)
				{
					return;
				}
				pin.mxmapMarker.openBubble(e);
			});
		}
		if (this.draggable == true)
		{
			var m = this;
			Microsoft.Maps.Events.addHandler(pin, "dragstart", function()
			{
				// Passing in the marker (not the proprietaty one) as objectSource
				// Defect 66864: The map id was wrong, it was undefined and the marker auto refresh was broken.
				// This happened during mapstraction removal
				dojo.publish("startedUserInteractionOnMap_" + me.compId, [ {
					objectSource: me,
					objectSourceName: 'microsoftv8',
					eventName: 'dragstart'
				} ]);
				
				// Looks like the event below is not handled anywhere
				//var latLng = this.map.latLng(pin.getLocation().latitude, pin.getLocation().longitude);
				//me.fireMarkerEvent(me.MarkerEvents.dragstart, latLng)
				pin.mxmapMarker.hideTooltip();
	
			});
			Microsoft.Maps.Events.addHandler(pin, "drag", function()
			{
				// Looks like the event below is not handled anywhere
				//var latLng = this.map.latLng(pin.getLocation().latitude, pin.getLocation().longitude);
				//me.fireMarkerEvent(me.MarkerEvents.drag, latLng)
				pin.mxmapMarker.dragging = true;
			});
			Microsoft.Maps.Events.addHandler(pin, "dragend", function()
			{
				if (pin.mxmapMarker.dragging != true)
				{
					return;
				}
	
			
				me.fireMarkerEvent(me.MarkerEvents.dragend, {
					marker: me,
					newLocation: {
						lng: pin.getLocation().longitude,
						lat: pin.getLocation().latitude
					}
				});

				// Passing in the marker (not the proprietaty one) as objectSource
				// Defect 66864: The map id was wrong, it was undefined and the marker auto refresh was broken.
				// This happened during mapstraction removal
				dojo.publish("endedUserInteractionOnMap_" + me.compId, [ {
					objectSource: me,
					objectSourceName: 'microsoftv8',
					eventName: 'dragend'
				} ]);
			});
		}
		if (this.tooltip && this.tooltip.length > 0)
		{
	
			Microsoft.Maps.Events.addHandler(pin, "mouseover", function()
			{
				var screenPoint = map.tryLocationToPixel(pin.getLocation(), Microsoft.Maps.PixelReference.control);
	
				pin.mxmapMarker.showTooltip(screenPoint, map.getRootElement());
	
			});
			Microsoft.Maps.Events.addHandler(pin, "mouseout", function()
			{
				pin.mxmapMarker.hideTooltip();
	
			});
	
		}
		if (this.hoverIconUrl)
		{
			Microsoft.Maps.Events.addHandler(pin, "mouseover", function()
			{
				pinOptions.icon = hIcon;
				pin.setOptions(pinOptions);
			});
			Microsoft.Maps.Events.addHandler(pin, "mouseout", function()
			{
				pinOptions.icon = hIcon;
				pin.setOptions(pinOptions);
	
			});
	
		}
		map.entities.push(pin);
		return pin;
	},

	/**
	 * Shows the marker's bubble (Microsoft.Maps.Infobox).
	 */
	openBubble: function()
	{
		// Defect 99060: Adding this condition so that markers that have been removed
		// from the map cannot have a maptip showing.
		if(this.onmap == true)
		{
			var me = this;
			// Passing in the marker (not the proprietaty one) as objectSource
			// Defect 66864: The map id was wrong, it was undefined and the marker auto refresh was broken.
			// This happened during mapstraction removal
			dojo.publish("startedUserInteractionOnMap_" + me.compId, [ {
				objectSource: me,
				objectSourceName: 'microsoftv8',
				eventName: 'openBubble'
			} ]);

			this.hideTooltip();
			var infowindow = this.proprietary_infowindow;

			var loc = this.proprietary_marker.getLocation();

			var pinPixel = this.map.tryLocationToPixel(loc, Microsoft.Maps.PixelReference.control);

			this.proprietary_infowindow.setContent(this.infoBubble);
			// Defect 67260 - Moves the main dialog up so that that the infoWindow can be closed
			// even when child dialogs are showing
			if(this.hasReferencedMarkers() == true)
			{
				this.proprietary_infowindow.moveUp();
			}
			this.proprietary_infowindow.show(pinPixel.x, pinPixel.y);
			var marker = this;
			var map = this.map;

			Microsoft.Maps.Events.addHandler(map, 'viewchange', function(e)
			{
				var pinPixel = marker.map.tryLocationToPixel(marker.proprietary_marker.getLocation(), Microsoft.Maps.PixelReference.control);
				infowindow.updatePosition(pinPixel.x, pinPixel.y);
			});

			this.fireMarkerEvent(this.MarkerEvents.openInfoBubble,{
				'marker': this
			});
			
			
			// Defect 88220: Whenever the maptip opens, center the map around the marker.
			// Note: The logic that automatically closes the maptip when it hits the map edges has been commented out
			// as it was affecting this logic that recenters the map.
			var options = {
				zoom: map.getZoom(),
				center: loc
			};
			map.setView(options);

			
			this.inherited(arguments);
		}
	},

	/**
	 * Hide the marker's bubble (Microsoft.Maps.Infobox).
	 */
	closeBubble: function()
	{
		if (this.hasOwnProperty('proprietary_infowindow'))
		{
			this.proprietary_infowindow.close();
			this.fireMarkerEvent(this.MarkerEvents.closeInfoBubble,{
				'marker': this
			});
		}
		this.inherited(arguments);
	},

	/**
	 * Hide the marker (Microsoft.Maps.Pushpin).
	 */
	hide: function()
	{
		var pin = this.proprietary_marker;
		pin.setOptions({
			visible: false
		});
		this.hideTooltip();
	},

	/**
	 * Shows the marker (Microsoft.Maps.Pushpin).
	 */
	show: function()
	{
		var pin = this.proprietary_marker;
		pin.setOptions({
			visible: true
		});
	}

	
});

});

},
'dojo/Stateful':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["./_base/declare", "./_base/lang", "./_base/array", "./when"], function(declare, lang, array, when){
	// module:
	//		dojo/Stateful

return declare("dojo.Stateful", null, {
	// summary:
	//		Base class for objects that provide named properties with optional getter/setter
	//		control and the ability to watch for property changes
	//
	//		The class also provides the functionality to auto-magically manage getters
	//		and setters for object attributes/properties.
	//		
	//		Getters and Setters should follow the format of _xxxGetter or _xxxSetter where 
	//		the xxx is a name of the attribute to handle.  So an attribute of "foo" 
	//		would have a custom getter of _fooGetter and a custom setter of _fooSetter.
	//
	// example:
	//	|	require(["dojo/Stateful", function(Stateful) {
	//	|		var obj = new Stateful();
	//	|		obj.watch("foo", function(){
	//	|			console.log("foo changed to " + this.get("foo"));
	//	|		});
	//	|		obj.set("foo","bar");
	//	|	});

	// _attrPairNames: Hash
	//		Used across all instances a hash to cache attribute names and their getter 
	//		and setter names.
	_attrPairNames: {},

	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		return (apn[name] = {
			s: "_" + name + "Setter",
			g: "_" + name + "Getter"
		});
	},

	postscript: function(/*Object?*/ params){
		// Automatic setting of params during construction
		if (params){ this.set(params); }
	},

	_get: function(name, names){
		// summary:
		//		Private function that does a get based off a hash of names
		// names:
		//		Hash of names of custom attributes
		return typeof this[names.g] === "function" ? this[names.g]() : this[name];
	},
	get: function(/*String*/name){
		// summary:
		//		Get a property on a Stateful instance.
		// name:
		//		The property to get.
		// returns:
		//		The property value on this Stateful instance.
		// description:
		//		Get a named property on a Stateful object. The property may
		//		potentially be retrieved via a getter method in subclasses. In the base class
		//		this just retrieves the object's property.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful({foo: 3});
		//	|		stateful.get("foo") // returns 3
		//	|		stateful.foo // returns 3
		//	|	});

		return this._get(name, this._getAttrNames(name)); //Any
	},
	set: function(/*String*/name, /*Object*/value){
		// summary:
		//		Set a property on a Stateful instance
		// name:
		//		The property to set.
		// value:
		//		The value to set in the property.
		// returns:
		//		The function returns this dojo.Stateful instance.
		// description:
		//		Sets named properties on a stateful object and notifies any watchers of
		//		the property. A programmatic setter may be defined in subclasses.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful();
		//	|		stateful.watch(function(name, oldValue, value){
		//	|			// this will be called on the set below
		//	|		}
		//	|		stateful.set(foo, 5);
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|		stateful.set({
		//	|			foo: "Howdy",
		//	|			bar: 3
		//	|		});
		//	|	});
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)

		// If an object is used, iterate through object
		if(typeof name === "object"){
			for(var x in name){
				if(name.hasOwnProperty(x) && x !="_watchCallbacks"){
					this.set(x, name[x]);
				}
			}
			return this;
		}

		var names = this._getAttrNames(name),
			oldValue = this._get(name, names),
			setter = this[names.s],
			result;
		if(typeof setter === "function"){
			// use the explicit setter
			result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			// no setter so set attribute directly
			this[name] = value;
		}
		if(this._watchCallbacks){
			var self = this;
			// If setter returned a promise, wait for it to complete, otherwise call watches immediately
			when(result, function(){
				self._watchCallbacks(name, oldValue, value);
			});
		}
		return this; // dojo/Stateful
	},
	_changeAttrValue: function(name, value){
		// summary:
		//		Internal helper for directly changing an attribute value.
		//
		// name: String
		//		The property to set.
		// value: Mixed
		//		The value to set in the property.
		//
		// description:
		//		Directly change the value of an attribute on an object, bypassing any 
		//		accessor setter.  Also handles the calling of watch and emitting events. 
		//		It is designed to be used by descendant class when there are two values 
		//		of attributes that are linked, but calling .set() is not appropriate.

		var oldValue = this.get(name);
		this[name] = value;
		if(this._watchCallbacks){
			this._watchCallbacks(name, oldValue, value);
		}
		return this; // dojo/Stateful
	},
	watch: function(/*String?*/name, /*Function*/callback){
		// summary:
		//		Watches a property for changes
		// name:
		//		Indicates the property to watch. This is optional (the callback may be the
		//		only parameter), and if omitted, all the properties will be watched
		// returns:
		//		An object handle for the watch. The unwatch method of this object
		//		can be used to discontinue watching this property:
		//		|	var watchHandle = obj.watch("foo", callback);
		//		|	watchHandle.unwatch(); // callback won't be called now
		// callback:
		//		The function to execute when the property changes. This will be called after
		//		the property has been changed. The callback will be called with the |this|
		//		set to the instance, the first argument as the name of the property, the
		//		second argument as the old value and the third argument as the new value.

		var callbacks = this._watchCallbacks;
		if(!callbacks){
			var self = this;
			callbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){
				var notify = function(propertyCallbacks){
					if(propertyCallbacks){
						propertyCallbacks = propertyCallbacks.slice();
						for(var i = 0, l = propertyCallbacks.length; i < l; i++){
							propertyCallbacks[i].call(self, name, oldValue, value);
						}
					}
				};
				notify(callbacks['_' + name]);
				if(!ignoreCatchall){
					notify(callbacks["*"]); // the catch-all
				}
			}; // we use a function instead of an object so it will be ignored by JSON conversion
		}
		if(!callback && typeof name === "function"){
			callback = name;
			name = "*";
		}else{
			// prepend with dash to prevent name conflicts with function (like "name" property)
			name = '_' + name;
		}
		var propertyCallbacks = callbacks[name];
		if(typeof propertyCallbacks !== "object"){
			propertyCallbacks = callbacks[name] = [];
		}
		propertyCallbacks.push(callback);

		// TODO: Remove unwatch in 2.0
		var handle = {};
		handle.unwatch = handle.remove = function(){
			var index = array.indexOf(propertyCallbacks, callback);
			if(index > -1){
				propertyCallbacks.splice(index, 1);
			}
		};
		return handle; //Object
	}

});

});

},
'dijit/form/ComboButton':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/keys", // keys
	"../focus", // focus.focus()
	"./DropDownButton",
	"dojo/text!./templates/ComboButton.html",
	"../a11yclick"	// template uses ondijitclick
], function(declare, keys, focus, DropDownButton, template){

	// module:
	//		dijit/form/ComboButton

	return declare("dijit.form.ComboButton", DropDownButton, {
		// summary:
		//		A combination button and drop-down button.
		//		Users can click one side to "press" the button, or click an arrow
		//		icon to display the drop down.
		//
		// example:
		// |	<button data-dojo-type="dijit/form/ComboButton" onClick="...">
		// |		<span>Hello world</span>
		// |		<div data-dojo-type="dijit/Menu">...</div>
		// |	</button>
		//
		// example:
		// |	var button1 = new ComboButton({label: "hello world", onClick: foo, dropDown: "myMenu"});
		// |	dojo.body().appendChild(button1.domNode);
		//

		templateString: template,

		// Map widget attributes to DOMNode attributes.
		_setIdAttr: "", // override _FormWidgetMixin which puts id on the focusNode
		_setTabIndexAttr: ["focusNode", "titleNode"],
		_setTitleAttr: "titleNode",

		// optionsTitle: String
		//		Text that describes the options menu (accessibility)
		optionsTitle: "",

		baseClass: "dijitComboButton",

		// Set classes like dijitButtonContentsHover or dijitArrowButtonActive depending on
		// mouse action over specified node
		cssStateNodes: {
			"buttonNode": "dijitButtonNode",
			"titleNode": "dijitButtonContents",
			"_popupStateNode": "dijitDownArrowButton"
		},

		_focusedNode: null,

		_onButtonKeyDown: function(/*Event*/ evt){
			// summary:
			//		Handler for right arrow key when focus is on left part of button
			if(evt.keyCode == keys[this.isLeftToRight() ? "RIGHT_ARROW" : "LEFT_ARROW"]){
				focus.focus(this._popupStateNode);
				evt.stopPropagation();
				evt.preventDefault();
			}
		},

		_onArrowKeyDown: function(/*Event*/ evt){
			// summary:
			//		Handler for left arrow key when focus is on right part of button
			if(evt.keyCode == keys[this.isLeftToRight() ? "LEFT_ARROW" : "RIGHT_ARROW"]){
				focus.focus(this.titleNode);
				evt.stopPropagation();
				evt.preventDefault();
			}
		},

		focus: function(/*String*/ position){
			// summary:
			//		Focuses this widget to according to position, if specified,
			//		otherwise on arrow node
			// position:
			//		"start" or "end"
			if(!this.disabled){
				focus.focus(position == "start" ? this.titleNode : this._popupStateNode);
			}
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/helpers/MapMarkersRefresher':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */



/**
 * This class is used to perform the refresh of the markers on the map. The time
 * interval defined in the application designer for the map is informed in
 * seconds. Zero and negative values are ignored and the marker is not started.
 *
 * To avoid refresh a map and create problems to an eventually user interaction
 * in the moment of the refresh, this class listens to the events
 * <code>startedUserInteractionOnMap</code> and
 * <code>endedUserInteractionOnMap</code>.
 *
 * Both events, when published, SHOULD pass along the following object: {
 * objectSource: anObject, // json object [optional] objectSourceName:
 * "myObjectName", // string [required] eventName: "userInteractionEvent" //
 * string [required] }
 *
 */
define(["dojo/_base/declare",
	"dojox/timing/_base",
	"ibm/tivoli/fwm/mxmap/_Base"],
	 function(declare, _dijitBase, _Base ) {
		return declare([_Base], {
			maximo: null,
			interval: 0, // seconds
			_timer: null,
			_signalCounter: 0,
			map: null,
			constructor: function(options)
			{
				dojo.mixin(this, options);
				dojo.require('dojox.timing');
				this.addSubscription("startedUserInteractionOnMap_" + this.map.getId(), dojo.hitch(this, this.disableMapRefresh));
				this.addSubscription("endedUserInteractionOnMap_" + this.map.getId(), dojo.hitch(this, this.checkToEnableMapRefresh));
				this._signalCounter = 0;
			},
			start: function()
			{
				if (this._timer == null)
				{
					if (this.interval > 0)
					{

						console.log("[MapMarkersRefresher] Starting timer with interval " + this.interval);

						this._doStart();
					}
					else
					{

						console.log("[MapMarkersRefresher] Interal must be greater than zero -- Start ignored.");

					}
				}
				else
				{

					console.log("[MapMarkersRefresher] Timer already started. Ignoring start");

				}
			},
			disableMapRefresh: function(e)
			{

				console.log("[MapMarkersRefresher] Received startedUserInteraction - Refreshed Disabled", e);

				this._signalCounter = this._signalCounter + 1;
			},
			checkToEnableMapRefresh: function(e)
			{

				console.log("[MapMarkersRefresher] Received endedUserInteraction", e);

				this._signalCounter = this._signalCounter - 1;
				// we could receive more events than expecting
				// no reason to not use a counter at the implementation time
				// as it is the responsibility of the map implementation to 'say' when
				// we can refresh or not
				if (this._signalCounter <= 0)
				{
					console.log("[MapMarkersRefresher] Map Refresh Enabled");
					this._signalCounter = 0;
				}
			},
			stop: function()
			{
				if (this._timer == null)
				{
					console.log("[MapMarkersRefresher] Timer not started. Ignoring stop");
				}
				else
				{
					console.log("[MapMarkersRefresher] Stopping timer");
					this._timer.stop();
					this._timer = null;
				}
			},
			_doStart: function()
			{
				var that = this;
				this._timer = new dojox.timing.Timer(this.interval * 1000);
				this._timer.onTick = function()
				{
					if (that._signalCounter == 0)
					{
						console.log("[MapMarkersRefresher] Refreshing markers positions");
						
						that.map.autoRefreshMap();
					}
					else
					{
						console.log("[MapMarkersRefresher] Refresh disabled at this time. Counter: " + that._signalCounter);
					}
				};
				this._timer.onStart = function()
				{
					console.log("[MapMarkersRefresher] Started timer to refresh map markers");
				};
				this._timer.onStop = function()
				{
					console.log("[MapMarkersRefresher] Stopped timer to refresh map markers");
				};
				this._timer.start();
			},
			getMaximo: function()
			{
				return this.maximo;
			},
			destroyRecursive: function()
			{
				this.stop();
				this.inherited(arguments);
			}
	});
});


},
'dijit/form/_TextBoxMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/sniff",	// has("ie"), has("dojo-bidi")
	"dojo/keys", // keys.ALT keys.CAPS_LOCK keys.CTRL keys.META keys.SHIFT
	"dojo/_base/lang", // lang.mixin
	"dojo/on", // on
	"../main"    // for exporting dijit._setSelectionRange, dijit.selectInputText
], function(array, declare, dom, has, keys, lang, on, dijit){

	// module:
	//		dijit/form/_TextBoxMixin

	var _TextBoxMixin = declare("dijit.form._TextBoxMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
		// summary:
		//		A mixin for textbox form input widgets

		// trim: Boolean
		//		Removes leading and trailing whitespace if true.  Default is false.
		trim: false,

		// uppercase: Boolean
		//		Converts all characters to uppercase if true.  Default is false.
		uppercase: false,

		// lowercase: Boolean
		//		Converts all characters to lowercase if true.  Default is false.
		lowercase: false,

		// propercase: Boolean
		//		Converts the first character of each word to uppercase if true.
		propercase: false,

		// maxLength: String
		//		HTML INPUT tag maxLength declaration.
		maxLength: "",

		// selectOnClick: [const] Boolean
		//		If true, all text will be selected when focused with mouse
		selectOnClick: false,

		// placeHolder: String
		//		Defines a hint to help users fill out the input field (as defined in HTML 5).
		//		This should only contain plain text (no html markup).
		placeHolder: "",

		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works as we like.
			// description:
			//		For `dijit/form/TextBox` this basically returns the value of the `<input>`.
			//
			//		For `dijit/form/MappedTextBox` subclasses, which have both
			//		a "displayed value" and a separate "submit value",
			//		This treats the "displayed value" as the master value, computing the
			//		submit value from it via this.parse().
			return this.parse(this.get('displayedValue'), this.constraints);
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so set('value', ...) works.
			//
			// description:
			//		Sets the value of the widget to "value" which can be of
			//		any type as determined by the widget.
			//
			// value:
			//		The visual element value is also set to a corresponding,
			//		but not necessarily the same, value.
			//
			// formattedValue:
			//		If specified, used to set the visual element value,
			//		otherwise a computed visual value is used.
			//
			// priorityChange:
			//		If true, an onChange event is fired immediately instead of
			//		waiting for the next blur event.

			var filteredValue;
			if(value !== undefined){
				// TODO: this is calling filter() on both the display value and the actual value.
				// I added a comment to the filter() definition about this, but it should be changed.
				filteredValue = this.filter(value);
				if(typeof formattedValue != "string"){
					if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
						formattedValue = this.filter(this.format(filteredValue, this.constraints));
					}else{
						formattedValue = '';
					}
					// Ensure the filtered value does not change after being formatted. See track #17955.
					//
					// This check is only applied when the formatted value is not specified by the caller in order to allow the 
					// behavior to be overriden. This is needed whenever value synonyms cannot be determined using parse/compare. For
					// example, dijit/form/FilteringSelect determines the formatted value asynchronously and applies it using a 
					// callback to this method.
					//
					// TODO: Should developers be warned that they broke the round trip on format?
					if (this.compare(filteredValue, this.filter(this.parse(formattedValue, this.constraints))) != 0){
						formattedValue = null;
					}
				}
			}
			if(formattedValue != null /* and !undefined */ && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
				this.textbox.value = formattedValue;
				this._set("displayedValue", this.get("displayedValue"));
			}

			this.inherited(arguments, [filteredValue, priorityChange]);
		},

		// displayedValue: String
		//		For subclasses like ComboBox where the displayed value
		//		(ex: Kentucky) and the serialized value (ex: KY) are different,
		//		this represents the displayed value.
		//
		//		Setting 'displayedValue' through set('displayedValue', ...)
		//		updates 'value', and vice-versa.  Otherwise 'value' is updated
		//		from 'displayedValue' periodically, like onBlur etc.
		//
		//		TODO: move declaration to MappedTextBox?
		//		Problem is that ComboBox references displayedValue,
		//		for benefit of FilteringSelect.
		displayedValue: "",

		_getDisplayedValueAttr: function(){
			// summary:
			//		Hook so get('displayedValue') works.
			// description:
			//		Returns the displayed value (what the user sees on the screen),
			//		after filtering (ie, trimming spaces etc.).
			//
			//		For some subclasses of TextBox (like ComboBox), the displayed value
			//		is different from the serialized value that's actually
			//		sent to the server (see `dijit/form/ValidationTextBox.serialize()`)

			// TODO: maybe we should update this.displayedValue on every keystroke so that we don't need
			// this method
			// TODO: this isn't really the displayed value when the user is typing
			return this.filter(this.textbox.value);
		},

		_setDisplayedValueAttr: function(/*String*/ value){
			// summary:
			//		Hook so set('displayedValue', ...) works.
			// description:
			//		Sets the value of the visual element to the string "value".
			//		The widget value is also set to a corresponding,
			//		but not necessarily the same, value.

			if(value == null /* or undefined */){
				value = ''
			}
			else if(typeof value != "string"){
				value = String(value)
			}

			this.textbox.value = value;

			// sets the serialized value to something corresponding to specified displayedValue
			// (if possible), and also updates the textbox.value, for example converting "123"
			// to "123.00"
			this._setValueAttr(this.get('value'), undefined);

			this._set("displayedValue", this.get('displayedValue'));
		},

		format: function(value /*=====, constraints =====*/){
			// summary:
			//		Replaceable function to convert a value to a properly formatted string.
			// value: String
			// constraints: Object
			// tags:
			//		protected extension
			return value == null /* or undefined */ ? "" : (value.toString ? value.toString() : value);
		},

		parse: function(value /*=====, constraints =====*/){
			// summary:
			//		Replaceable function to convert a formatted string to a value
			// value: String
			// constraints: Object
			// tags:
			//		protected extension

			return value;	// String
		},

		_refreshState: function(){
			// summary:
			//		After the user types some characters, etc., this method is
			//		called to check the field for validity etc.  The base method
			//		in `dijit/form/TextBox` does nothing, but subclasses override.
			// tags:
			//		protected
		},

		 onInput: function(/*Event*/ /*===== evt =====*/){
			 // summary:
			 //		Connect to this function to receive notifications of various user data-input events.
			 //		Return false to cancel the event and prevent it from being processed.
			 //		Note that although for historical reasons this method is called `onInput()`, it doesn't
			 //		correspond to the standard DOM "input" event, because it occurs before the input has been processed.
			 // event:
			 //		keydown | keypress | cut | paste | compositionend
			 // tags:
			 //		callback
		 },

		_onInput: function(/*Event*/ evt){
			// summary:
			//		Called AFTER the input event has happened and this.textbox.value has new value.

			this._lastInputEventValue = this.textbox.value;

			// For Combobox, this needs to be called w/the keydown/keypress event that was passed to onInput().
			// As a backup, use the "input" event itself.
			this._processInput(this._lastInputProducingEvent || evt);
			delete this._lastInputProducingEvent;

			if(this.intermediateChanges){
				this._handleOnChange(this.get('value'), false);
			}
		},

		_processInput: function(/*Event*/ /*===== evt =====*/){
			// summary:
			//		Default action handler for user input events.
			//		Called after the "input" event (i.e. after this.textbox.value has been updated),
			//		but `evt` is the keydown/keypress/etc. event that triggered the "input" event.
			// tags:
			//		protected

			this._refreshState();

			// In case someone is watch()'ing for changes to displayedValue
			this._set("displayedValue", this.get("displayedValue"));
		},

		postCreate: function(){
			// setting the value here is needed since value="" in the template causes "undefined"
			// and setting in the DOM (instead of the JS object) helps with form reset actions
			this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values should be the same

			this.inherited(arguments);

			// normalize input events to reduce spurious event processing
			//	keydown: do not forward modifier keys
			//		       set charOrCode to numeric keycode
			//	keypress: do not forward numeric charOrCode keys (already sent through onkeydown)
			//	paste, cut, compositionend: set charOrCode to 229 (IME)
			function handleEvent(e){
				var charOrCode;

				// Filter out keydown events that will be followed by keypress events.  Note that chrome/android
				// w/word suggestion has keydown/229 events on typing with no corresponding keypress events.
				if(e.type == "keydown" && e.keyCode != 229){
					charOrCode = e.keyCode;
					switch(charOrCode){ // ignore state keys
						case keys.SHIFT:
						case keys.ALT:
						case keys.CTRL:
						case keys.META:
						case keys.CAPS_LOCK:
						case keys.NUM_LOCK:
						case keys.SCROLL_LOCK:
							return;
					}
					if(!e.ctrlKey && !e.metaKey && !e.altKey){ // no modifiers
						switch(charOrCode){ // ignore location keys
							case keys.NUMPAD_0:
							case keys.NUMPAD_1:
							case keys.NUMPAD_2:
							case keys.NUMPAD_3:
							case keys.NUMPAD_4:
							case keys.NUMPAD_5:
							case keys.NUMPAD_6:
							case keys.NUMPAD_7:
							case keys.NUMPAD_8:
							case keys.NUMPAD_9:
							case keys.NUMPAD_MULTIPLY:
							case keys.NUMPAD_PLUS:
							case keys.NUMPAD_ENTER:
							case keys.NUMPAD_MINUS:
							case keys.NUMPAD_PERIOD:
							case keys.NUMPAD_DIVIDE:
								return;
						}
						if((charOrCode >= 65 && charOrCode <= 90) || (charOrCode >= 48 && charOrCode <= 57) || charOrCode == keys.SPACE){
							return; // keypress will handle simple non-modified printable keys
						}
						var named = false;
						for(var i in keys){
							if(keys[i] === e.keyCode){
								named = true;
								break;
							}
						}
						if(!named){
							return;
						} // only allow named ones through
					}
				}

				charOrCode = e.charCode >= 32 ? String.fromCharCode(e.charCode) : e.charCode;
				if(!charOrCode){
					charOrCode = (e.keyCode >= 65 && e.keyCode <= 90) || (e.keyCode >= 48 && e.keyCode <= 57) || e.keyCode == keys.SPACE ? String.fromCharCode(e.keyCode) : e.keyCode;
				}
				if(!charOrCode){
					charOrCode = 229; // IME
				}
				if(e.type == "keypress"){
					if(typeof charOrCode != "string"){
						return;
					}
					if((charOrCode >= 'a' && charOrCode <= 'z') || (charOrCode >= 'A' && charOrCode <= 'Z') || (charOrCode >= '0' && charOrCode <= '9') || (charOrCode === ' ')){
						if(e.ctrlKey || e.metaKey || e.altKey){
							return;
						} // can only be stopped reliably in keydown
					}
				}

				// create fake event to set charOrCode and to know if preventDefault() was called
				var faux = { faux: true }, attr;
				for(attr in e){
					if(!/^(layer[XY]|returnValue|keyLocation)$/.test(attr)){ // prevent WebKit warnings
						var v = e[attr];
						if(typeof v != "function" && typeof v != "undefined"){
							faux[attr] = v;
						}
					}
				}
				lang.mixin(faux, {
					charOrCode: charOrCode,
					_wasConsumed: false,
					preventDefault: function(){
						faux._wasConsumed = true;
						e.preventDefault();
					},
					stopPropagation: function(){
						e.stopPropagation();
					}
				});

				this._lastInputProducingEvent = faux;

				// Give web page author a chance to consume the event.  Note that onInput() may be called multiple times
				// for same keystroke: once for keypress event and once for input event.
				//console.log(faux.type + ', charOrCode = (' + (typeof charOrCode) + ') ' + charOrCode + ', ctrl ' + !!faux.ctrlKey + ', alt ' + !!faux.altKey + ', meta ' + !!faux.metaKey + ', shift ' + !!faux.shiftKey);
				if(this.onInput(faux) === false){ // return false means stop
					faux.preventDefault();
					faux.stopPropagation();
				}
				if(faux._wasConsumed){
					return;
				} // if preventDefault was called

				// IE8 doesn't emit the "input" event at all, and IE9 doesn't emit it for backspace, delete, cut, etc.
				// Since the code below (and perhaps user code) depends on that event, emit it synthetically.
				// See http://benalpert.com/2013/06/18/a-near-perfect-oninput-shim-for-ie-8-and-9.html.
				if(has("ie") <= 9){
					switch(e.keyCode){
					case keys.TAB:
					case keys.ESCAPE:
					case keys.DOWN_ARROW:
					case keys.UP_ARROW:
					case keys.LEFT_ARROW:
					case keys.RIGHT_ARROW:
						// These keys may alter the <input>'s value indirectly, but we don't want to emit an "input"
						// event.  For example, the up/down arrows in TimeTextBox or ComboBox will cause the next
						// dropdown item's value to be copied to the <input>.
						break;
					default:
						if(e.keyCode == keys.ENTER && this.textbox.tagName.toLowerCase() != "textarea"){
							break;
						}
						this.defer(function(){
							if(this.textbox.value !== this._lastInputEventValue){
								on.emit(this.textbox, "input", {bubbles: true});
							}
						});
					}
				}
			}
			this.own(
				on(this.textbox, "keydown, keypress, paste, cut, compositionend", lang.hitch(this, handleEvent)),
				on(this.textbox, "input", lang.hitch(this, "_onInput")),

				// Allow keypress to bubble to this.domNode, so that TextBox.on("keypress", ...) works,
				// but prevent it from further propagating, so that typing into a TextBox inside a Toolbar doesn't
				// trigger the Toolbar's letter key navigation.
				on(this.domNode, "keypress", function(e){ e.stopPropagation(); })
			);
		},

		_blankValue: '', // if the textbox is blank, what value should be reported
		filter: function(val){
			// summary:
			//		Auto-corrections (such as trimming) that are applied to textbox
			//		value on blur or form submit.
			// description:
			//		For MappedTextBox subclasses, this is called twice
			//
			//		- once with the display value
			//		- once the value as set/returned by set('value', ...)
			//
			//		and get('value'), ex: a Number for NumberTextBox.
			//
			//		In the latter case it does corrections like converting null to NaN.  In
			//		the former case the NumberTextBox.filter() method calls this.inherited()
			//		to execute standard trimming code in TextBox.filter().
			//
			//		TODO: break this into two methods in 2.0
			//
			// tags:
			//		protected extension
			if(val === null){
				return this._blankValue;
			}
			if(typeof val != "string"){
				return val;
			}
			if(this.trim){
				val = lang.trim(val);
			}
			if(this.uppercase){
				val = val.toUpperCase();
			}
			if(this.lowercase){
				val = val.toLowerCase();
			}
			if(this.propercase){
				val = val.replace(/[^\s]+/g, function(word){
					return word.substring(0, 1).toUpperCase() + word.substring(1);
				});
			}
			return val;
		},

		_setBlurValue: function(){
			// Format the displayed value, for example (for NumberTextBox) convert 1.4 to 1.400,
			// or (for CurrencyTextBox) 2.50 to $2.50

			this._setValueAttr(this.get('value'), true);
		},

		_onBlur: function(e){
			if(this.disabled){
				return;
			}
			this._setBlurValue();
			this.inherited(arguments);
		},

		_isTextSelected: function(){
			return this.textbox.selectionStart != this.textbox.selectionEnd;
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){
				return;
			}

			// Select all text on focus via click if nothing already selected.
			// Since mouse-up will clear the selection, need to defer selection until after mouse-up.
			// Don't do anything on focus by tabbing into the widget since there's no associated mouse-up event.
			if(this.selectOnClick && by == "mouse"){
				// Use on.once() to only select all text on first click only; otherwise users would have no way to clear
				// the selection.
				this._selectOnClickHandle = on.once(this.domNode, "mouseup, touchend", lang.hitch(this, function(evt){
					// Check if the user selected some text manually (mouse-down, mouse-move, mouse-up)
					// and if not, then select all the text
					if(!this._isTextSelected()){
						_TextBoxMixin.selectInputText(this.textbox);
					}
				}));
				this.own(this._selectOnClickHandle);

				// in case the mouseup never comes
				this.defer(function(){
					if(this._selectOnClickHandle){
						this._selectOnClickHandle.remove();
						this._selectOnClickHandle = null;
					}
				}, 500); // if mouseup not received soon, then treat it as some gesture
			}
			// call this.inherited() before refreshState(), since this.inherited() will possibly scroll the viewport
			// (to scroll the TextBox into view), which will affect how _refreshState() positions the tooltip
			this.inherited(arguments);

			this._refreshState();
		},

		reset: function(){
			// Overrides `dijit/_FormWidget/reset()`.
			// Additionally resets the displayed textbox value to ''
			this.textbox.value = '';
			this.inherited(arguments);
		}
	});

	if(has("dojo-bidi")){
		_TextBoxMixin = declare("dijit.form._TextBoxMixin", _TextBoxMixin, {
			_setValueAttr: function(){
				this.inherited(arguments);
				this.applyTextDir(this.focusNode);
			},
			_setDisplayedValueAttr: function(){
				this.inherited(arguments);
				this.applyTextDir(this.focusNode);
			},
			_onInput: function(){
				this.applyTextDir(this.focusNode);
				this.inherited(arguments);
			}
		});
	}

	_TextBoxMixin._setSelectionRange = dijit._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
		if(element.setSelectionRange){
			element.setSelectionRange(start, stop);
		}
	};

	_TextBoxMixin.selectInputText = dijit.selectInputText = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
		// summary:
		//		Select text in the input element argument, from start (default 0), to stop (default end).

		// TODO: use functions in _editor/selection.js?
		element = dom.byId(element);
		if(isNaN(start)){
			start = 0;
		}
		if(isNaN(stop)){
			stop = element.value ? element.value.length : 0;
		}
		try{
			element.focus();
			_TextBoxMixin._setSelectionRange(element, start, stop);
		}catch(e){ /* squelch random errors (esp. on IE) from unexpected focus changes or DOM nodes being hidden */
		}
	};

	return _TextBoxMixin;
});

},
'ibm/tivoli/fwm/mxmap/findlocation/FindLocationPanelWidget':function(){
/* IBM Confidential
 *
 /* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define( ["dojo/_base/declare", "dojo/dom-construct",
		"dijit/_Widget",
		"dijit/_Templated",
		"ibm/tivoli/fwm/mxmap/_Base",
		"dojo/dom", "dojo/dom-style",
		"dojo/on", "dojo/dom-class",
		"dijit/form/Button", "dijit/form/TextBox"
	], function (declare, domConstruct, _Widget, _Templated,_Base,  dom, domStyle, on, domClass, Button, TextBox) {

	return declare( [_Widget, _Templated, _Base], {
		templateString: dojo.cache("ibm.tivoli.fwm.mxmap", "templates/FindLocationPanelWidget.html", "<div>\n\t<div data-dojo-attach-point=\"findLocationDiv\" id=\"findLocationToolDiv\" class=\"findLocationBar\"></div>\n</div>\n"),
		
		/* Tool initialization. The params argument,
		 * by default, contains only the Map reference */
		constructor: function(params)
		{
			dojo.mixin(this, params);	
		},
		/**
		 * Create the Find Location bar on the map
		 */
		createBar: function() {
			var mapDiv = this.map.element;
			
			this.searchField = new TextBox({
 	  		        id: "findLocationToolInputField",
 	  		        "class": "findLocationToolInputTxt",
 	  		        value: "",
 	  		        placeHolder: ibm.tivoli.fwm.i18n.getMaxMsg("map", "findLocation")
 	  		    });
			
			
			this.searchButton = new Button( {
				label : "",
				showLabel : false,
				iconClass : "findLocationToolButton findLocationToolFindButton",
				id: "findLocationToolFindButton",
				onClick : dojo.hitch( this, function() {
					this.searchButton.set("disabled", true);
					this.findAddressLocation();
					}),
				onDblClick : dojo.hitch( this, function(event ) {
					event.stopPropagation();
					})
			});
			this.searchButton.set("disabled", true);
			dojo.subscribe('findLocationSelected',dojo.hitch(this,function(){
				this.searchButton.set("disabled", false);
			}));
			on(this.searchField, "keyUp", dojo.hitch(this, function(evt) {
				if (this.searchButton.get("disabled")) {
					if (!this.searchField.displayedValue == "") {
						this.searchButton.set("disabled", false);
					}
				} else if (this.searchField.displayedValue == "") {
					this.searchButton.set("disabled", true);
				}
			}));
			on(this.searchField, "keyDown", dojo.hitch(this, function(evt) {
				if (evt.keyCode == "13") {
					evt.preventDefault();
					this.findAddressLocation();
				}
				if (evt.keyCode == "27") {
					this.tool.execute();
				}
			}));
			
			/*
			 * Set the css class for the find location bar based on the provider
			 */
			if (this.map.mapConf.provider == "spatial") {
				domClass.add(this.findLocationDiv, "spatialFindLocationBar");
			} else if (this.map.mapConf.provider == "gmaps") {
				domClass.add(this.findLocationDiv, "gMapsFindLocationBar");
			} else if (this.map.mapConf.provider) {
				domClass.add(this.findLocationDiv, "bmapsFindLocationBar");
			}
			
			domStyle.set(this.findLocationDiv, "z-index", "1000");
			
			domConstruct.place(this.domNode, mapDiv, "first");
			domConstruct.place(this.searchField.domNode, this.findLocationDiv, "first");
			domConstruct.place(this.searchButton.domNode, this.findLocationDiv, "last");
			
			this.searchButton.startup();
		},
		/**
		 * Calls the geocoder findlocation methos, using as a parameter the search field value
		 */
		findAddressLocation: function() {
			var locationString = this.searchField.getValue();
			this.map.geocoder.findLocation(locationString);
		},
		/**
		 * Show the Find Location bar on the map
		 */
		show: function() {
			domStyle.set(this.findLocationDiv, "display", "inline");
		},
		hide: function() {
			domStyle.set(this.findLocationDiv, "display", "none");
		},
		destroy: function()
		{
			if (this.searchField) {
				this.searchField.destroyRecursive();
			}
			if (this.searchButton) {
				this.searchButton.destroyRecursive();
			}
			if (this.closeButton) {
				this.closeButton.destroyRecursive();
			}
			
		}
	})
});

},
'dijit/PopupMenuItem':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/dom-style", // domStyle.set
	"dojo/_base/lang",
	"dojo/query", // query
	"./popup",
	"./registry",	// registry.byNode
	"./MenuItem",
	"./hccss"
], function(declare, domStyle, lang, query, pm, registry, MenuItem){

	// module:
	//		dijit/PopupMenuItem

	return declare("dijit.PopupMenuItem", MenuItem, {
		// summary:
		//		An item in a Menu that spawn a drop down (usually a drop down menu)

		baseClass: "dijitMenuItem dijitPopupMenuItem",

		_fillContent: function(){
			// summary:
			//		When Menu is declared in markup, this code gets the menu label and
			//		the popup widget from the srcNodeRef.
			// description:
			//		srcNodeRef.innerHTML contains both the menu item text and a popup widget
			//		The first part holds the menu item text and the second part is the popup
			// example:
			// |	<div data-dojo-type="dijit/PopupMenuItem">
			// |		<span>pick me</span>
			// |		<popup> ... </popup>
			// |	</div>
			// tags:
			//		protected

			if(this.srcNodeRef){
				var nodes = query("*", this.srcNodeRef);
				this.inherited(arguments, [nodes[0]]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		_openPopup: function(/*Object*/ params, /*Boolean*/ focus){
			// summary:
			//		Open the popup to the side of/underneath this MenuItem, and optionally focus first item
			// tags:
			//		protected

			var popup = this.popup;

			pm.open(lang.delegate(params, {
				popup: this.popup,
				around: this.domNode
			}));

			if(focus && popup.focus){
				popup.focus();
			}
		},

		_closePopup: function(){
			pm.close(this.popup);
			this.popup.parentMenu = null;
		},

		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);

			// We didn't copy the dropdown widget from the this.srcNodeRef, so it's in no-man's
			// land now.  Move it to <body>.
			if(!this.popup){
				var node = query("[widgetId]", this.dropDownContainer)[0];
				this.popup = registry.byNode(node);
			}
			this.ownerDocumentBody.appendChild(this.popup.domNode);
			this.popup.domNode.setAttribute("aria-labelledby", this.containerNode.id);
			this.popup.startup();

			this.popup.domNode.style.display="none";
			if(this.arrowWrapper){
				domStyle.set(this.arrowWrapper, "visibility", "");
			}
			this.focusNode.setAttribute("aria-haspopup", "true");
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			if(this.popup){
				// Destroy the popup, unless it's already been destroyed.  This can happen because
				// the popup is a direct child of <body> even though it's logically my child.
				if(!this.popup._destroyed){
					this.popup.destroyRecursive(preserveDom);
				}
				delete this.popup;
			}
			this.inherited(arguments);
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/Radius':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */


define(["dojo/_base/declare"], function(declare) {
	return declare( null, {

		/**
		 * Creates a new radius object for drawing circles around a point, does a
		 * lot of initial calculation to increase load time
		 * 
		 * @name mxn.Radius
		 * @constructor
		 * @param {LatLonPoint}
		 *            center LatLonPoint of the radius
		 * @param {Number}
		 *            quality Number of points that comprise the approximated circle
		 *            (20 is a good starting point)
		 * @exports Radius as mxn.Radius
		 */
		constructor: function(params)
		{
			dojo.mixin(this, params);
			if(this.center && this.quality)
			{
				var _latConv = this.center.latConv();
				var _lonConv = this.center.lonConv();

				// Create Radian conversion constant
				var rad = Math.PI / 180;
				this.calcs = [];

				for ( var i = 0; i < 360; i += this.quality)
				{
					this.calcs.push([ Math.cos(i * rad) / _latConv, Math.sin(i * rad) / _lonConv ]);
				}
			}
		},

		/**
		 * Returns polyline of a circle around the point based on new radius
		 * 
		 * @param {Radius}
		 *            radius
		 * @param {Color}
		 *            color
		 * @returns {Polyline} Polyline
		 */
		getPolyline: function(radius, color)
		{
			var points = [];
			for ( var i = 0; i < this.calcs.length; i++)
			{
				var point = this.map.latLng(this.center.lat + (radius * this.calcs[i][0]), this.center.lon + (radius * this.calcs[i][1]));
				points.push(point);
			}

			// Add first point
			points.push(points[0]);

			var line = this.map.polyline({points: points});
			line.setColor(color);

			return line;
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/_BoundingBox':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */


define(["dojo/_base/declare"], function(declare) {
	return declare( null, {

		sw: null,
		ne: null,
		/**
		 * BoundingBox creates a new bounding box object
		 * 
		 * @name mxn.BoundingBox
		 * @constructor
		 * @param {double}
		 *            swlat the latitude of the south-west point
		 * @param {double}
		 *            swlon the longitude of the south-west point
		 * @param {double}
		 *            nelat the latitude of the north-east point
		 * @param {double}
		 *            nelon the longitude of the north-east point
		 * @exports BoundingBox as mxn.BoundingBox
		 */
		constructor: function(swLat, swLon, neLat, neLon)
		{
			this._init(swLat, swLon, neLat, neLon);
		},

		_init: function(swLat, swLon, neLat, neLon)
		{
			// FIXME throw error if box bigger than world
			// alert('new bbox ' + swlat + ',' + swlon + ',' + nelat + ',' + nelon);
			this.sw = new ibm.tivoli.fwm.mxmap._LatLonPoint({lat: swLat, lon: swLon, lng: swLon});
			this.ne = new ibm.tivoli.fwm.mxmap._LatLonPoint({lat: neLat, lon: neLon, lng: neLon});
		},

		/**
		 * getSouthWest returns a LatLonPoint of the south-west point of the
		 * bounding box
		 * 
		 * @returns the south-west point of the bounding box
		 * @type LatLonPoint
		 */
		getSouthWest: function()
		{
			return this.sw;
		},

		/**
		 * getNorthEast returns a LatLonPoint of the north-east point of the
		 * bounding box
		 * 
		 * @returns the north-east point of the bounding box
		 * @type LatLonPoint
		 */
		getNorthEast: function()
		{
			return this.ne;
		},

		merge: function(bbox)
		{
			if(bbox)
			{
				this.extend(bbox.sw);
				this.extend(bbox.ne);
			}
		},
		/**
		 * extend extends the bounding box to include the new point
		 */
		extend: function(point)
		{
			// console.log(this.sw.lat,point.lat,(this.sw.lat > point.lat));
			// console.log(this.sw.lon,point.lon,(this.sw.lon > point.lon));
			// console.log(this.ne.lat,point.lat,(this.ne.lat < point.lat));
			// console.log(this.ne.lon,point.lon,(this.ne.lon < point.lon));

			if(point)
			{
				if (this.sw.lat > point.lat)
				{
					this.sw.lat = point.lat;
				}
				if (this.sw.lng > point.lng)
				{
					this.sw.lng = this.sw.lon = point.lng;
				}
				if (this.ne.lat < point.lat)
				{
					this.ne.lat = point.lat;
				}
				if (this.ne.lng < point.lng)
				{
					this.ne.lng = this.ne.lon = point.lng;
				}
			}
			return;
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/InfoSummaryPanelWidget':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/_base/declare",
	"dijit/_Widget",
	"dijit/_Templated"],
	function(declare, _Widget, _Templated ) {
	return declare([_Widget, _Templated], {
		templateString: dojo.cache("ibm.tivoli.fwm.mxmap", "templates/InfoSummaryPanelWidget.html", "<div class=\"text\">\n\t<div data-dojo-attach-point=\"infoSummaryPanel\"></div>\n</div>"),
		constructor:function(params)
		{
			dojo.mixin(this, params);				
		}
	});

});


},
'dojo/hccss':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"require",			// require, require.toUrl
	"./_base/config", // config.blankGif
	"./dom-class", // domClass.add
	"./dom-style", // domStyle.getComputedStyle
	"./has",
	"./domReady",
	"./_base/window" // win.body
], function(require, config, domClass, domStyle, has, domReady, win){

	// module:
	//		dojo/hccss

	/*=====
	return function(){
		// summary:
		//		Test if computer is in high contrast mode (i.e. if browser is not displaying background images).
		//		Defines `has("highcontrast")` and sets `dj_a11y` CSS class on `<body>` if machine is in high contrast mode.
		//		Returns `has()` method;
	};
	=====*/

	// Has() test for when background images aren't displayed.  Don't call has("highcontrast") before dojo/domReady!.
	has.add("highcontrast", function(){
		// note: if multiple documents, doesn't matter which one we use
		var div = win.doc.createElement("div");
		try{
			div.style.cssText = "border: 1px solid; border-color:red green; position: absolute; height: 5px; top: -999px;" +
				"background-image: url(\"" + (config.blankGif || require.toUrl("./resources/blank.gif")) + "\");";
			win.body().appendChild(div);

			var cs = domStyle.getComputedStyle(div),
				bkImg = cs.backgroundImage;
			return cs.borderTopColor == cs.borderRightColor ||
				(bkImg && (bkImg == "none" || bkImg == "url(invalid-url:)" ));
		}catch(e){
			console.warn("hccss: exception detecting high-contrast mode, document is likely hidden: " + e.toString());
			return false;
		}finally{
			if(has("ie") <= 8){
				div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
			}else{
				win.body().removeChild(div);
			}
		}
	});

	domReady(function(){
		if(has("highcontrast")){
			domClass.add(win.body(), "dj_a11y");
		}
	});

	return has;
});

},
'ibm/tivoli/fwm/mxmap/dispatcher/DispatcherManager':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/routing/MultipleRoutesManager,ibm/tivoli/fwm/mxmap/ImageLibraryManager"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.dispatcher.DispatcherManager");
dojo.require("ibm.tivoli.fwm.mxmap.routing.MultipleRoutesManager");
dojo.require("ibm.tivoli.fwm.mxmap.ImageLibraryManager");
/**
 * Controls the communication between the map,routing and the applet.<br>
 * By default it sets the map symbology to be based on the routes.
 */
dojo.declare("ibm.tivoli.fwm.mxmap.dispatcher.DispatcherManager", ibm.tivoli.fwm.mxmap._Base, {
	// these are all static... not sure that is intentional
	map: null,
	_needsModelRefresh: false,
	applet: null,
	routeCache: null,
	routeManager: null,
	_calculatingRoutes: false,
	_callBuffer: [],
	_totalRequested: 0,
	_totalCompleted: 0,
	travelTimeToSave: [],
	errorCodes: null,
	_updateProjTries: 10,
	constructor: function(params)
	{
		dojo.mixin(this, params);

		if (this.map.isMapGraphite()) {
			return;
		}

		this.map.registerDatasourceRefresh(dojo.hitch(this, this.refreshDS));
		this._executionOptions = {};
		this.routeManager = this.map.routeManager;
		this.addSubscription("onWorkAssigned_" + this.map.getId(), dojo.hitch(this, this.onWorkAssigned));
		this.routeCache = {};
		this._calculatingRoutes = false;
		this._callBuffer = [];
		this._needsModelRefresh = false;
		this.errorCodes = [];
		this._totalRequested = 0;
		this._totalCompleted = 0;
		this.travelTimeToSave = [];
		this._updateProjTries = 10;
	},

	/**
	 * Set the default symbology to be based on the Route.
	 */
	init: function()
	{
		if (this.map.isMapGraphite()) {
			this.map.initRoutes();
			return;
		}

		var workOrderMarkerInfo = ibm.tivoli.fwm.mxmap.ImageLibraryManager.getImageLibraryManager().getDefaultWorkOrderMarkerImageInfo();
		var resourceSymbology = {
			"id": "resource",
			"labelGroup": "map",
			"labelKey": "resourcesymbologylabel",
			"legendTitleGroup": "map",
			"legendTitleKey": "workorderresourcelegendtitle",
			"type": "dynamic",
			"legends": [ {
				"id": "fwm_default",
				"labelGroup": "map",
				"labelKey": "defaultlayerlabel",
				"symbol": {
					"url": workOrderMarkerInfo.getImageURL(),
					"color": "",
					"offsetx": workOrderMarkerInfo.getImageAnchor()[0],
					"offsety": workOrderMarkerInfo.getImageAnchor()[1],
					"width": workOrderMarkerInfo.getImageSize()[0],
					"height": workOrderMarkerInfo.getImageSize()[1]
				},
				"isDefault": true
			} ]
		};
		var layer = this.map.layersManager.getLayerForObjectName("WORKORDER");
		this.routeSymbology = layer.createNewChildLayer({
			layerName: ibm.tivoli.fwm.i18n.getMaxMsg("map", "resourcesymbologylabel"),
			layerId: resourceSymbology.id,
			layerConf: resourceSymbology,
			map: this.map,
			layerType: ibm.tivoli.fwm.mxmap.layers.LayerType.SYMBOLOGY,
			symbologyType: resourceSymbology.type,
			childrenTitle: ""
		});
		this.routeSymbology.toggleState();
		this.routeSymbology.setDefault();
		
		// Create the route layer if it does not already exist
		// It has nothing to do with the route symbology created above
		// This layer is just to allow for enabling/disabling route lines
		this.map.createRouteLayer();

		this.map.setDispatcher(this);
		
		this.addSubscription("onMarkerClicked_" + this.map.getId(), dojo.hitch(this, this._sendActivityToHighlight));
	},
	clearAllCurrentRoutes: function()
	{
		if (this.map.isMapGraphite()) {
			this.map.clearRoutes();
			return;
		}

		this.data = {};
		this.routeManager.clearAll();
		this.routeCache = {};
	},
	drawAllRoutes: function(routeData, successCallback, errorCallback)
	{
		if (this.map.isMapGraphite()) {
			this.map.drawRoutes(routeData);
			return;
		}

		this.resetMaximoTimer();
		// TODO find a way tocancel a previous request, like when user clicks
		// twice on the next calendar view page
		// 12-13571 - Since the applet can make more than one multiple route request for a given set of resources,
		// we cannot reset the this.travelTimeToSave buffer inside the _addRoute() method because would erase all
		// travel times from the previous request before sending to Maximo. So we only reset this.travelTimeToSave
		// if this is the first multiple route request from the applet.
		if(this._calculatingRoutes == false)
		{
			this.travelTimeToSave = [];
			// This variable cannot be reset in _addRoute() method as well because errors that might
			// happen in the first applet request will be ignored.
			this.errorCodes = [];
		}
		this._loadedData(routeData);
	},
	/**
	 * If several routing requests were done, we buffer the last one in order to
	 * execute after the other calls
	 */
	_triggerBufferedCalls: function()
	{
		if (this._callBuffer.length > 0)
		{
			console.log("executing buffered calls", this._callBuffer.length);
			// Using .shift() instead of .pop() because the route requests must be
			// processed in the same order they were received
			// We were using .pop() because we were only storing the last route request (which was wrong)
			this._loadedData(this._callBuffer.shift());
		}
	},
	/**
	 * Creates the routesfor the current Dispatch data. Data comes from the
	 * dispatch applet and contains the assignments per resources for a certain
	 * day.<br>
	 * 
	 * We only buffer the last request, so if a routing request is being handled
	 * and another 2 requests from dispatch are done, only the last one needs to
	 * be executed, improving usability and performance.
	 * 
	 * @param data
	 */
	_loadedData: function(data)
	{
		if (!window.ccc)
		{
			window.ccc = 0;
		}
		data.id = window.ccc++;
		console.info("DISPATCH loaded data", data.id, data);
		if (this._calculatingRoutes == true)
		{
			console.log("BUFFERING IN DISPATCH route being executed buffering call");

			var bufdata = this._callBuffer[0];
			if (bufdata && bufdata.options)
			{
				if (bufdata.options.hasErrCallback == true)
				{
					this._refreshInfo.errorCb();
				}
				else if (bufdata.options.hasCallback == true)
				{
					this._refreshInfo.callback();
				}
			}			
			//this._callBuffer[0] = (data);
			// Instead of just replacing the last stored route request, we buffer all of them
			// because if we scroll through more than one group of work orders and more than 2 route
			// requests are made, we can't ignore the intermediate ones because they may be "clear route"
			// requests. When scrolling from a group of WOs to another without running the "clear route" request
			// for all resources, some old routes may not be deleted if the second group of WOs do not
			// contain routes for some resources that the first group had.
			this._callBuffer.push(data);
			// Previous (wrong) comment: only one is buffered, we only
			// calculate the last requested
			// route
		}
		else
		{
			console.log("executing", data.options);
			var routes = data.allRoutes;
			this._totalRequested = routes.length;
			this.data = data;
			if (this._totalRequested > 0)
			{
				this._startTime = new Date().getTime();
				// This variable cannot be reset here because errors that might happen in the first applet
				// request will be ignored.
				//this.errorCodes = [];
				this._calculatingRoutes = true;
				// simple mutex
				this._needsModelRefresh = false;
				if (dojo.config.fwm.debug == true)
				{
					// console.log("map", this.map);
					// console.log(routes.length, data);
				}

				this._totalCompleted = 0;

				for ( var i = 0; i < routes.length; i++)
				{
					var routeInfo = routes[i];
					this._addRoute(id, routeInfo);
				}

			}
			else
			{
				// 12-13612. Sometimes (not sure why) a buffered call runs and the logic flow ends up here
				// because this._totalRequested = 0. When this happens (mostly because the user scrolled
				// the applet from one day do another skipping one day between the two), the zoomAndCenterOverAll() function
				// is not called when the routes are done loading. So I added the logic below (the same as in allSLRRequestsComplete())
				// to guarantee that zoomAndCenterOverAll() runs.
				this.allSLRRequestsComplete();
			}
		}
	},
	/*
	 * DEBUGGGING purposes, would add a stop marker
	 */
	__debugAddStopToMap: function(record)
	{
		var point = this.map.latLng(record.lat, record.lng);
		this.map.addMarker(point);
	},
	/**
	 * Draws a route based on the route info of a resource
	 * 
	 * @param id
	 * @param routeInfo
	 */
	_addRoute: function(id, routeInfo)
	{

		var color = routeInfo.color;
		if (color.substring(0, 1) != '#')
		{
			color = "#" + color;
		}

		var stops = [];
		// 12-13571 - Since the applet can make more than one multiple route request for a given set of resources,
		// we cannot reset the this.travelTimeToSave buffer here because would erase all
		// travel times from the previous request before sending to Maximo. So we only reset this.travelTimeToSave
		// in the first multiple route request from the applet.
		//this.travelTimeToSave = [];
		var cf = this.map.routeConf;
		cf.routecolor = color;
		stops = routeInfo.stops;
		var routeInfoAux = routeInfo;
		if (routeInfo.noroute != true && stops.length > 1)
		{

			var complete = function(route)
			{
				if (this.routeCache[routeInfoAux.resource.id])
				{
					this.routeCache[routeInfoAux.resource.id].clear();
				}
				this.routeCache[routeInfoAux.resource.id] = route;
				this.completeRoute(route, routeInfoAux);

			};
			var error = function(errorCode, msg)
			{
				this._totalCompleted++;
				this.onError(errorCode, routeInfoAux, msg);
				// 12-13610 - We need to try to remove this cached route if the route creation was successful for this resource
				// in a previous day. Otherwise, if the route fails for this day (which is the case here), the old route
				// will not be deleted and may confuse the user.
				if (this.routeCache[routeInfo.resource.id])
				{
					this.routeCache[routeInfo.resource.id].clear();
					this.routeCache[routeInfo.resource.id] = null;
				}
				if (this._totalCompleted == this._totalRequested)
				{
					this.allSLRRequestsComplete();
				}
			};
			this.routeManager.createRoute(stops, cf, dojo.hitch(this, complete), dojo.hitch(this, error), true);
		}
		else
		{
			this._totalCompleted++;
			if (routeInfo.noroute == true)
			{
				if (dojo.config.fwm.debug == true)
				{
					console.log("no route for this resource", routeInfo);
				}
			}
			else
			{
				this.onError("MIN_STOPS_REQ", routeInfoAux);
			}
			if (this.routeCache[routeInfo.resource.id])
			{
				this.routeCache[routeInfo.resource.id].clear();
				this.routeCache[routeInfo.resource.id] = null;
			}
			if (this._totalCompleted == this._totalRequested)
			{
				this.allSLRRequestsComplete();
			}
		}
	},
	/**
	 * this method is called when a route is completed. It will handle any need
	 * to save the travel time.
	 * 
	 * @param route
	 * @param routeInfo
	 */
	completeRoute: function(route, routeInfo)
	{
		if (dojo.config.fwm.debug == true)
		{
			console.log("route", route);
			console.log("routeInfo", routeInfo);
		}
		this._totalCompleted++;
		for ( var j in routeInfo.stops)
		{
			var item = routeInfo.stops[j];

			if (j > 0)
			{
				var legInfo = route.itinerary.legs[j - 1];

				var routedata = item.routedata;
				if (routedata == null)
				{
					console.error("Assignment ", item, " with no route data info");
					continue;
				}
				if (routedata.HASTRAVELTIME == false)
				{

					if (legInfo)
					{
						var totalSecondsToStop = this.convertDurationToSeconds(legInfo.durationToLeg);
						if (totalSecondsToStop)
						{

							var slrTravelData = {
								ASSIGNMENTID: routedata.ASSIGNMENTID,
								SLROUTEID: routedata.SLROUTEID,
								FROMLOCATIONSID: routedata.FROMLOCATIONSID,
								TOLOCATIONSID: routedata.TOLOCATIONSID,
								FROMASSIGNMENT: routedata.FROMASSIGNMENT,
								TRAVELTIME_SECS: totalSecondsToStop
							};

							this.travelTimeToSave.push(slrTravelData);
							this._needsModelRefresh = true;
						}
					}
				}
			}

		}

		console.log(this._totalCompleted, "/", this._totalRequested, "routes created");

		if (this._totalCompleted == this._totalRequested)
		{
			this.allSLRRequestsComplete();
		}
	},
	/**
	 * Simple conversion from duration double to seconds
	 * 
	 * @param duration
	 * @returns
	 */
	convertDurationToSeconds: function(/* in minutes */duration)
	{
		return Math.round(duration * 60);
	},
	/**
	 * On a failure of creating a route we buffer it and only display after all
	 * routes are drawn. We buffer the error, the route info and any message
	 * from the routing service.
	 * 
	 * @param errorCode
	 * @param routeInfo
	 * @param msg
	 */
	onError: function(errorCode, routeInfo, msg)
	{
		console.warn("Failed to draw route", errorCode);
		var errorMsg = msg;
		if (msg && msg.message)
		{
			errorMsg = msg.message;
		}

		this.errorCodes.push({
			errorInfo: {
				code: errorCode,
				msg: errorMsg
			},
			routeInfo: routeInfo
		});

	},

	/**
	 * function to post events to maximo, subclasses can override
     */
	postEvent: function(name, data, onSuccess, onError) {
		var myEvent = new Event(name, 'mapdispatcher-mxdispatcherctrl', data, REQUESTTYPE_HIGHASYNC);
		queueManager.queueEvent(myEvent, "application/json", "json", onSuccess, onError);
	},

	/**
	 * If any traveltime needs to be saved, this is executed and saves ALL the
	 * traveltime calculated in this routing execution
	 */
	_saveBulkOfSLRTravelTime: function()
	{
		var success = function(result)
		{
			console.log("result", result);
			this._handleServerData(result, "onSLRTravelTimeUpdated");
		};
		this.postEvent("SAVEBULKTRAVELTIME", this.travelTimeToSave, dojo.hitch(this, success), dojo.hitch(this, this.genericError));
		// var myEvent = new Event("SAVEBULKTRAVELTIME", 'mapdispatcher-mxdispatcherctrl', this.travelTimeToSave, REQUESTTYPE_HIGHASYNC);
		// queueManager.queueEvent(myEvent, "application/json", "json", dojo.hitch(this, success), dojo.hitch(this, this.genericError));
	},
	/**
	 * @deprecated use _saveBulkOfSLRTravelTime
	 * @param slrTravel
	 */
	_saveSLRTravelTime: function(slrTravel)
	{
		var success = function(data)
		{
			console.log("Saved SLRTravel Time ", data, slrTravel);

		};
		this.postEvent("SAVETRAVELTIME", slrTravel, success, this.genericError);
		// var myEvent = new Event("SAVETRAVELTIME", this.mxdispatcherctrl, slrTravel, REQUESTTYPE_HIGHASYNC);
		// queueManager.queueEvent(myEvent, "application/json", "json", success, this.genericError);
	},
	/**
	 * This is a method to wrap up the applet calls to the server.
	 * 
	 * @param p
	 * @param appletCallbackFunction
	 * @param appletErrorCallback
	 */
	sendActionToServer: function(p, appletCallbackFunction, appletErrorCallback)
	{
		var beanMethodName = p.servermethod;
		var params = p.serverparams;
		if (dojo.config.fwm.debug == true)
		{
			console.log("sendActionToServer", beanMethodName, params, appletCallbackFunction);
		}
		var callback = function(data)
		{
			this._handleServerData(data, appletCallbackFunction, appletErrorCallback);

		};

		this.postEvent(beanMethodName, params, dojo.hitch(this, callback), dojo.hitch(this, callback));
		// var myEvent = new Event(beanMethodName, this.mxdispatcherctrl, params, REQUESTTYPE_HIGHASYNC);
		// queueManager.queueEvent(myEvent, "application/json", "json", dojo.hitch(this, callback), dojo.hitch(this, callback));
	},

	/**
	 * When all routes are completed for a certain dispatch request this method
	 * handles the results.<br>
	 * If there are buffered calls just skip the final methods and go on with
	 * the routing calculation of the buffered scripts.
	 */
	allSLRRequestsComplete: function()
	{

		this._calculatingRoutes = false;
		console.log("completed ", this.data.id, this.data.options);
		if (this._callBuffer.length > 0)
		{
			this.handleExecutionFinished();
			this._triggerBufferedCalls();
		}
		else
		{
			if (!this.data.options || this.data.options.noZoom != true)
			{
				// Pass the routes to be zoomed at. If not, routeManager will use
				// all of its routes (visible and invisible), which is wrong.
				this.routeManager.zoomAndCenterOverAll(this.routeCache);
			}

			var _endTime = new Date().getTime();
			console.info("Total for all routes b4 saving travel time: ", (_endTime - this._startTime), "ms");
			if (this.travelTimeToSave != null && this.travelTimeToSave.length > 0)
			{
				this._saveBulkOfSLRTravelTime();
			}

			if (this.map)
			{
				if (this.errorCodes != null && this.errorCodes.length > 0)
				{
					var returnedFct = function(data)
					{
						this.triggerMsgs();
						this.handleExecutionFinished();
					};

					this.postEvent("SHOWMULTIPLEROUTEERRORS", this.errorCodes, dojo.hitch(this, returnedFct), dojo.hitch(this, returnedFct));
					// var myEvent = new Event("SHOWMULTIPLEROUTEERRORS", this.mxdispatcherctrl, this.errorCodes, REQUESTTYPE_HIGHASYNC);
					// queueManager.queueEvent(myEvent, "application/json", "json", dojo.hitch(this, returnedFct), dojo.hitch(this, returnedFct));

				}
				else
				{
					this.handleExecutionFinished();

				}
			}
		}

	},
	handleExecutionFinished: function()
	{
		if (this.data.options && this.data.options.hasCallback == true)
		{
			this._refreshInfo.callback(this.routeManager);
		}
	},
	/**
	 * This is to force maximo to show messages on any error
	 * 
	 * @param error
	 */
	genericError: function(error)
	{
		this._calculatingRoutes = false;
		this.triggerMsgs();
		console.error("Error ", error);
	},
	/**
	 * All data returned from server is handled by this method that can trigger
	 * other messages or just call the success function back
	 */
	_handleServerData: function(data, callback, errCallback)
	{
		if (data && data.result == 'failed')
		{
			console.warn("there was an error on server", data);
			if (data.mxerror == true)
			{
				this.triggerMsgs();
			}
			if (errCallback)
			{
				this.getApplet().jsCallback(errCallback, dojo.toJson(data));
			}
		}
		else
		{
			this.getApplet().jsCallback(callback, dojo.toJson(data));
		}
	},
	/**
	 * Update several asignments at once
	 */
	bulkAssignmentsUpdates: function(arrayOfAssignments)
	{
		var success = function(data)
		{
			this._handleServerData(data, "onBulkAssignments");
			// this.getApplet().jsCallback("onBulkAssignments",
			// dojo.toJson(data));
		};

		this.postEvent("UPDATEASSIGNMENTS", arrayOfAssignments, dojo.hitch(this, success), dojo.hitch(this, this.genericError));
		// var myEvent = new Event("UPDATEASSIGNMENTS", this.mxdispatcherctrl, arrayOfAssignments, REQUESTTYPE_HIGHASYNC);
		// queueManager.queueEvent(myEvent, "application/json", "json", dojo.hitch(this, success), dojo.hitch(this, this.genericError));
		this.resetMaximoTimer();
	},
	/**
	 * On SKDProject updates it is called to reload the projects data.
	 * 
	 * @param projId
	 */
	updateProject: function(projId)
	{
		console.log("Project changed");
		if (!this.getApplet())
		{
			this._updateProjTries--;
			if (this._updateProjTries <= 0)
			{
				this._updateProjTries = 10;
				console.error("Can't find the applet or it's not loaded!");
			}
			else
			{
				var fct = function()
				{
					this.updateProject(projId);
				};
				setTimeout(dojo.hitch(this, fct), 1000);
			}
		}
		this._updateProjTries = 10;
		this.getApplet().updateProjId(projId);
		this.resetMaximoTimer();
	},
	/**
	 * Due the high async calls, we need to force maximo to trigger its actions
	 * thru sync calls to trigger messages and actions
	 */
	triggerMsgs: function()
	{
		sendEvent("TRIGGERMSGS", 'mapdispatcher-mxdispatcherctrl');
		this.resetMaximoTimer();
	},
	/**
	 * Applets reference gets lost when changing tabs or re loading it. So this
	 * method tries "hard" to get its reference
	 * 
	 * @returns
	 */
	getApplet: function()
	{
		try
		{

			this.applet.isLoaded();
			return this.applet;
		}
		catch (e)
		{
			console.log("trying to refecth the applet with dojo.byId ", dojo.byId("CalendarViewId"), e);
			this.applet = dojo.byId("CalendarViewId");
			try
			{
				this.applet.isLoaded();
				return this.applet;
			}
			catch (e2)
			{
				console.log("trying to refecth the applet with window.CalendarViewId", window.CalendarViewId, e2);
				this.applet = window.CalendarViewId;
				try
				{
					this.applet.isLoaded();
					return this.applet;
				}
				catch (e3)
				{
					console.warn("can't find applet to start communication", e3);
				}
			}
		}
	},
	/**
	 * Forces the applet to get refreshed
	 */
	refresh: function()
	{

		this.getApplet().updateModel();

	},
	_refreshInfo: null,
	refreshDS: function(callback, errorCallback, noZoom)
	{
		console.log("calling updateModel");
		// dangerous... but that's what i can do now Ideally we should pass it
		// to the applet
		this._refreshInfo = {
			callback: callback,
			errorCb: errorCallback
		};
		var _executionOptions = {
			noZoom: noZoom,
			refreshMap: true,
			hasCallback: false,
			hasErrCallback: false
		};
		if (callback)
		{
			_executionOptions.hasCallback = true;
		}
		if (callback)
		{
			_executionOptions.hasErrCallback = true;
		}
		this.getApplet().updateModelWithOptions(dojo.toJson(_executionOptions));
		console.log("done");
	},
	/**
	 * If any work order gets assigned we need to update the applets data.
	 */
	onWorkAssigned: function()
	{
		// need to refresh the model to load the assignmenton the applet.
		this.getApplet().updateModel();

	},
	/**
	 * On any action we must reset maximo timer.
	 */
	resetMaximoTimer: function()
	{
		resetLogoutTimer(false);
	},
	/**
	 * Shows route lines and calculated markers only for the
	 * resources that are currently active in calendar view
	 */
	showCachedRoutesLinesAndCalculatedMarkers: function()
	{
		for(resourceId in this.routeCache)
		{
			if(this.routeCache[resourceId] != null)
			{
				this.routeCache[resourceId].setLineVisible(true);
				this.routeCache[resourceId].showCalculatedMarkers();
			}
		}
	},
	/**
	 * Returns the route from routeCache which corresponds to the resource defined 
	 * by resourceType (LABOR or AMCREW) and resourceId (value of LABORCODE or AMCREW) 
	 */
	getRouteInfoForResource: function(resourceType, resourceId)
	{
		// The applet sends route data using a "key" in the following format:
		// "RESOURCE_TYPE : RESOURCE_ID", where RESOURCE_TYPE is either LABOR or AMCREW
		// and RESOURCE_ID is the value of the ID attribute (LABORCODE for labor and AMCREW for crew) 
		var routeInfo = this.routeCache[resourceType + ":" + resourceId];
		return routeInfo;
	},
	/**
	* highlight on the map the stop with the activityid of activityId, called from the applet on select
	*/
	highlightStop: function(activityId)
	{
		var markers = this.map.getMarkers();
		// Iterate over all markers that are showing on the map and, 
		// if the activityId is the same, then highlight it (show maptip)
		dojo.forEach(markers, function(marker)
		{
			if(marker.hasActivityId(activityId))
			{
				marker.openBubble();
			}
		});
	},
	
	/**
	 * Method that is triggered whenever a marker is clicked.
	 * The idea is to pass the activity ID to the applet so the assignment can be highlighted.
	 */
	_sendActivityToHighlight: function(params)
	{
		if(this.getApplet() != undefined)
		{
			var marker = params.marker;
			if(marker != undefined)
			{
				var activityIdArray = marker.getActivityIdArray();
				if(activityIdArray != null)
				{
					dojo.forEach(activityIdArray,  dojo.hitch(this, function(activityId)
					{
						// Highlight the activity that corresponds to
						// this marker if it contains activityId
						this.getApplet().highlightactivity(activityId);
					}));
				}

				// If this is a multi-marker, go for its children
				// and highlight their activities
				if(marker.hasReferencedMarkers())
				{
					referencedMarkers = marker.getReferencedMarkers();
					dojo.forEach(referencedMarkers, dojo.hitch(this, function(referencedMarker)
					{
						activityIdArray = referencedMarker.getActivityIdArray();
						if(activityIdArray != null)
						{
							dojo.forEach(activityIdArray, dojo.hitch(this,function(activityId)
							{
								// Highlight the activity that corresponds to
								// this marker if it contains activityId
								this.getApplet().highlightactivity(activityId);
							}));
						}
					}));
				}
			}
		}
		else
		{
			console.error("Could not call this.getApplet().highlightactivity(activityId) because this.getApplet() returned undefined");
		}
	},

	/**
	 * Method that is triggered by the applet whenever the unassigned work orders
	 * need to be updated on the map.
	 */
	updateUnAssignWODates: function(startDate, endDate)
	{
		var data = {
				startDate: dojo.number.parse(startDate),
				endDate: dojo.number.parse(endDate)
			};
		dojo.publish("onDispatcherRefresh_" + this.map.getId(), [data]);
	}
});

});

},
'dijit/form/RadioButton':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"./CheckBox",
	"./_RadioButtonMixin"
], function(declare, CheckBox, _RadioButtonMixin){

	// module:
	//		dijit/form/RadioButton

	return declare("dijit.form.RadioButton", [CheckBox, _RadioButtonMixin], {
		// summary:
		//		Same as an HTML radio, but with fancy styling.

		baseClass: "dijitRadio"
	});
});

},
'ibm/tivoli/fwm/mxmap/_Polyline':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */



define(["dojo/_base/declare"], 
		function(declare) {
	return declare(null, {
		api: null,
		points: null,
		attributes: [],
		onmap: false,
		proprietary_polyline: false,

		/**
		 * Instantiates a new Polyline.
		 * 
		 * @name mxn.Polyline
		 * @constructor
		 * @param {Point[]}
		 *            points Points that make up the Polyline.
		 * @exports Polyline as mxn.Polyline
		 */
		constructor: function(params)
		{
			dojo.mixin(this, params);
			this.pllID = "mspll-" + new Date().getTime() + '-' + (Math.floor(Math.random() * Math.pow(2, 16)));
		},

		/**
		 * Retrieve the settings from a proprietary polyline.
		 * 
		 * @name mxn.Polyline#fromProprietary
		 * @function
		 * @param {String}
		 *            apiId The API ID of the proprietary polyline.
		 * @param {Object}
		 *            polyline The proprietary polyline.
		 */
		fromProprietary: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		/**
		 * Hide the polyline.
		 * 
		 * @name mxn.Polyline#hide
		 * @function
		 */
		hide: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		/**
		 * Show the polyline.
		 * 
		 * @name mxn.Polyline#show
		 * @function
		 */
		show: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		/**
		 * Converts the current Polyline to a proprietary one for the API specified
		 * by apiId.
		 * 
		 * @name mxn.Polyline#toProprietary
		 * @function
		 * @param {String}
		 *            apiId The API ID of the proprietary polyline.
		 * @returns A proprietary polyline.
		 */
		toProprietary: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		/**
		 * Updates the Polyline with the path of the attached proprietary polyline
		 * on the map.
		 * 
		 * @name mxn.Polyline#update
		 * @function
		 */
		update: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		/**
		 * addData conviniently set a hash of options on a polyline
		 * 
		 * @param {Object}
		 *            options An object literal hash of key value pairs. Keys are:
		 *            color, width, opacity, closed, fillColor, borderOpacity.
		 */
		addData: function(options)
		{
			for ( var sOpt in options)
			{
				if (options.hasOwnProperty(sOpt))
				{
					switch (sOpt)
					{
					case 'color':
						this.setColor(options.color);
						break;
					case 'width':
						this.setWidth(options.width);
						break;
					case 'opacity':
						this.setOpacity(options.opacity);
						break;
					case 'closed':
						this.setClosed(options.closed);
						break;
					case 'fillColor':
						this.setFillColor(options.fillColor);
						break;
					case 'borderOpacity':
						this.setBorderOpacity(options.borderOpacity);
						break;
					default:
						this.setAttribute(sOpt, options[sOpt]);
					break;
					}
				}
			}
		},

		setChild: function(some_proprietary_polyline)
		{
			this.proprietary_polyline = some_proprietary_polyline;
			this.onmap = true;
		},

		/**
		 * in the form: #RRGGBB Note map24 insists on upper case, so we convert it.
		 */
		setColor: function(color)
		{
			this.color = (color.length == 7 && color[0] == "#") ? color.toUpperCase() : color;
		},

		/**
		 * Stroke width of the polyline
		 * 
		 * @param {Integer}
		 *            width
		 */
		setWidth: function(width)
		{
			this.width = width;
		},

		/**
		 * A float between 0.0 and 1.0
		 * 
		 * @param {Float}
		 *            opacity
		 */
		setOpacity: function(opacity)
		{
			this.opacity = opacity;
		},

		/**
		 * Marks the polyline as a closed polygon
		 * 
		 * @param {Boolean}
		 *            bClosed
		 */
		setClosed: function(bClosed)
		{
			this.closed = bClosed;
		},

		/**
		 * Fill color for a closed polyline as HTML color value e.g. #RRGGBB
		 * 
		 * @param {String}
		 *            sFillColor HTML color value #RRGGBB
		 */
		setFillColor: function(sFillColor)
		{
			this.fillColor = sFillColor;
		},

		/**
		 * A float between 0.0 and 1.0
		 * 
		 * @param {Float}
		 *            opacity
		 */
		setBorderOpacity: function(borderOpacity)
		{
			this.borderOpacity = borderOpacity;
		},

		/**
		 * Set an arbitrary key/value pair on a polyline
		 * 
		 * @param {String}
		 *            key
		 * @param value
		 */
		setAttribute: function(key, value)
		{
			this.attributes[key] = value;
		},

		/**
		 * Gets the value of "key"
		 * 
		 * @param {String}
		 *            key
		 * @returns value
		 */
		getAttribute: function(key)
		{
			return this.attributes[key];
		},

		/**
		 * Simplifies a polyline, averaging and reducing the points
		 * 
		 * @param {Number}
		 *            tolerance (1.0 is a good starting point)
		 */
		simplify: function(tolerance)
		{
			var reduced = [];

			// First point
			reduced[0] = this.points[0];

			var markerPoint = 0;

			for ( var i = 1; i < this.points.length - 1; i++)
			{
				if (this.points[i].distance(this.points[markerPoint]) >= tolerance)
				{
					reduced[reduced.length] = this.points[i];
					markerPoint = i;
				}
			}

			// Last point
			reduced[reduced.length] = this.points[this.points.length - 1];

			// Revert
			this.points = reduced;
		}

	});
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/MobileInfoPanel':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Base,dijit/form/Button,ibm/tivoli/fwm/mxmap/panels/MobileInfoPanelDialog"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.toolbar.ext.MobileInfoPanel");

dojo.require("ibm.tivoli.fwm.mxmap._Base");
dojo.require("dijit.form.Button");
dojo.require("ibm.tivoli.fwm.mxmap.panels.MobileInfoPanelDialog");

/**
 * Mobile Info Panel tool bar action.
 */
dojo.declare("ibm.tivoli.fwm.mxmap.toolbar.ext.MobileInfoPanel", ibm.tivoli.fwm.mxmap._Base, {
		label: "Info Panel",
		iconClass: "basicMapToolbarBtn",
		map: null,
		_dialog: null,
		constructor: function(params)
		{
			dojo.mixin(this, params);
			this._dialog = null;	
			var _label = ibm.tivoli.fwm.i18n.getMaxMsg("map", "infopanel");
			this.label = _label || this.label;
		},
		createToolbarButton: function()
		{
			var button = new dijit.form.Button( {
				label: this.label,
				showLabel: true,
				iconClass: this.iconClass,
				onClick: dojo.hitch(this, function()
				{
					this.execute();
				})
			});
			return button;
		},
		execute: function()
		{
			if (this._dialog)
			{
				this._dialog.close();
				this._dialog = null;
			}	
			var me = this;
			this._dialog = new ibm.tivoli.fwm.mxmap.panels.MobileInfoPanelDialog({map: me.map});
			this._dialog.show();
		},
		disable: function()
		{
		},
		destroy: function()
		{
			this.destroyRecursive();
		}
});

});

},
'dijit/main':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/kernel"
], function(dojo){
	// module:
	//		dijit/main

/*=====
return {
	// summary:
	//		The dijit package main module.
	//		Deprecated.   Users should access individual modules (ex: dijit/registry) directly.
};
=====*/

	return dojo.dijit;
});

},
'ibm/tivoli/fwm/mxmap/_Marker':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */




define(["dojo/main", "dijit/main", "dojox/main","dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/_Base"], 
	function(dojo, dijit, dojox, declare, _Base) {
	return declare([_Base], {

		api: null,
		location: null,
		onmap: false,
		proprietary_marker: false,
		attributes: null,
		// If this marker is a "Multi Marker", this property will hold the other
		// markers that are part of the multi marker.
		referencedMarkers: null,
		infoBubbleOpen: false,

		/**
		 * Marker create's a new marker pin
		 * 
		 * @name mxn.Marker
		 * @constructor
		 * @param {LatLonPoint}
		 *            point the point on the map where the marker should go
		 */
		constructor: function(params)
		{
			this.attributes = [];
			this.referencedMarkers = [];
			dojo.mixin(this, params);
			this.location = params.point;
		},

		/**
		 * Retrieve the settings from a proprietary marker.
		 * 
		 * @name mxn.Marker#fromProprietary
		 * @function
		 * @param {String}
		 *            apiId The API ID of the proprietary point.
		 * @param {Object}
		 *            marker The proprietary marker.
		 */
		fromProprietary: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		/**
		 * Hide the marker.
		 * 
		 * @name mxn.Marker#hide
		 * @function
		 */
		hide: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		/**
		 * Remove the marker.
		 * 
		 * @name mxn.Marker#remove
		 * @function
		 */
		remove: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		/**
		 * Open the marker's info bubble.
		 * 
		 * @name mxn.Marker#openBubble
		 * @function
		 */
		openBubble: function()
		{
			this.infoBubbleOpen = true;
		},

		/**
		 * Closes the marker's info bubble.
		 * 
		 * @name mxn.Marker#closeBubble
		 * @function
		 */
		closeBubble: function()
		{
			this.infoBubbleOpen = false;
		},

		closeBubbleIfNecessary: function()
		{
			if(this.infoBubbleOpen == true)
			{
				this.infoBubbleOpen = false;
				this.closeBubble();
				this._sendCloseBubbleEventIfNecessary();
			}
		},

		/**
		 * Show the marker.
		 * 
		 * @name mxn.Marker#show
		 * @function
		 */
		show: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		/**
		 * Converts the current Marker to a proprietary one for the API specified by
		 * apiId.
		 * 
		 * @name mxn.Marker#toProprietary
		 * @function
		 * @param {String}
		 *            apiId The API ID of the proprietary marker.
		 * @returns A proprietary marker.
		 */
		toProprietary: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		/**
		 * Updates the Marker with the location of the attached proprietary marker
		 * on the map.
		 * 
		 * @name mxn.Marker#update
		 * @function
		 */
		update: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		setChild: function(some_proprietary_marker)
		{
			this.proprietary_marker = some_proprietary_marker;
			some_proprietary_marker.mxmapMarker = this;
			this.onmap = true;
		},

		setLabel: function(labelText)
		{
			this.labelText = labelText;
		},
		setTooltip: function(labelText)
		{
			this.tooltip = labelText;
		},
		showTooltip: function(screenPoint, mapDom)
		{
			if (this.tooltip && this.tooltip.length > 0)
			{
				var topPx = screenPoint.y + "px";
				var leftPx = screenPoint.x + "px";
				var dom = dojo.create("div", {
					style: {
						position: "absolute",
						top: topPx,
						left: leftPx					
					}
				}, mapDom);
				var rtl=false;
				var mapRtl=dojo.style(mapDom,'directions');
				if(document.body.dir=='rtl' && mapRtl!='ltr'){
					rtl=true;
				}

				dijit.showTooltip(this.tooltip, dom,['after'],rtl);
				this._tooltipDom = dom;
			}
		},
		hideTooltip: function()
		{
			dijit.hideTooltip(this._tooltipDom);
		},
		/**
		 * addData conviniently set a hash of options on a marker
		 * 
		 * @param {Object}
		 *            options An object literal hash of key value pairs. Keys are:
		 *            label, infoBubble, icon, iconShadow, infoDiv, draggable,
		 *            hover, hoverIcon, openBubble, groupName.
		 */
		addData: function(options)
		{
			for (var sOptKey in options)
			{
				if (options.hasOwnProperty(sOptKey))
				{
					switch (sOptKey)
					{
					case 'label':
						this.setLabel(options.label);
						break;
					case 'tooltip':
						this.setTooltip(options.tooltip);
						break;
					case 'infoBubble':
						this.setInfoBubble(options.infoBubble);
						break;
					case 'icon':
						if (options.iconSize && options.iconAnchor)
						{
							this.setIcon(options.icon, options.iconSize, options.iconAnchor);
						}
						else if (options.iconSize)
						{
							this.setIcon(options.icon, options.iconSize);
						}
						else
						{
							this.setIcon(options.icon);
						}
						break;
					case 'iconShadow':
						if (options.iconShadowSize)
						{
							this.setShadowIcon(options.iconShadow, [ options.iconShadowSize[0], options.iconShadowSize[1] ]);
						}
						else
						{
							this.setIcon(options.iconShadow);
						}
						break;
					case 'infoDiv':
						this.setInfoDiv(options.infoDiv[0], options.infoDiv[1]);
						break;
					case 'draggable':
						this.setDraggable(options.draggable);
						break;
					case 'hover':
						this.setHover(options.hover);
						this.setHoverIcon(options.hoverIcon);
						break;
					case 'hoverIcon':
						this.setHoverIcon(options.hoverIcon);
						break;
					case 'openBubble':
						this.openBubble();
						break;
					case 'closeBubble':
						this.closeBubble();
						break;
					default:
						// don't have a specific action for this bit of
						// data so set a named attribute
						this.setAttribute(sOptKey, options[sOptKey]);
					break;
					}
				}
			}
		},

		/**
		 * Sets the html/text content for a bubble popup for a marker
		 * 
		 * @param {String}
		 *            infoBubble the html/text you want displayed
		 */
		setInfoBubble: function(infoBubble)
		{
			this.infoBubble = infoBubble;
		},

		/**
		 * Sets the text and the id of the div element where to the information
		 * useful for putting information in a div outside of the map
		 * 
		 * @param {String}
		 *            infoDiv the html/text you want displayed
		 * @param {String}
		 *            div the element id to use for displaying the text/html
		 */
		setInfoDiv: function(infoDiv, div)
		{
			this.infoDiv = infoDiv;
			this.div = div;
		},

		/**
		 * Sets the icon for a marker
		 * 
		 * @param {String}
		 *            iconUrl The URL of the image you want to be the icon
		 */
		setIcon: function(iconUrl, iconSize, iconAnchor)
		{
			this.iconUrl = iconUrl;
			if (iconSize)
			{
				this.iconSize = iconSize;
			}
			if (iconAnchor)
			{
				this.iconAnchor = iconAnchor;
			}
		},

		/**
		 * Sets the icon for a marker
		 * 
		 * @param {String}
		 *            iconUrl The URL of the image you want to be the icon
		 */
		setShadowIcon: function(iconShadowUrl, iconShadowSize)
		{
			this.iconShadowUrl = iconShadowUrl;
			if (iconShadowSize)
			{
				this.iconShadowSize = iconShadowSize;
			}
		},

		setHoverIcon: function(hoverIconUrl)
		{
			this.hoverIconUrl = hoverIconUrl;
		},

		/**
		 * Sets the draggable state of the marker
		 * 
		 * @param {Bool}
		 *            draggable set to true if marker should be draggable by the
		 *            user
		 */
		setDraggable: function(draggable)
		{
			this.draggable = draggable;
		},

		/**
		 * Sets that the marker info is displayed on hover
		 * 
		 * @param {Boolean}
		 *            hover set to true if marker should display info on hover
		 */
		setHover: function(hover)
		{
			this.hover = hover;
		},

		/**
		 * Set an arbitrary key/value pair on a marker
		 * 
		 * @param {String}
		 *            key
		 * @param value
		 */
		setAttribute: function(key, value)
		{
			this.attributes[key] = value;
		},

		/**
		 * getAttribute: gets the value of "key"
		 * 
		 * @param {String}
		 *            key
		 * @returns value
		 */
		getAttribute: function(key)
		{
			return this.attributes[key];
		},

		addMarkerEventHandler: function(event, handler)
		{
			this.addSubscription('marker_' + event + '_' + this.compId, handler);
		},
		removeMarkerEventHandler: function(event, handler)
		{
			this.removeSubscription('marker_' + event + '_' + this.compId, handler);
		},
		fireMarkerEvent: function(event, data)
		{
			dojo.publish('marker_' + event + '_' + this.compId, data);
		},
		getTooltip: function()
		{
			return this.tooltip;
		},
		hasReferencedMarkers: function()
		{
			return ((this.referencedMarkers != null) && (this.referencedMarkers != undefined) && (this.referencedMarkers.length > 0)) ? true : false;
		},
		// If this marker is a "Multi Marker", there will be other markers at the same spot
		// as this one. Those markers are the referenced markers.
		addReferencedMarker: function(marker)
		{
			if((marker != null) && (marker != undefined))
			{
				if(this._isReferencedMarkerNew(marker) == true)
				{
					this.referencedMarkers.push(marker);
				}
			}
		},
		clearReferencedMarkers: function()
		{
			this.referencedMarkers = [];
		},
		getReferencedMarkers: function()
		{
			return this.referencedMarkers;
		},

		_isReferencedMarkerNew: function(marker)
		{
			for(var i=0; i<this.referencedMarkers.length; i++)
			{
				if(marker == this.referencedMarkers[i])
				{
					return false;
				}
			}
			return true;
		},
		// Only necessary for google because it's info window is the only one that is proprietary and the only
		// way to trigger closing bubble events is by clicking on the X button 
		// For other providers, the closing of the infoWindow object triggers the necessary events, even
		// if someone else (besides clicking on the X button) closes it
		_sendCloseBubbleEventIfNecessary: function() {},

		// The activity ID (if it exists) can be either a property or an array,
		// so this method return it (or them) as an array
		// This method is used only by DispatcherManager
		getActivityIdArray: function()
		{
			var activityId = this.getAttribute("activityId");
			if(activityId != null && activityId != undefined)
			{
				if (activityId instanceof Array)
				{
					return activityId;
				}
				else
				{
					return [activityId];
				}
			}
			return null;
		},

		// Checks whether whether the "id" exists in the marker's activityId array
		// This method is used only by DispatcherManager
		hasActivityId: function(id)
		{
			var foundExistingActivityId = false;
			var activityIdArray = this.getActivityIdArray();
			if(activityIdArray != null)
			{
				dojo.forEach(activityIdArray, function(activityId)
						{
					if(activityId == id)
					{
						foundExistingActivityId = true;
					}
						});
			}
			return foundExistingActivityId;
		},

		MarkerEvents:
		{
			openInfoBubble: 'openInfoBubble', // Info bubble opened
			closeInfoBubble: 'closeInfoBubble', // Info bubble closed
			dragstart: 'dragstart', // when the marker starts to be dragged
			drag: 'drag', // while the marker is being dragged
			dragend: 'dragend', // when the marker ends to be dragged
			click: 'click' // Marker clicked
		}

	});
});

},
'ibm/tivoli/fwm/mxmap/geolocation/MyCurrentLocation':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

/**
 * This implements the control of monitoring user current location. It always
 * uses the watchposition method. It demanded a small tweak for Firefox because
 * mozilla ALWAYS throws a timeout error after the timeout has been achieved
 * EVEN if a location was found before the timeout and stops watching the
 * location.
 * 
 * We have opened an issue for mozilla:
 * https://bugzilla.mozilla.org/show_bug.cgi?id=732923
 * 
 * In order to avoid this, when we are in firefox we set a high timeout (10
 * minutes) so during 10 minutes FF keeps monitoring correctly the user
 * location. If the 10 minutes is achieved but we had a location found during
 * the timeout period, we just restart the watch position again. On the first
 * time though, we need to timeout after the regular timeout period. So we force
 * a check after the regular timeout to see if firefox has found a location. If
 * not we trigger the regular error, else we just keep monitoring.
 * 
 */
define(["dojo/_base/declare", "dojo/main", "dijit/main",
	"ibm/tivoli/fwm/mxmap/_Base"], function(declare, dojo, dijit, _Base) {

	if (!ibm.tivoli.fwm.mxmap.geolocation) {
		ibm.tivoli.fwm.mxmap.geolocation = {};
	}
	ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus = {
		UNASSIGNED: -1,
		HAS_LOCATION: 0,
		PERMISSION_DENIED: 1,
		POSITION_UNAVAILABLE: 2,
		GEOLOCATION_NOT_SUPPORTED: 4,
		TIMEOUT: 3
	};
		
	return {
		/**
		 * Provides access to current location data.<br>
		 */
		_instance: null,
		
		/**
		 * Retrieves the MyCurrentLocation singleton instance
		 */
		getMyCurrentLocationInstance: function()
		{
			if (!this._instance)
			{
				this._instance = new this.MyCurrentLocation();
			}
			return this._instance;
		},
		
		MyCurrentLocation: declare([_Base], {
			_userLocation: null,
			_userLocationStatus: ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.UNASSIGNED,
			// Time to wait for a response from the geolocation API
			_timeout: 5000,
			_watchPositionId: null,
			_waitingForTimeout: false,
			_callbackArray: null,
			_listenerArray: null,
			constructor: function(params)
			{
				dojo.mixin(this, params);
				console.log("MyCurrentLocation created at ", new Date());
				this._callbackArray = [];
				this._listenerArray = [];
				this._h = 0;

				if (dojo.isMozilla)
				{
					console.log("Firefox");
					this._oldTimeout = this._timeout;
					this._timeout = 10 * 60000;
				}

			},
			/**
			 * Retrieves the current position data
			 */
			getPosition: function()
			{
				return this._userLocation;
			},
			/**
			 * Retrieves the current status (or error code)
			 */
			getStatus: function()
			{
				return this._userLocationStatus;
			},
			/**
			 * callback response for current user location
			 * 
			 * @param position
			 * @param callback
			 */
			_lastLocationTimestamp: 0,
			gotUserLocation: function(position)
			{
				this._userLocation = position;
				this._userLocationStatus = ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.HAS_LOCATION;
				this._lastLocationTimestamp = new Date().getTime();

				if (this._listenerArray)
				{
					for ( var handler in this._listenerArray)
					{
						var fct = this._listenerArray[handler];
						fct.success(position);
					}

				}
				if (this._callbackArray)
				{
					while (this._callbackArray.length > 0)
					{
						var fctErr = this._callbackArray.pop();
						fctErr.success(position);
					}
				}

				this._callbackArray = [];

			},
			/**
			 * If we failed to retrieve user location. The possible errors are:<br>
			 * code 1 - Permission denied, user did not allow to share his location<br>
			 * code 2 - Position unavailable, the position of the device could not be
			 * determined<br>
			 * code 3 - Timeout, device took too long (longer than the timeout
			 * specified) to return current location<br>
			 * code 4 - Geolocation not supported, this device does not support
			 * geolocation, this is a custom error code<br>
			 * 
			 * @see http://dev.w3.org/geo/api/spec-source.html#permission_denied_error
			 * @param error:
			 *            {code,message}
			 * @param callback
			 *            error function
			 */
			failedToGetLocation: function(error)
			{
				console.warn("Error finding user location", error);
				this._userLocationStatus = error.code;
				if (this._listenerArray)
				{
					for ( var handler in this._listenerArray)
					{

						var fct = this._listenerArray[handler];
						fct.failure(error);
					}

				}
				// Execute all buffered error callbacks
				if (this._callbackArray)
				{
					while (this._callbackArray.length > 0)
					{
						var fctErr = this._callbackArray.pop();
						fctErr.failure(error);
					}
				}

				this._callbackArray = [];
			},
			_isWaitingForTimeout: function()
			{
				var now = new Date();
				if (now.getTime() < (this._lastGetLocCall + this._timeout))
				{
					return true;
				}
				else
				{
					return false;
				}
			},
			_lastGetLocCall: 0,
			/**
			 * Tries to get the device location thru the w3c Geolocation API.<br>
			 * It has a timeout of 10 seconds and if device does not support geolocation
			 * it returns an error code 4. If watchPosition is enabled, just return the
			 * last location.
			 * 
			 * @see http://dev.w3.org/geo/api/spec-source.html
			 * @param callback
			 * @param errorCb
			 */
			getUserLocation: function(callback, errorCb)
			{
				if (this._watchPositionId != null && this.isStatusHasLocation())

				{
					// If Watch Position is enabled, return the current position, if it
					// exists
					// If it does not exist, it means that the watchPosition API was
					// unable to retrieve it
					callback(this._userLocation);
				}
				else
				{
					this._callbackArray.push({
						success: callback,
						failure: errorCb
					});
					this.watchUserLocation();
				}
			},
			/**
			 * Adds the success and error callback functions to a buffer and returns
			 * a handler so these callback functions can be removed later when
			 * the tool is no longer in used by the caller
			 * 
			 * @param callback
			 * @param errorCb
			 */
			// 12-13674. We need to create the listener prior to calling watchUserLocation on myCurrentLocationInstance
			// because some errors may happen synchronously. When an error happens during the listenToUserLocation() call,
			// the error callback is executed before the handler is returned, so the myCurrentLocationInstance.removeListeners
			// tries to remove the listener using a handler that does not exist yet.
			_h: null,
			createListener: function(callback, errorCb)
			{
				this._h++;
				var h = this._h;
				this._listenerArray[h] = {
					success: callback,
					failure: errorCb
				};
				return h;
			},

			/**
			 * Tries to get the device location thru the w3c Geolocation API.<br>
			 * It has a timeout of 10 seconds and if device does not support geolocation
			 * it returns an error code 4. Once active, the callback function will fire
			 * whenever a location change is noticed by the browser.
			 * 
			 * @see http://dev.w3.org/geo/api/spec-source.html
			 */
			listenToUserLocation: function(handler)
			{
				if(this._listenerArray[handler] != null)
				{
					this.watchUserLocation();
				}
				else
				{
					console.warn("No listener for handler ", handler);
				}
			},
			removeListeners: function(handler)
			{
				if(handler != null)
				{
					this._listenerArray[handler] = null;
					delete this._listenerArray[handler];
				}
			},
			watchUserLocation: function()
			{

				if (navigator.geolocation)
				{
					if (this._watchPositionId == null)
					{

						var fctSuccess = function(position)
						{
							console.log("got location", position);
							this.gotUserLocation(position);
							if (this._mozzilaTS)
							{
								clearTimeout(this._mozzilaTS);
							}
						};
						var fctErr = function(error)
						{
							this.clearWatchUserLocation();
							if (error.code == error.TIMEOUT && dojo.isMozilla && this.isStatusHasLocation() == true)
							{
								console.log("last timestamp", this._lastLocationTimestamp);
								var now = new Date();
								var elapsedTime = (now.getTime() - this._requestTimestamp.getTime());
								if (elapsedTime < (this._timeout + 5000) || elapsedTime > (this._timeout - 5000))
								{
									// probabily due mozilla accurate implementation
									console.log("skipping first timeout error due mozilla accurate implementation");
									
									this.watchUserLocation();
									return;
								}
							}					
							this.failedToGetLocation(error);
						};
						this._requestTimestamp = new Date();

						this._watchPositionId = navigator.geolocation.watchPosition(dojo.hitch(this, fctSuccess), dojo.hitch(this, fctErr), {
							timeout: this._timeout
						});
						if (dojo.isMozilla)
						{// we need to manually add the timeout for the first time.
							// Due firefox issue
							if (this.isStatusUnassigned() == true)
							{
								var ffMozilla = dojo.hitch(this, function()
								{
									console.log("first try in Mozilla to get location");
									this.clearWatchUserLocation();
									var error = {
										TIMEOUT: true,
										code: ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.TIMEOUT,
										message: "Browser FF timeout"
									};
									this.clearWatchUserLocation();
									this.failedToGetLocation(error);
								});
								this._mozzilaTS = setTimeout(ffMozilla, this._oldTimeout);
							}
						}
					}
					else
					{
						console.warn("Watch Position is already enabled");
						if (this.isStatusHasLocation() == true)
						{// show last postion
							this.gotUserLocation(this._userLocation);
						}
						else
						{
							if (this.isStatusUnassigned() != true)
							{
								var error = {
									code: this.getStatus(),
									message: "Failed"
								};
								this.clearWatchUserLocation();
								this.failedToGetLocation(error);
							}
						}
					}
				}
				else
				{
					console.warn("no geolocation support");
					this._userLocationStatus = ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.GEOLOCATION_NOT_SUPPORTED;
					var error = {
						code: ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.GEOLOCATION_NOT_SUPPORTED,
						message: "Browser does not support geolocation"
					};			
					this.failedToGetLocation(error);
				}

			},
			/**
			 * Disables the watchPosition and sets _watchPositionId to null
			 * 
			 * @see http://dev.w3.org/geo/api/spec-source.html
			 */

			clearWatchUserLocation: function()
			{
				if (this._watchPositionId != null)
				{
					if (navigator.geolocation)
					{
						navigator.geolocation.clearWatch(this._watchPositionId);
						this._watchPositionId = null;
					}
				}
				else
				{
					console.log("Watch Position is already disabled.");
				}
			},

			/**
			 * Returns true if _userLocationStatus = UNASSIGNED
			 */
			isStatusUnassigned: function()
			{
				return this.isStatusEqual(ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.UNASSIGNED);
			},
			/**
			 * Returns true if _userLocationStatus = HAS_LOCATION
			 */
			isStatusHasLocation: function()
			{
				return this.isStatusEqual(ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.HAS_LOCATION);
			},
			/**
			 * Returns true if _userLocationStatus = locStatus
			 */
			isStatusEqual: function(locStatus)
			{
				return (this._userLocationStatus == locStatus);
			},
			convertPositionToMapPoint: function(map, callback, errorCb)
			{
				var position = this.getPosition();
				var latLng = map.latLng(position.coords.latitude, position.coords.longitude);
				map.getAllPointsFromWGS84([ latLng ], dojo.hitch(this, function(points)
				{
					callback(points[0]);
				}));
			}
		})
	}
	
});






},
'dojo/json5/parse':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	'../string',
	'./util'
], function (dstring, util) {
	var source;
	var parseState;
	var stack;
	var pos;
	var line;
	var column;
	var token;
	var key;
	var root;

	function parse(text, reviver) {
		source = String(text);
		parseState = 'start';
		stack = [];
		pos = 0;
		line = 1;
		column = 0;
		token = undefined;
		key = undefined;
		root = undefined;
		do {
			token = lex();
			parseStates[parseState]();
		} while (token.type !== 'eof');
		if (typeof reviver === 'function') {
			return internalize({ '': root }, '', reviver);
		}
		return root;
	}
	function internalize(holder, name, reviver) {
		var value = holder[name];
		if (value != null && typeof value === 'object') {
			for (var key_1 in value) {
				var replacement = internalize(value, key_1, reviver);
				if (replacement === undefined) {
					delete value[key_1];
				}
				else {
					value[key_1] = replacement;
				}
			}
		}
		return reviver.call(holder, name, value);
	}
	var lexState;
	var buffer;
	var doubleQuote;
	var sign;
	var c;
	function lex() {
		lexState = 'default';
		buffer = '';
		doubleQuote = false;
		sign = 1;
		for (;;) {
			c = peek();
			var token_1 = lexStates[lexState]();
			if (token_1) {
				return token_1;
			}
		}
	}
	function peek() {
		if (source[pos]) {
			return dstring.fromCodePoint(dstring.codePointAt(source, pos));
		}
	}
	function read() {
		var c = peek();
		if (c === '\n') {
			line++;
			column = 0;
		}
		else if (c) {
			column += c.length;
		}
		else {
			column++;
		}
		if (c) {
			pos += c.length;
		}
		return c;
	}
	var lexStates = {
		'default': function () {
			switch (c) {
				case '\t':
				case '\v':
				case '\f':
				case ' ':
				case '\u00A0':
				case '\uFEFF':
				case '\n':
				case '\r':
				case '\u2028':
				case '\u2029':
					read();
					return;
				case '/':
					read();
					lexState = 'comment';
					return;
				case undefined:
					read();
					return newToken('eof');
			}
			if (util.isSpaceSeparator(c)) {
				read();
				return;
			}
			return lexStates[parseState]();
		},
		comment: function () {
			switch (c) {
				case '*':
					read();
					lexState = 'multiLineComment';
					return;
				case '/':
					read();
					lexState = 'singleLineComment';
					return;
			}
			throw invalidChar(read());
		},
		multiLineComment: function () {
			switch (c) {
				case '*':
					read();
					lexState = 'multiLineCommentAsterisk';
					return;
				case undefined:
					throw invalidChar(read());
			}
			read();
		},
		multiLineCommentAsterisk: function () {
			switch (c) {
				case '*':
					read();
					return;
				case '/':
					read();
					lexState = 'default';
					return;
				case undefined:
					throw invalidChar(read());
			}
			read();
			lexState = 'multiLineComment';
		},
		singleLineComment: function () {
			switch (c) {
				case '\n':
				case '\r':
				case '\u2028':
				case '\u2029':
					read();
					lexState = 'default';
					return;
				case undefined:
					read();
					return newToken('eof');
			}
			read();
		},
		value: function () {
			switch (c) {
				case '{':
				case '[':
					return newToken('punctuator', read());
				case 'n':
					read();
					literal('ull');
					return newToken('null', null);
				case 't':
					read();
					literal('rue');
					return newToken('boolean', true);
				case 'f':
					read();
					literal('alse');
					return newToken('boolean', false);
				case '-':
				case '+':
					if (read() === '-') {
						sign = -1;
					}
					lexState = 'sign';
					return;
				case '.':
					buffer = read();
					lexState = 'decimalPointLeading';
					return;
				case '0':
					buffer = read();
					lexState = 'zero';
					return;
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					buffer = read();
					lexState = 'decimalInteger';
					return;
				case 'I':
					read();
					literal('nfinity');
					return newToken('numeric', Infinity);
				case 'N':
					read();
					literal('aN');
					return newToken('numeric', NaN);
				case '"':
				case "'":
					doubleQuote = (read() === '"');
					buffer = '';
					lexState = 'string';
					return;
			}
			throw invalidChar(read());
		},
		identifierNameStartEscape: function () {
			if (c !== 'u') {
				throw invalidChar(read());
			}
			read();
			var u = unicodeEscape();
			switch (u) {
				case '$':
				case '_':
					break;
				default:
					if (!util.isIdStartChar(u)) {
						throw invalidIdentifier();
					}
					break;
			}
			buffer += u;
			lexState = 'identifierName';
		},
		identifierName: function () {
			switch (c) {
				case '$':
				case '_':
				case '\u200C':
				case '\u200D':
					buffer += read();
					return;
				case '\\':
					read();
					lexState = 'identifierNameEscape';
					return;
			}
			if (util.isIdContinueChar(c)) {
				buffer += read();
				return;
			}
			return newToken('identifier', buffer);
		},
		identifierNameEscape: function () {
			if (c !== 'u') {
				throw invalidChar(read());
			}
			read();
			var u = unicodeEscape();
			switch (u) {
				case '$':
				case '_':
				case '\u200C':
				case '\u200D':
					break;
				default:
					if (!util.isIdContinueChar(u)) {
						throw invalidIdentifier();
					}
					break;
			}
			buffer += u;
			lexState = 'identifierName';
		},
		sign: function () {
			switch (c) {
				case '.':
					buffer = read();
					lexState = 'decimalPointLeading';
					return;
				case '0':
					buffer = read();
					lexState = 'zero';
					return;
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					buffer = read();
					lexState = 'decimalInteger';
					return;
				case 'I':
					read();
					literal('nfinity');
					return newToken('numeric', sign * Infinity);
				case 'N':
					read();
					literal('aN');
					return newToken('numeric', NaN);
			}
			throw invalidChar(read());
		},
		zero: function () {
			switch (c) {
				case '.':
					buffer += read();
					lexState = 'decimalPoint';
					return;
				case 'e':
				case 'E':
					buffer += read();
					lexState = 'decimalExponent';
					return;
				case 'x':
				case 'X':
					buffer += read();
					lexState = 'hexadecimal';
					return;
			}
			return newToken('numeric', sign * 0);
		},
		decimalInteger: function () {
			switch (c) {
				case '.':
					buffer += read();
					lexState = 'decimalPoint';
					return;
				case 'e':
				case 'E':
					buffer += read();
					lexState = 'decimalExponent';
					return;
			}
			if (util.isDigit(c)) {
				buffer += read();
				return;
			}
			return newToken('numeric', sign * Number(buffer));
		},
		decimalPointLeading: function () {
			if (util.isDigit(c)) {
				buffer += read();
				lexState = 'decimalFraction';
				return;
			}
			throw invalidChar(read());
		},
		decimalPoint: function () {
			switch (c) {
				case 'e':
				case 'E':
					buffer += read();
					lexState = 'decimalExponent';
					return;
			}
			if (util.isDigit(c)) {
				buffer += read();
				lexState = 'decimalFraction';
				return;
			}
			return newToken('numeric', sign * Number(buffer));
		},
		decimalFraction: function () {
			switch (c) {
				case 'e':
				case 'E':
					buffer += read();
					lexState = 'decimalExponent';
					return;
			}
			if (util.isDigit(c)) {
				buffer += read();
				return;
			}
			return newToken('numeric', sign * Number(buffer));
		},
		decimalExponent: function () {
			switch (c) {
				case '+':
				case '-':
					buffer += read();
					lexState = 'decimalExponentSign';
					return;
			}
			if (util.isDigit(c)) {
				buffer += read();
				lexState = 'decimalExponentInteger';
				return;
			}
			throw invalidChar(read());
		},
		decimalExponentSign: function () {
			if (util.isDigit(c)) {
				buffer += read();
				lexState = 'decimalExponentInteger';
				return;
			}
			throw invalidChar(read());
		},
		decimalExponentInteger: function () {
			if (util.isDigit(c)) {
				buffer += read();
				return;
			}
			return newToken('numeric', sign * Number(buffer));
		},
		hexadecimal: function () {
			if (util.isHexDigit(c)) {
				buffer += read();
				lexState = 'hexadecimalInteger';
				return;
			}
			throw invalidChar(read());
		},
		hexadecimalInteger: function () {
			if (util.isHexDigit(c)) {
				buffer += read();
				return;
			}
			return newToken('numeric', sign * Number(buffer));
		},
		string: function () {
			switch (c) {
				case '\\':
					read();
					buffer += escape();
					return;
				case '"':
					if (doubleQuote) {
						read();
						return newToken('string', buffer);
					}
					buffer += read();
					return;
				case "'":
					if (!doubleQuote) {
						read();
						return newToken('string', buffer);
					}
					buffer += read();
					return;
				case '\n':
				case '\r':
					throw invalidChar(read());
				case '\u2028':
				case '\u2029':
					separatorChar(c);
					break;
				case undefined:
					throw invalidChar(read());
			}
			buffer += read();
		},
		start: function () {
			switch (c) {
				case '{':
				case '[':
					return newToken('punctuator', read());
			}
			lexState = 'value';
		},
		beforePropertyName: function () {
			switch (c) {
				case '$':
				case '_':
					buffer = read();
					lexState = 'identifierName';
					return;
				case '\\':
					read();
					lexState = 'identifierNameStartEscape';
					return;
				case '}':
					return newToken('punctuator', read());
				case '"':
				case "'":
					doubleQuote = (read() === '"');
					lexState = 'string';
					return;
			}
			if (util.isIdStartChar(c)) {
				buffer += read();
				lexState = 'identifierName';
				return;
			}
			throw invalidChar(read());
		},
		afterPropertyName: function () {
			if (c === ':') {
				return newToken('punctuator', read());
			}
			throw invalidChar(read());
		},
		beforePropertyValue: function () {
			lexState = 'value';
		},
		afterPropertyValue: function () {
			switch (c) {
				case ',':
				case '}':
					return newToken('punctuator', read());
			}
			throw invalidChar(read());
		},
		beforeArrayValue: function () {
			if (c === ']') {
				return newToken('punctuator', read());
			}
			lexState = 'value';
		},
		afterArrayValue: function () {
			switch (c) {
				case ',':
				case ']':
					return newToken('punctuator', read());
			}
			throw invalidChar(read());
		},
		end: function () {
			throw invalidChar(read());
		}
	};
	function newToken(type, value) {
		return {
			type: type,
			value: value,
			line: line,
			column: column
		};
	}
	function literal(s) {
		for (var _i = 0, s_1 = s; _i < s_1.length; _i++) {
			var c_1 = s_1[_i];
			var p = peek();
			if (p !== c_1) {
				throw invalidChar(read());
			}
			read();
		}
	}
	function escape() {
		var c = peek();
		switch (c) {
			case 'b':
				read();
				return '\b';
			case 'f':
				read();
				return '\f';
			case 'n':
				read();
				return '\n';
			case 'r':
				read();
				return '\r';
			case 't':
				read();
				return '\t';
			case 'v':
				read();
				return '\v';
			case '0':
				read();
				if (util.isDigit(peek())) {
					throw invalidChar(read());
				}
				return '\0';
			case 'x':
				read();
				return hexEscape();
			case 'u':
				read();
				return unicodeEscape();
			case '\n':
			case '\u2028':
			case '\u2029':
				read();
				return '';
			case '\r':
				read();
				if (peek() === '\n') {
					read();
				}
				return '';
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				throw invalidChar(read());
			case undefined:
				throw invalidChar(read());
		}
		return read();
	}
	function hexEscape() {
		var buffer = '';
		var c = peek();
		if (!util.isHexDigit(c)) {
			throw invalidChar(read());
		}
		buffer += read();
		c = peek();
		if (!util.isHexDigit(c)) {
			throw invalidChar(read());
		}
		buffer += read();
		return dstring.fromCodePoint(parseInt(buffer, 16));
	}
	function unicodeEscape() {
		var buffer = '';
		var count = 4;
		while (count-- > 0) {
			var c_2 = peek();
			if (!util.isHexDigit(c_2)) {
				throw invalidChar(read());
			}
			buffer += read();
		}
		return dstring.fromCodePoint(parseInt(buffer, 16));
	}
	var parseStates = {
		start: function () {
			if (token.type === 'eof') {
				throw invalidEOF();
			}
			push();
		},
		beforePropertyName: function () {
			switch (token.type) {
				case 'identifier':
				case 'string':
					key = token.value;
					parseState = 'afterPropertyName';
					return;
				case 'punctuator':
					pop();
					return;
				case 'eof':
					throw invalidEOF();
			}
		},
		afterPropertyName: function () {
			if (token.type === 'eof') {
				throw invalidEOF();
			}
			parseState = 'beforePropertyValue';
		},
		beforePropertyValue: function () {
			if (token.type === 'eof') {
				throw invalidEOF();
			}
			push();
		},
		beforeArrayValue: function () {
			if (token.type === 'eof') {
				throw invalidEOF();
			}
			if (token.type === 'punctuator' && token.value === ']') {
				pop();
				return;
			}
			push();
		},
		afterPropertyValue: function () {
			if (token.type === 'eof') {
				throw invalidEOF();
			}
			switch (token.value) {
				case ',':
					parseState = 'beforePropertyName';
					return;
				case '}':
					pop();
			}
		},
		afterArrayValue: function () {
			if (token.type === 'eof') {
				throw invalidEOF();
			}
			switch (token.value) {
				case ',':
					parseState = 'beforeArrayValue';
					return;
				case ']':
					pop();
			}
		},
		end: function () {
		}
	};
	function push() {
		var value;
		switch (token.type) {
			case 'punctuator':
				switch (token.value) {
					case '{':
						value = {};
						break;
					case '[':
						value = [];
						break;
				}
				break;
			case 'null':
			case 'boolean':
			case 'numeric':
			case 'string':
				value = token.value;
				break;
		}
		if (root === undefined) {
			root = value;
		}
		else {
			var parent_1 = stack[stack.length - 1];
			if (Array.isArray(parent_1)) {
				parent_1.push(value);
			}
			else {
				parent_1[key] = value;
			}
		}
		if (value !== null && typeof value === 'object') {
			stack.push(value);
			if (Array.isArray(value)) {
				parseState = 'beforeArrayValue';
			}
			else {
				parseState = 'beforePropertyName';
			}
		}
		else {
			var current = stack[stack.length - 1];
			if (current == null) {
				parseState = 'end';
			}
			else if (Array.isArray(current)) {
				parseState = 'afterArrayValue';
			}
			else {
				parseState = 'afterPropertyValue';
			}
		}
	}
	function pop() {
		stack.pop();
		var current = stack[stack.length - 1];
		if (current == null) {
			parseState = 'end';
		}
		else if (Array.isArray(current)) {
			parseState = 'afterArrayValue';
		}
		else {
			parseState = 'afterPropertyValue';
		}
	}
	function invalidChar(c) {
		if (c === undefined) {
			return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
		}
		return syntaxError("JSON5: invalid character '" + formatChar(c) + "' at " + line + ":" + column);
	}
	function invalidEOF() {
		return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
	}
	function invalidIdentifier() {
		column -= 5;
		return syntaxError("JSON5: invalid identifier character at " + line + ":" + column);
	}
	function separatorChar(c) {
		console.warn("JSON5: '" + formatChar(c) + "' in strings is not valid ECMAScript; consider escaping");
	}
	function formatChar(c) {
		var replacements = {
			"'": "\\'",
			'"': '\\"',
			'\\': '\\\\',
			'\b': '\\b',
			'\f': '\\f',
			'\n': '\\n',
			'\r': '\\r',
			'\t': '\\t',
			'\v': '\\v',
			'\0': '\\0',
			'\u2028': '\\u2028',
			'\u2029': '\\u2029'
		};
		if (replacements[c]) {
			return replacements[c];
		}
		if (c < ' ') {
			var hexString = c.charCodeAt(0).toString(16);
			return '\\x' + ('00' + hexString).substring(hexString.length);
		}
		return c;
	}
	function syntaxError(message) {
		var err = new SyntaxError(message);
		err.lineNumber = line;
		err.columnNumber = column;
		return err;
	}

	return parse;
});

},
'ibm/tivoli/fwm/mxmap/layers/SymbologyLayer':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/_base/declare", "ibm/tivoli/fwm/mxmap/layers/Layer"], function(declare, Layer) {
	/**
	 * Represents a map symbology
	 * 
	 * The constructor receive the following parameters:
	 * 
	 * {layerName: a string e.g.: "Status",
	 *  parentLayer: the layer that is creating this layer,
	 * }
	 */
	return declare([Layer], {
		symbologyType: null,
		_defaultSymbology: null,
		/**
		 * Disables all the other sibling symbologies
		 */
		_disableSiblings: function()
		{
			var siblings = this.getSiblings();
			dojo.forEach(siblings, function(sibling){
				sibling.disable();
			});
		},
		/**
		 * Enables this symbology layer, executes the action that configures the markers for this symbology
		 * and disables all the other sibling symbologies
		 * (but do not redraw markers)
		 */
		toggleStateButDontRedrawMarkers: function()
		{
			this._disableSiblings();
			this.enableButDontRedrawMarkers();
		},
		/**
		 * Enables this symbology layer, executes the action that configures the markers for this symbology
		 * and disables all the other sibling symbologies
		 */
		toggleState: function()
		{
			this._disableSiblings();
			this.enable();
		},
		/**
		 * Enables this layer and configures the markers for the records according 
		 * to the legends (children of this symbology)
		 */
		enableButDontRedrawMarkers: function()
		{
			this._disabled = false;
			this._setLeftIconURL();
			var layerId = this.getParentLayer().getLayerId();
			this._map.getSymbologyManager().setActiveSymbology(layerId, this.layerConf);
		},
		enable: function()
		{
			this.enableButDontRedrawMarkers();
			this._map.getLayersManager().redrawMarkers();
		},
		/**
		 * Disables this layer
		 */
		disable: function()
		{
			this._disabled = true;
			this._setLeftIconURL();
		},
		_setDefault: function(value)
		{
			this._defaultSymbology = value;
		},
		setDefault: function()
		{
			var siblings = this.getSiblings();
			dojo.forEach(siblings, function(sibling){
				sibling._setDefault(false);
			});
			this._setDefault(true);
		},
		isDefault: function()
		{
			return (this._defaultSymbology == true);
		}
	});
});


},
'ibm/tivoli/fwm/mxmap/ImageLibraryManager':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/_base/declare",
		 "ibm/tivoli/fwm/mxmap/MarkerImageInfo"],
		 function(declare, MarkerImageInfo) {
	return {
		_instance: null,
		getImageLibraryManager: function() {
			if(!this._instance) {
				this._instance = new this.ImageLibraryManager();	
			}
			return this._instance;
		},
		/**
		 * Implements Maximo <-> Map JS framework communication. Currently using sendEvent
		 */
		ImageLibraryManager:  declare( null, {
			_infoCache: null,
			constructor: function(options)
			{
				dojo.mixin(this, options);
				this._loadCache();
			},
			getMarkerImageInfoForObject: function(objectName) {

				var result = objectName ? this._infoCache[objectName.toUpperCase()] : null;
				if(!result)
				{
					console.warn("[ImageLibraryManager] No marker image found for object " + objectName);
					console.warn("[ImageLibraryManager] returning default one");
					return this.getDefaultMarkerImageInfo();
				}
				return result;
			},
			getLBSMarkerImageInfo: function(lbsData) {
				if (lbsData)
				{
					if (lbsData.is_weather_alert_impact)
					{
						return this.getMarkerImageInfoForObject("WEATHER_ALERT_IMPACT");
					}
					else if ("EXCEEDED_TOLERANCE" === lbsData.max_accuracy_state)
					{
						return this.getMarkerImageInfoForObject("__LBS_EXCEEDED_ACCURACY");
					}
					else if ("EXCEEDED_TOLERANCE" === lbsData.last_update_condition_state)
					{
						return this.getMarkerImageInfoForObject("__LBS_EXCEEDED_UPDATE_COND");
					}
					else
					{
						return this.getMarkerImageInfoForObject("__LBS_INSIDE_TOLERANCE");
					}
				}
				console.warn("no lbs data!");
				return null;
			},
			getDefaultMarkerImageInfo: function() {
				return this._infoCache["__DEFAULT_MARKER"];
			},
			getStartPositionMarkerImageInfo: function() {
				return this._infoCache["__START_POSITION_MARKER"];
			},
			getEndPositionMarkerImageInfo: function() {
				return this._infoCache["__END_POSITION_MARKER"];
			},
			getLayerOnImageInfo: function() {
				return this._infoCache["__LAYER_ON"];
			},
			getLayerOffImageInfo: function() {
				return this._infoCache["__LAYER_OFF"];
			},
			getLayerDetailsImageInfo: function() {
				return this._infoCache["__LAYER_DETAILS"];
			},
			getLayerDetailsOffImageInfo: function() {
				return this._infoCache["__LAYER_DETAILS_OFF"];
			},
			getDefaultReadOnlyMarkerImageInfo: function() {
				return this._infoCache["__DEFAULT_RO_MARKER"];
			},
			getMyLocationMarkerImageInfo: function() {
				return this._infoCache["__MY_LOCATION"];
			},
			getDefaultWorkOrderMarkerImageInfo: function() {
				return this._infoCache["WORKORDER"];
			},
			getResourcesPath: function() {
				return dojo.moduleUrl("ibm.tivoli.fwm.mxmap", "resources");
			},
			getMultiMarkerImageInfo: function() {
				return this._infoCache["MULTIMARKER"];
			},
			// temporary to accommodate the custom marker
			// we should have something to allow users to override
			// the images
			updateDefaultMarkerImageURL: function(newURL)
			{
				this.getDefaultMarkerImageInfo().setImageURL(newURL);
			},
			_loadCache: function()
			{	
				var rtlDir = "";
				if(document.body.dir == "rtl")
				{
					rtlDir = "/rtl";
				}

				this._infoCache = {};
				this._infoCache["LABOR"] = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/symbology/labor/map_locationLabor.png", imageSize: [47,36], imageAnchor:[24,41]}); 
				this._infoCache["AMCREW"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/symbology/crew/map_locationCrew.png", imageSize: [47,36], imageAnchor:[24,41]});
				this._infoCache["WORKORDER"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/symbology/workorder/map_WO_default.png", imageSize: [47,36], imageAnchor:[24,36]});
				this._infoCache["__DEFAULT_MARKER"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/symbology/map_default_marker.svg", imageSize: [36,36], imageAnchor:[11,36]});
				this._infoCache["__START_POSITION_MARKER"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/map16_pointMarker_start.png", imageSize: [16,16], imageAnchor:[8,8]});
				this._infoCache["__END_POSITION_MARKER"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/map16_pointMarker_red.png", imageSize: [16,16], imageAnchor:[8,8]});
				this._infoCache["__DEFAULT_RO_MARKER"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/symbology/map_default_marker.svg", imageSize: [32,32], imageAnchor:[0,32]});
				this._infoCache["__LBS_EXCEEDED_ACCURACY"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/map16_pointMarker_red.png", imageSize: [16,16], imageAnchor:[8,8]});
				this._infoCache["__LBS_EXCEEDED_UPDATE_COND"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/map16_pointMarker_yellow.png", imageSize: [16,16], imageAnchor:[8,8]});
				this._infoCache["__LBS_INSIDE_TOLERANCE"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/map16_pointMarker_blue.png", imageSize: [16,16], imageAnchor:[8,8]});
				this._infoCache["__MY_LOCATION"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/map16_pointMarker_blue.png", imageSize: [16,16], imageAnchor:[8,8]});
				this._infoCache["__LAYER_ON"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/checkBox_selected.png", imageSize: [15,15], imageAnchor:[0,0]});
				this._infoCache["__LAYER_OFF"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/checkBox_unselected.png", imageSize: [15,15], imageAnchor:[0,0]});
				this._infoCache["__LAYER_DETAILS"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/symbologyMenu_arrow.png", imageSize: [15,15], imageAnchor:[0,0]});
				this._infoCache["__LAYER_DETAILS_OFF"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/symbologyMenu_arrow_off.png", imageSize: [15,15], imageAnchor:[0,0]});
				this._infoCache["UNASSIGNEDWORK"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/marker_yellow.png", imageSize: [20,34], imageAnchor:[10,34]});
				this._infoCache["MULTIMARKER"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/map_multiMarkerOverlay.png", imageSize: [47,36], imageAnchor:[24,36]});
				this._infoCache["WEATHER_ALERT_IMPACT"]  = new MarkerImageInfo({imageUrl: this.getResourcesPath() + rtlDir + "/map32_pointMarker_orange.png", imageSize: [32,32], imageAnchor:[16,16]});
			}
		})

	}

	
});

},
'dijit/_OnDijitClickMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/on",
	"dojo/_base/array", // array.forEach
	"dojo/keys", // keys.ENTER keys.SPACE
	"dojo/_base/declare", // declare
	"dojo/has", // has("dom-addeventlistener")
	"./a11yclick"
], function(on, array, keys, declare, has, a11yclick){

	// module:
	//		dijit/_OnDijitClickMixin

	var ret = declare("dijit._OnDijitClickMixin", null, {
		// summary:
		//		Deprecated.   New code should access the dijit/a11yclick event directly, ex:
		//		|	this.own(on(node, a11yclick, function(){ ... }));
		//
		//		Mixing in this class will make _WidgetBase.connect(node, "ondijitclick", ...) work.
		//		It also used to be necessary to make templates with ondijitclick work, but now you can just require
		//		dijit/a11yclick.

		connect: function(obj, event, method){
			// override _WidgetBase.connect() to make this.connect(node, "ondijitclick", ...) work
			return this.inherited(arguments, [obj, event == "ondijitclick" ? a11yclick : event, method]);
		}
	});

	ret.a11yclick = a11yclick;	// back compat

	return ret;
});

},
'dojo/dnd/autoscroll':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["../_base/lang", "../sniff", "../_base/window", "../dom-geometry", "../dom-style", "../window"],
	function(lang, has, win, domGeom, domStyle, winUtils){

// module:
//		dojo/dnd/autoscroll

var exports = {
	// summary:
	//		Used by dojo/dnd/Manager to scroll document or internal node when the user
	//		drags near the edge of the viewport or a scrollable node
};
lang.setObject("dojo.dnd.autoscroll", exports);

exports.getViewport = winUtils.getBox;

exports.V_TRIGGER_AUTOSCROLL = 32;
exports.H_TRIGGER_AUTOSCROLL = 32;

exports.V_AUTOSCROLL_VALUE = 16;
exports.H_AUTOSCROLL_VALUE = 16;

// These are set by autoScrollStart().
// Set to default values in case autoScrollStart() isn't called. (back-compat, remove for 2.0)
var viewport,
	doc = win.doc,
	maxScrollTop = Infinity,
	maxScrollLeft = Infinity;

exports.autoScrollStart = function(d){
	// summary:
	//		Called at the start of a drag.
	// d: Document
	//		The document of the node being dragged.

	doc = d;
	viewport = winUtils.getBox(doc);

	// Save height/width of document at start of drag, before it gets distorted by a user dragging an avatar past
	// the document's edge
	var html = win.body(doc).parentNode;
	maxScrollTop = Math.max(html.scrollHeight - viewport.h, 0);
	maxScrollLeft = Math.max(html.scrollWidth - viewport.w, 0);	// usually 0
};

exports.autoScroll = function(e){
	// summary:
	//		a handler for mousemove and touchmove events, which scrolls the window, if
	//		necessary
	// e: Event
	//		mousemove/touchmove event

	// FIXME: needs more docs!
	var v = viewport || winUtils.getBox(doc), // getBox() call for back-compat, in case autoScrollStart() wasn't called
		html = win.body(doc).parentNode,
		dx = 0, dy = 0;
	if(e.clientX < exports.H_TRIGGER_AUTOSCROLL){
		dx = -exports.H_AUTOSCROLL_VALUE;
	}else if(e.clientX > v.w - exports.H_TRIGGER_AUTOSCROLL){
		dx = Math.min(exports.H_AUTOSCROLL_VALUE, maxScrollLeft - html.scrollLeft);	// don't scroll past edge of doc
	}
	if(e.clientY < exports.V_TRIGGER_AUTOSCROLL){
		dy = -exports.V_AUTOSCROLL_VALUE;
	}else if(e.clientY > v.h - exports.V_TRIGGER_AUTOSCROLL){
		dy = Math.min(exports.V_AUTOSCROLL_VALUE, maxScrollTop - html.scrollTop);	// don't scroll past edge of doc
	}
	window.scrollBy(dx, dy);
};

exports._validNodes = {"div": 1, "p": 1, "td": 1};
exports._validOverflow = {"auto": 1, "scroll": 1};

exports.autoScrollNodes = function(e){
	// summary:
	//		a handler for mousemove and touchmove events, which scrolls the first available
	//		Dom element, it falls back to exports.autoScroll()
	// e: Event
	//		mousemove/touchmove event

	// FIXME: needs more docs!

	var b, t, w, h, rx, ry, dx = 0, dy = 0, oldLeft, oldTop;

	for(var n = e.target; n;){
		if(n.nodeType == 1 && (n.tagName.toLowerCase() in exports._validNodes)){
			var s = domStyle.getComputedStyle(n),
				overflowX = (s.overflowX.toLowerCase() in exports._validOverflow),
				overflowY = (s.overflowY.toLowerCase() in exports._validOverflow);
			if(overflowX || overflowY){
				b = domGeom.getContentBox(n, s);
				t = domGeom.position(n, true);
			}
			// overflow-x
			if(overflowX){
				w = Math.min(exports.H_TRIGGER_AUTOSCROLL, b.w / 2);
				rx = e.pageX - t.x;
				if(has("webkit") || has("opera")){
					// FIXME: this code should not be here, it should be taken into account
					// either by the event fixing code, or the domGeom.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					rx += win.body().scrollLeft;
				}
				dx = 0;
				if(rx > 0 && rx < b.w){
					if(rx < w){
						dx = -w;
					}else if(rx > b.w - w){
						dx = w;
					}
					oldLeft = n.scrollLeft;
					n.scrollLeft = n.scrollLeft + dx;
				}
			}
			// overflow-y
			if(overflowY){
				//console.log(b.l, b.t, t.x, t.y, n.scrollLeft, n.scrollTop);
				h = Math.min(exports.V_TRIGGER_AUTOSCROLL, b.h / 2);
				ry = e.pageY - t.y;
				if(has("webkit") || has("opera")){
					// FIXME: this code should not be here, it should be taken into account
					// either by the event fixing code, or the domGeom.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					ry += win.body().scrollTop;
				}
				dy = 0;
				if(ry > 0 && ry < b.h){
					if(ry < h){
						dy = -h;
					}else if(ry > b.h - h){
						dy = h;
					}
					oldTop = n.scrollTop;
					n.scrollTop  = n.scrollTop  + dy;
				}
			}
			if(dx || dy){ return; }
		}
		try{
			n = n.parentNode;
		}catch(x){
			n = null;
		}
	}
	exports.autoScroll(e);
};

return exports;

});

},
'dijit/form/_RadioButtonMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/lang", // lang.hitch
	"dojo/query!css2", // query
	"../registry"    // registry.getEnclosingWidget
], function(array, declare, domAttr, lang, query, registry){

	// module:
	//		dijit/form/_RadioButtonMixin

	return declare("dijit.form._RadioButtonMixin", null, {
		// summary:
		//		Mixin to provide widget functionality for an HTML radio button

		// type: [private] String
		//		type attribute on `<input>` node.
		//		Users should not change this value.
		type: "radio",

		_getRelatedWidgets: function(){
			// Private function needed to help iterate over all radio buttons in a group.
			var ary = [];
			query("input[type=radio]", this.focusNode.form || this.ownerDocument).forEach(// can't use name= since query doesn't support [] in the name
				lang.hitch(this, function(inputNode){
					if(inputNode.name == this.name && inputNode.form == this.focusNode.form){
						var widget = registry.getEnclosingWidget(inputNode);
						if(widget){
							ary.push(widget);
						}
					}
				})
			);
			return ary;
		},

		_setCheckedAttr: function(/*Boolean*/ value){
			// If I am being checked then have to deselect currently checked radio button
			this.inherited(arguments);
			if(!this._created){
				return;
			}
			if(value){
				array.forEach(this._getRelatedWidgets(), lang.hitch(this, function(widget){
					if(widget != this && widget.checked){
						widget.set('checked', false);
					}
				}));
			}
		},

		_getSubmitValue: function(/*String*/ value){
			return value == null ? "on" : value;
		},

		_onClick: function(/*Event*/ e){
			if(this.checked || this.disabled){ // nothing to do
				e.stopPropagation();
				e.preventDefault();
				return false;
			}

			if(this.readOnly){ // ignored by some browsers so we have to resync the DOM elements with widget values
				e.stopPropagation();
				e.preventDefault();
				array.forEach(this._getRelatedWidgets(), lang.hitch(this, function(widget){
					domAttr.set(this.focusNode || this.domNode, 'checked', widget.checked);
				}));
				return false;
			}

			// RadioButton has some unique logic since it must enforce only a single button being checked at once
			// For this reason the "_onClick" method does not call this.inherited

			var canceled = false;
			var previouslyCheckedButton;

			array.some(this._getRelatedWidgets(), function(radioButton){
				if(radioButton.checked){
					previouslyCheckedButton = radioButton;
					return true;
				}
				return false;
			});

			// We want to set the post-click values correctly for any event handlers, but since
			// the event handlers could revert them, we don't want to fully update the widget state
			// yet and trigger notifications
			this.checked = true;
			previouslyCheckedButton && (previouslyCheckedButton.checked = false);

			// Call event handlers
			// If event handler prevents it, the clicked radio button will not be checked
			if(this.onClick(e) === false || e.defaultPrevented){
				canceled = true;
			}

			// Reset internal state to how it was before the click
			this.checked = false;
			previouslyCheckedButton && (previouslyCheckedButton.checked = true);

			if(canceled){
				e.preventDefault();
			}else{
				this.set('checked', true);
			}

			return !canceled;
		}
	});
});

},
'dojo/dnd/TimedMoveable':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["../_base/declare", "./Moveable" /*=====, "./Mover" =====*/], function(declare, Moveable /*=====, Mover =====*/){
	// module:
	//		dojo/dnd/TimedMoveable

	/*=====
	var __TimedMoveableArgs = declare([Moveable.__MoveableArgs], {
		// timeout: Number
		//		delay move by this number of ms,
		//		accumulating position changes during the timeout
		timeout: 0
	});
	=====*/

	// precalculate long expressions
	var oldOnMove = Moveable.prototype.onMove;

	return declare("dojo.dnd.TimedMoveable", Moveable, {
		// summary:
		//		A specialized version of Moveable to support an FPS throttling.
		//		This class puts an upper restriction on FPS, which may reduce
		//		the CPU load. The additional parameter "timeout" regulates
		//		the delay before actually moving the moveable object.

		// object attributes (for markup)
		timeout: 40,	// in ms, 40ms corresponds to 25 fps

		constructor: function(node, params){
			// summary:
			//		an object that makes a node moveable with a timer
			// node: Node||String
			//		a node (or node's id) to be moved
			// params: __TimedMoveableArgs
			//		object with additional parameters.

			// sanitize parameters
			if(!params){ params = {}; }
			if(params.timeout && typeof params.timeout == "number" && params.timeout >= 0){
				this.timeout = params.timeout;
			}
		},

		onMoveStop: function(/*Mover*/ mover){
			if(mover._timer){
				// stop timer
				clearTimeout(mover._timer);
				// reflect the last received position
				oldOnMove.call(this, mover, mover._leftTop);
			}
			Moveable.prototype.onMoveStop.apply(this, arguments);
		},
		onMove: function(/*Mover*/ mover, /*Object*/ leftTop){
			mover._leftTop = leftTop;
			if(!mover._timer){
				var _t = this;	// to avoid using dojo.hitch()
				mover._timer = setTimeout(function(){
					// we don't have any pending requests
					mover._timer = null;
					// reflect the last received position
					oldOnMove.call(_t, mover, mover._leftTop);
				}, this.timeout);
			}
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/layers/VirtualLayer':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/layers/Layer",
	"ibm/tivoli/fwm/mxmap/_Base"], 
	function(declare, Layer, _Base) {
	return declare([Layer], {
		constructor: function(options)
		{
			this._layerName = options.layerId;
			this._layerId = options.layerId;
			this.enable();
			this.layerConf = this.symbManager.getLayerConfigById(options.objectType);
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/factories/gmaps':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dojo/io/script,ibm/tivoli/fwm/mxmap/impl/GMaps"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.factories.gmaps");
dojo.require("dojo.io.script");
dojo.require("ibm.tivoli.fwm.mxmap.impl.GMaps");
/**
 * Factory to load google maps api javascripts
 */
ibm.tivoli.fwm.mxmap.factories.gmaps = {
	compId:null,
	/**
	 * After we load the google maps javascripts this method is called. 
	 */
	apiLoaded : function() {
		console.log('Google Maps API is now available');		
		ibm.tivoli.fwm.mxmap.factory.apiInitialized("ibm.tivoli.fwm.mxmap.impl.GMaps","gmaps");
	},
	/**
	 * method to be overriden by all map factory implementation 
	 * @param options
	 */
	init : function(options) {		
		var apiVersion = "3.8"; // default API version
		var gmapsConfig = options.mapConf.GMAPS;
		if(gmapsConfig && gmapsConfig.apiVersion)
		{
			apiVersion = gmapsConfig.apiVersion;
			apiVersion.toString();
		}
		
		var license = '';	
		var secret = options.mapConf.clientSecret;
		
		if ( options.mapConf.gmapAuthMethod == "CLIENTID" )
		{
			if( options.mapConf.key )
				license = '&client=' + options.mapConf.key;
				if ( secret != ""  && secret != null && secret != undefined)	
					license = license + '&signature=' + secret;
		} else {
			if( options.mapConf.apiKey )
				license = '&key=' + options.mapConf.apiKey;
		}
		
		
		this._loadJSApi(options.mapConf.key, options.mapConf.https, apiVersion, license);
	},
	/**
	 * this method loads the google maps api and the mapstraction js for google.
	 */
	_loadJSApi : function(key, https, apiVersion, license) {
		
		console.log(license);
		var protocol = 'http';
		if(https)
			protocol = 'https';
		
		dojo.io.script.get({
			url : protocol + '://maps.google.com/maps/api/js?v=' + apiVersion + '&sensor=true&callback=ibm.tivoli.fwm.mxmap.factories.gmaps.apiLoaded' + license,
			timeout : 30000,
			error : function() {
				console.error('Failed to load google apis');
				alert('Failed to load google maps api, check your internet conncetion.');
			}
		});
	}
};

});

},
'dojo/cache':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["./_base/kernel", "./text"], function(dojo){
	// module:
	//		dojo/cache

	// dojo.cache is defined in dojo/text
	return dojo.cache;
});

},
'ibm/tivoli/fwm/mxmap/InfoWindow':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */


define(["dojo/main",
        "dojo/_base/declare",
        "ibm/tivoli/fwm/mxmap/_Base",
        "dijit/_Widget",
        "dijit/_Templated",
        "dojo/parser",
        "dojo/dom-style"], function(dojo, declare, _Base, _Widget,  _Templated, parser, domStyle ) {

        // This z-index is always increased when an info window show up so that
        // the info window can always be on top of the others 
        ibm.tivoli.fwm.mxmap.infoWindowZIndex = 0;
        ibm.tivoli.fwm.mxmap.getNextInfoWindowZIndex = function()
        {
            return ibm.tivoli.fwm.mxmap.infoWindowZIndex++;
        };


        return declare([_Base, _Widget, _Templated], {
                map:null,
                isRTL:null,
                templateString:"<div>\n<div style=\"position: relative; width: 0pt; height: 0pt; line-height: 0; border-color: transparent rgb(255, 255, 255) transparent transparent; margin-left: 0px; margin-top: 0px; border-style: solid; float: left; border-width: 15px 15px 15px 2px;\"></div>\n\n<div dojoAttachPoint=\"mainDialog\" style=\"padding:5px;position:relative;float:left;border:1px solid #000;background-color:#fff;min-width:100px;min-height:50px;\">\n\t<div dojoAttachPoint=\"closeBtn\" style=\"padding:0;margin:0;float:right;width:29px;height:29px;cursor: pointer;text-align:right;position:absolute;background-position: 8px 6px;\" ></div>\t\n\t<div dojoAttachPoint=\"content\" style=\"overflow-x:auto;\"></div>\n\t</div>\n</div>",
                _display: null,
                rootElement:null,
                domNode:null,
                mapId:null,
                constructor : function(options) {
                        dojo.mixin(this,options);
                        this._display = false;
                        if(!this.isRTL){
                                this.isRTL=document.body.dir=='rtl';
                        }
                },
                postCreate:function(){
                        var me = this;
                        parser.parse(this.domNode );
                        domStyle.set(this.domNode,"display","none");
                        domStyle.set(this.domNode,"position","absolute");
                        // Defect 70995 - There is no way to make the InfoWindow become scrollable in mobile browsers
                        // (or maybe there is, but I could not find out how to do that in 1 week)
                       // so the solution is to allow the maptip summary to be as huge as necessary so that no scrolling is needed,
                        // also, we cannot let the InfoWindow close when it touches the map edges.
                        // To sum up, scrolling is disabled only if this is a mobile device and the marker is a multiple marker.
                        if(this.enableScrollBars())
                        {
                                // Defect 66760 - Force the maximum height of the infoWindow to be 50% of the map width
                                // (as it seems to be like when gmaps is selected)
                                // so that a vertical scroll will show up for maptip summaries with many records.
                                // However, since IE ignores "max-" attributes (microsoft says it doesn't since IE7, but this is a big fat lie)
                                // so the solution involves forcing the height of the content div to be mapHeight / 2 in the show() method below.
                                // Not sure why spatial map does not have the getHeight method
                                var mapHeight = this.map.getHeight ? this.map.getHeight() : this.map.height;
                                domStyle.set(this.content,"maxHeight", mapHeight / 2);
                        }

                        this._display = false;
                        this.placeAt(this.rootElement);
                        domStyle.set(this.closeBtn, "background", "url(" + dojo.config.fwm.servletBase + "/javascript/ibm/tivoli/fwm/mxmap/resources/ac16_winClose.png) no-repeat");
                        // Moves the close button to the left if bidi is enabled
                        if(this.isRTL==true)
                        {
                                domStyle.set(this.closeBtn, "float", "left");
                                domStyle.set(this.closeBtn, "left", "3px");
                                domStyle.set(this.content, "marginLeft", "20px");
                                domStyle.set(this.domNode, "direction", "rtl");
                        } else {
                                domStyle.set(this.closeBtn, "float", "right");
                                domStyle.set(this.closeBtn, "right", "3px");
                                domStyle.set(this.content, "marginRight", "20px");
                                domStyle.set(this.domNode, "direction", "ltr");
                        }
                        if (dojo.isIE) {
                                if (this.content) {
                                        domStyle.set(this.content,"overflow","hidden");
                                        domStyle.set(this.content,"overflow-x","hidden");
                                }
                        }
                        dojo.connect(this.domNode, "oncontextmenu", function(evt)
                                        {
                                dojo.stopEvent(evt);
                                        });
                        // Defect 67358 - Prevent map panning when the user is interacting with the maptip
                        dojo.connect(this.domNode, "mousedown", function(evt)
                                        {
                                dojo.stopEvent(evt);
                                        });
                        dojo.connect(this.domNode, "touchstart", function(evt)
                                        {
                                dojo.stopEvent(evt);
                                        });
                        // Defect 66953: Cannot use dojoAttachEvent in the html template to attach more than one event
                        // to the same dojoAttachPoint (maybe a bug in dojo?), so the solution is to make 2 connections.
                        // The "touchend" connection is for mobile devices
                        dojo.connect(this.closeBtn, "click", function(evt)
                                        {
                                me.close();
                                        });
                        dojo.connect(this.closeBtn, "touchend", function(evt)
                                        {
                                me.close();
                                        });

                },
                updatePosition:function(x,y){ 
                        var coords ={x:0,y:0};// dojo.position(this.rootElement,true);          
                        var px = x+coords.x+this.offset.x;
                        var py = y+coords.y+this.offset.y;
                        domStyle.set(this.domNode,"left",px + "px");
                        domStyle.set(this.domNode,"top",py + "px");

                        // Commenting out this code that closes the maptip whenever it hits the map edges per Lisa's request.
                        // The code below gets in the way of the logic that automatically centers the map around the marker
                        // when its maptip opens (defect 88220). If this change brings back the issue where the maptip overlaps
                        // other maximo UI components, then it should be rolled back.
//                      if(this.isDisplayed() && this.enableScrollBars()){
//                      if(parseInt(px)<0 || parseInt(py)<0 || parseInt(domStyle.set(this.domNode, "right"))<0 || parseInt(domStyle.set(this.domNode, "bottom"))<0){
//                      this.close();
//                      }
//                      }
                },
                isDisplayed:function(){
                        return (this._display == true);
                },
                setContent:function(content){
                        if(typeof(content) == 'object'){
                                this.setDomContent(content);
                        }else{
                                dojo.empty(this.content);
                                dojo.create("div",{innerHTML:content},this.content);
                        }
                },
                setDomContent:function(domToAppend){
                        dojo.place(domToAppend, this.content, "only");
                },
                close:function(){ 
                        domStyle.set(this.domNode,"display",'none');
                        this._display = false;
                        dojo.publish("endedUserInteractionOnMap_"+this.mapId, [ {
                                objectSource: this,
                                objectSourceName: 'infowindow',
                                eventName: 'closeBubble'
                        } ]);
                },
                offset:{
                        y:-15,
                        x:0
                },
                show:function(x,y){

                        var coords ={x:0,y:0};// dojo.position(this.rootElement,true);          

                        var px = x+coords.x+this.offset.x;
                        var py = y+coords.y+this.offset.y;

                        domStyle.set(this.domNode,"top",py + "px");
                        domStyle.set(this.domNode,"left",px + "px");
                        domStyle.set(this.domNode,"display",'block');
                        domStyle.set(this.domNode,"zIndex",ibm.tivoli.fwm.mxmap.getNextInfoWindowZIndex());
                        this._display = true;

                        // Very ugly workaround for IE because it does not support maxHeight. Besides,
                        // it is impossible to retrieve the actual height of the content div by reading the 'height'
                        // style property... it only works by reading the offsetHeight property directly from the div
                        if(dojo.isIE)
                        {
                                var mapHeight = this.map.getHeight ? this.map.getHeight() : this.map.height;
                                var maxInfoWindowHeight = mapHeight/2;
                                if(this.content.offsetHeight > maxInfoWindowHeight)
                                {
//                                      domStyle.set(this.content,"overflow", "auto");
                                        domStyle.set(this.content,"height", maxInfoWindowHeight + "px");
                                }
                        }
                },
                // Defect 67260 - Moves the main dialog up so that that the infoWindow can be closed
                // even when child dialogs are showing
                moveUp: function()
                {
                        domStyle.set(this.mainDialog, "marginTop", "-40px");
                },
                // Defect 70995 - There is no way to make the InfoWindow become scrollable in mobile browsers
                // (or maybe there is, but I could not find out how to do that in 1 week)
                // so the solution is to allow the maptip summary to be as huge as necessary so that no scrolling is needed,
                // also, we cannot let the InfoWindow close when it touches the map edges.
                // To sum up, scrolling is disabled only if this is a mobile device and the marker is a multiple marker.
                enableScrollBars: function()
                {
                        return (this.isMobile != true);
                }
        });
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/WorkOrderSymbologyTool':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
define(["dojo/_base/declare", "ibm/tivoli/fwm/mxmap/layers/LayerPanelWidget", "ibm/tivoli/fwm/mxmap/_Base",
	"ibm/tivoli/fwm/mxmap/toolbar/ext/LayersTool", "dijit/form/Button" ], function(declare, LayerPanelWidget, _Base, 
			LayersTool, Button) {
	
	/**
	 * Work order symbology tool (this is just a shortcut to Layers -> Work Order)
	 */
	ibm.tivoli.fwm.mxmap.toolbar.ext.WorkOrderSymbologyTool = declare([LayersTool], {
		iconClass: "basicMapToolbarBtn workOrderSymbologyMapToolbarBtn",
		constructor: function(params)
		{			
			dojo.mixin(this, params); 
			var _label = ibm.tivoli.fwm.i18n.getMaxMsg("map", "workordersymbology");
			this.label = _label || this.label;
		},
		execute: function()
		{
			var layer = this.map.getLayersManager().getLayerById("workorder");
			if((layer != null) && (layer.hasChildren()))
			{
				this._destroyCurrentPanelWidget();
				var _layerPanelManager = new ibm.tivoli.fwm.mxmap.layers.LayerPanelWidget({map: this.map, tool: this, title: layer.getChildrenTitle()});		
				_layerPanelManager.updateLayers(layer.getChildren());
			}
		}
	});
	return ibm.tivoli.fwm.mxmap.toolbar.ext.WorkOrderSymbologyTool;
});

},
'dojo/promise/all':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"../_base/array",
	"../_base/lang",
	"../Deferred",
	"../when"
], function(array, lang, Deferred, when){
	"use strict";

	// module:
	//		dojo/promise/all

	var some = array.some;

	return function all(objectOrArray){
		// summary:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected.
		// description:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected. If one of
		//		the promises is rejected, the returned promise is also rejected. Canceling
		//		the returned promise will *not* cancel any passed promises.
		// objectOrArray: Object|Array?
		//		The promise will be fulfilled with a list of results if invoked with an
		//		array, or an object of results when passed an object (using the same
		//		keys). If passed neither an object or array it is resolved with an
		//		undefined value.
		// returns: dojo/promise/Promise

		var object, array;
		if(lang.isArray(objectOrArray)){
			array = objectOrArray;
		}else if(objectOrArray && typeof objectOrArray === "object"){
			object = objectOrArray;
		}

		var results;
		var keyLookup = [];
		if(object){
			array = [];
			for(var key in object){
				if(Object.hasOwnProperty.call(object, key)){
					keyLookup.push(key);
					array.push(object[key]);
				}
			}
			results = {};
		}else if(array){
			results = [];
		}

		if(!array || !array.length){
			return new Deferred().resolve(results);
		}

		var deferred = new Deferred();
		deferred.promise.always(function(){
			results = keyLookup = null;
		});
		var waiting = array.length;
		some(array, function(valueOrPromise, index){
			if(!object){
				keyLookup.push(index);
			}
			when(valueOrPromise, function(value){
				if(!deferred.isFulfilled()){
					results[keyLookup[index]] = value;
					if(--waiting === 0){
						deferred.resolve(results);
					}
				}
			}, deferred.reject);
			return deferred.isFulfilled();
		});
		return deferred.promise;	// dojo/promise/Promise
	};
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/RefresherTool':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/toolbar/ext/_ToolTemplate,ibm/tivoli/fwm/mxmap/_Base,dijit/form/Button"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.toolbar.ext.RefresherTool");
dojo.require("ibm.tivoli.fwm.mxmap.toolbar.ext._ToolTemplate");
dojo.require("ibm.tivoli.fwm.mxmap._Base");
dojo.require("dijit.form.Button");

/**
 * Full Screen tool bar action.
 */
dojo.declare("ibm.tivoli.fwm.mxmap.toolbar.ext.RefresherTool", ibm.tivoli.fwm.mxmap.toolbar.ext._ToolTemplate, {
	label: "Refresh",
	iconClass: "basicMapToolbarBtn refreshMapToolbarBtn",
	map: null,
	constructor: function(params)
	{
		dojo.mixin(this, params);

		var _label = ibm.tivoli.fwm.i18n.getMaxMsg("map", "refreshtoolbar");
		this.label = _label || this.label;
	},
	execute: function()
	{
		var refreshOptions = {
				zoom: true,
				disableMsgs: false,
				automatic: false
			};
		this.map.refreshMap(refreshOptions);
	},
	disable: function()
	{
		// does nothing
	},
	destroy: function()
	{
		this.destroyRecursive();
	}
});

});

},
'dojo/_base/url':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["./kernel"], function(dojo){
	// module:
	//		dojo/url

	var
		ore = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"),
		ire = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$"),
		_Url = function(){
			var n = null,
				_a = arguments,
				uri = [_a[0]];
			// resolve uri components relative to each other
			for(var i = 1; i<_a.length; i++){
				if(!_a[i]){ continue; }

				// Safari doesn't support this.constructor so we have to be explicit
				// FIXME: Tracked (and fixed) in Webkit bug 3537.
				//		http://bugs.webkit.org/show_bug.cgi?id=3537
				var relobj = new _Url(_a[i]+""),
					uriobj = new _Url(uri[0]+"");

				if(
					relobj.path == "" &&
					!relobj.scheme &&
					!relobj.authority &&
					!relobj.query
				){
					if(relobj.fragment != n){
						uriobj.fragment = relobj.fragment;
					}
					relobj = uriobj;
				}else if(!relobj.scheme){
					relobj.scheme = uriobj.scheme;

					if(!relobj.authority){
						relobj.authority = uriobj.authority;

						if(relobj.path.charAt(0) != "/"){
							var path = uriobj.path.substring(0,
								uriobj.path.lastIndexOf("/") + 1) + relobj.path;

							var segs = path.split("/");
							for(var j = 0; j < segs.length; j++){
								if(segs[j] == "."){
									// flatten "./" references
									if(j == segs.length - 1){
										segs[j] = "";
									}else{
										segs.splice(j, 1);
										j--;
									}
								}else if(j > 0 && !(j == 1 && segs[0] == "") &&
									segs[j] == ".." && segs[j-1] != ".."){
									// flatten "../" references
									if(j == (segs.length - 1)){
										segs.splice(j, 1);
										segs[j - 1] = "";
									}else{
										segs.splice(j - 1, 2);
										j -= 2;
									}
								}
							}
							relobj.path = segs.join("/");
						}
					}
				}

				uri = [];
				if(relobj.scheme){
					uri.push(relobj.scheme, ":");
				}
				if(relobj.authority){
					uri.push("//", relobj.authority);
				}
				uri.push(relobj.path);
				if(relobj.query){
					uri.push("?", relobj.query);
				}
				if(relobj.fragment){
					uri.push("#", relobj.fragment);
				}
			}

			this.uri = uri.join("");

			// break the uri into its main components
			var r = this.uri.match(ore);

			this.scheme = r[2] || (r[1] ? "" : n);
			this.authority = r[4] || (r[3] ? "" : n);
			this.path = r[5]; // can never be undefined
			this.query = r[7] || (r[6] ? "" : n);
			this.fragment	 = r[9] || (r[8] ? "" : n);

			if(this.authority != n){
				// server based naming authority
				r = this.authority.match(ire);

				this.user = r[3] || n;
				this.password = r[4] || n;
				this.host = r[6] || r[7]; // ipv6 || ipv4
				this.port = r[9] || n;
			}
		};
	_Url.prototype.toString = function(){ return this.uri; };

	return dojo._Url = _Url;
});

},
'dojox/main':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["dojo/_base/kernel"], function(dojo) {
	// module:
	//		dojox/main

	/*=====
	return {
		// summary:
		//		The dojox package main module; dojox package is somewhat unusual in that the main module currently just provides an empty object.
		//		Apps should require modules from the dojox packages directly, rather than loading this module.
	};
	=====*/

	return dojo.dojox;
});

},
'ibm/tivoli/fwm/mxmap/LoadEsriPlugin':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
/*

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * Neither the name of the Mapstraction nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/**
 * A dojo loader plugin for loading esri modules so that they get ignored by the build system.
 */
define(function () {

    return {
        load: function (id, require, callback) {
            // id: String  esri module id
            // require: Function  AMD require; usually a context-sensitive require bound to the module making the plugin request
            // callback: Function Callback function which will be called, when the loading finished.
            require([id], function (mod) {
                callback(mod);
            });

        }

    };

});

},
'dojo/text':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["./_base/kernel", "require", "./has", "./request"], function(dojo, require, has, request){
	// module:
	//		dojo/text

	var getText;
	if( 1 ){
		getText= function(url, sync, load){
			request(url, {sync:!!sync, headers: { 'X-Requested-With': null } }).then(load);
		};
	}else{
		// Path for node.js and rhino, to load from local file system.
		// TODO: use node.js native methods rather than depending on a require.getText() method to exist.
		if(require.getText){
			getText= require.getText;
		}else{
			console.error("dojo/text plugin failed to load because loader does not support getText");
		}
	}

	var
		theCache = {},

		strip= function(text){
			//Strips <?xml ...?> declarations so that external SVG and XML
			//documents can be added to a document without worry. Also, if the string
			//is an HTML document, only the part inside the body tag is returned.
			if(text){
				text= text.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
				var matches= text.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
				if(matches){
					text= matches[1];
				}
			}else{
				text = "";
			}
			return text;
		},

		notFound = {},

		pending = {};

	dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		// summary:
		//		A getter and setter for storing the string content associated with the
		//		module and url arguments.
		// description:
		//		If module is a string that contains slashes, then it is interpretted as a fully
		//		resolved path (typically a result returned by require.toUrl), and url should not be
		//		provided. This is the preferred signature. If module is a string that does not
		//		contain slashes, then url must also be provided and module and url are used to
		//		call `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.
		//		If value is specified, the cache value for the moduleUrl will be set to
		//		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
		//		in its internal cache and return that cached value for the URL. To clear
		//		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
		//		the URL contents, only modules on the same domain of the page can use this capability.
		//		The build system can inline the cache values though, to allow for xdomain hosting.
		// module: String||Object
		//		If a String with slashes, a fully resolved path; if a String without slashes, the
		//		module name to use for the base part of the URL, similar to module argument
		//		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
		//		generates a valid path for the cache item. For example, a dojo._Url object.
		// url: String
		//		The rest of the path to append to the path derived from the module argument. If
		//		module is an object, then this second argument should be the "value" argument instead.
		// value: String||Object?
		//		If a String, the value to use in the cache for the module/url combination.
		//		If an Object, it can have two properties: value and sanitize. The value property
		//		should be the value to use in the cache, and sanitize can be set to true or false,
		//		to indicate if XML declarations should be removed from the value and if the HTML
		//		inside a body tag in the value should be extracted as the real value. The value argument
		//		or the value property on the value argument are usually only used by the build system
		//		as it inlines cache content.
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
		//		of call is used to avoid an issue with the build system erroneously trying to intern
		//		this example. To get the build system to intern your dojo.cache calls, use the
		//		"dojo.cache" style of call):
		//		| //If template.html contains "<h1>Hello</h1>" that will be
		//		| //the value for the text variable.
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html");
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
		//		 (the dojo["cache"] style of call is used to avoid an issue with the build system
		//		erroneously trying to intern this example. To get the build system to intern your
		//		dojo.cache calls, use the "dojo.cache" style of call):
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
		// example:
		//		Same example as previous, but demonstrates how an object can be passed in as
		//		the first argument, then the value argument can then be the second argument.
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

		//	 * (string string [value]) => (module, url, value)
		//	 * (object [value])        => (module, value), url defaults to ""
		//
		//	 * if module is an object, then it must be convertable to a string
		//	 * (module, url) module + (url ? ("/" + url) : "") must be a legal argument to require.toUrl
		//	 * value may be a string or an object; if an object then may have the properties "value" and/or "sanitize"
		var key;
		if(typeof module=="string"){
			if(/\//.test(module)){
				// module is a version 1.7+ resolved path
				key = module;
				value = url;
			}else{
				// module is a version 1.6- argument to dojo.moduleUrl
				key = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : ""));
			}
		}else{
			key = module + "";
			value = url;
		}
		var
			val = (value != undefined && typeof value != "string") ? value.value : value,
			sanitize = value && value.sanitize;

		if(typeof val == "string"){
			//We have a string, set cache value
			theCache[key] = val;
			return sanitize ? strip(val) : val;
		}else if(val === null){
			//Remove cached value
			delete theCache[key];
			return null;
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in theCache)){
				getText(key, true, function(text){
					theCache[key]= text;
				});
			}
			return sanitize ? strip(theCache[key]) : theCache[key];
		}
	};

	return {
		// summary:
		//		This module implements the dojo/text! plugin and the dojo.cache API.
		// description:
		//		We choose to include our own plugin to leverage functionality already contained in dojo
		//		and thereby reduce the size of the plugin compared to various foreign loader implementations.
		//		Also, this allows foreign AMD loaders to be used without their plugins.
		//
		//		CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous
		//		loader. This feature is outside the scope of the CommonJS plugins specification.

		// the dojo/text caches it's own resources because of dojo.cache
		dynamic: true,

		normalize: function(id, toAbsMid){
			// id is something like (path may be relative):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var parts= id.split("!"),
				url= parts[0];
			return (/^\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? "!" + parts[1] : "");
		},

		load: function(id, require, load){
			// id: String
			//		Path to the resource.
			// require: Function
			//		Object that include the function toUrl with given id returns a valid URL from which to load the text.
			// load: Function
			//		Callback function which will be called, when the loading finished.

			// id is something like (path is always absolute):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var
				parts= id.split("!"),
				stripFlag= parts.length>1,
				absMid= parts[0],
				url = require.toUrl(parts[0]),
				requireCacheUrl = "url:" + url,
				text = notFound,
				finish = function(text){
					load(stripFlag ? strip(text) : text);
				};
			if(absMid in theCache){
				text = theCache[absMid];
			}else if(require.cache && requireCacheUrl in require.cache){
				text = require.cache[requireCacheUrl];
			}else if(url in theCache){
				text = theCache[url];
			}
			if(text===notFound){
				if(pending[url]){
					pending[url].push(finish);
				}else{
					var pendingList = pending[url] = [finish];
					getText(url, !require.async, function(text){
						theCache[absMid]= theCache[url]= text;
						for(var i = 0; i<pendingList.length;){
							pendingList[i++](text);
						}
						delete pending[url];
					});
				}
			}else{
				finish(text);
			}
		}
	};

});


},
'ibm/tivoli/fwm/mxmap/toolbar/ext/_ToggleTool':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */


define(["dojo/main", "dijit/main", "dojox/main", "dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/_Base",
	"dijit/form/ToggleButton",
	"ibm/tivoli/fwm/mxmap/toolbar/ext/_ToolTemplate"], 
	function(dojo, dijit, dojox, declare, _Base, ToggleButton, _ToolTemplate) {
	return declare([_ToolTemplate], {
		toolActive: false,
		constructor: function(params)
		{
			dojo.mixin(this, params);
		},
		createToolbarButton: function()
		{
			this._button = new dijit.form.ToggleButton({
				label: this.label,
				showLabel: false,
				iconClass: this.iconClass,
				onClick: dojo.hitch(this, function(params)
						{
					this.execute(params);
						})

			});
			return this._button;

		},
		/**
		 * The execute method has been overridden here to run toggleStatus()
		 */
		execute: function(params)
		{
			this.toggleStatus(params);
		},
		/**
		 * Runs either executeOn or executeOff, depending on the toolActive status.
		 * The executeOff and executeOn methods must be implemented.
		 * Should any error occur in the executeOff and executeOn routines that requires the status to remain the same,
		 * the setActive(true/false) method must be called explicitly.
		 */
		toggleStatus: function(params)
		{
			if(this.isActive() == true)
			{
				this.setActive(false);
				this.executeOff(params);
			}
			else
			{
				this.setActive(true);
				this.executeOn(params);
			}
		},
		/**
		 * Checks if the tool is active
		 */
		isActive: function()
		{
			return this.toolActive;
		},
		executeOn: function()
		{
			console.error("to be implemented");
		},
		executeOff: function()
		{
			console.error("to be implemented");
		},
		/**
		 * Changes the status of the tool (and the button)
		 */
		setActive: function(active)
		{
			if(this._button != null){
				this._button.set({
					checked: active
				});
			}
			this.toolActive = active;
		}	
	});
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/MyLocationTool':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */



/**
 * My Location tool bar action.
 */

define(["dojo/_base/declare", "ibm/tivoli/fwm/mxmap/_Base", "ibm/tivoli/fwm/mxmap/toolbar/ext/_ToggleTool",
	"dijit/form/Button", "ibm/tivoli/fwm/mxmap/ImageLibraryManager",
	"ibm/tivoli/fwm/mxmap/geolocation/MyCurrentLocation", "ibm/tivoli/fwm/mxmap/Radius"], 
	function(declare, _Base, _ToggleTool, Button,  ImageLibraryManager, MyCurrentLocation, Radius) {

	ibm.tivoli.fwm.mxmap.toolbar.ext.MyLocationToolStatus = {
			DISABLED: -1,
			MARKER_CENTERED: 0,
			MARKER_NOT_CENTERED: 1
	};


	return declare([_ToggleTool], {
		label: "My Location",
		iconClass: "basicMapToolbarBtn myLocationMapToolbarBtn",
		map: null,
		myLocationToolStatus: null,
		myLocationMarker: null,
		lbsCircle: null,
		imageLibManager: null,
		myCurrentLocationInstance: null,
		_executedAtLeastOnce: false,
		_onEndPanFct: null,
		_createOnEndPanFct: null,
		_setCenterTimer: null,
		_setCenterTimerInterval: 0,
		_setCenterPending: false,
		constructor: function(params)
		{
			dojo.mixin(this, params);
			var _label = ibm.tivoli.fwm.i18n.getMaxMsg("map", "mylocationtool");

			this.resetMyLocationTool();

			this.label = _label || this.label;

			this.imageLibManager = ImageLibraryManager.getImageLibraryManager();
			this.myCurrentLocationInstance = MyCurrentLocation.getMyCurrentLocationInstance();

			// Create the reference for the handler functions here only once. Running dojo.hitch twice on the 
			// same function does not yield the exact same reference (i.e. checking for equality will fail)
			this._onEndPanFct = dojo.hitch(this,this.onEndPan);
			this._createOnEndPanFct = dojo.hitch(this,this.createOnEndPan);

			// When the tool is active and on MARKER_CENTERED status, the map will recenter
			// around the user location marker only once per this._setCenterTimerInterval seconds
			// regardless of the number of updates to the marker position
			this._setCenterTimerInterval = this.getSetCenterInterval();
		},

		disable: function()
		{
			// does nothing
		},
		destroy: function()
		{
			this.stopSetCenterControlTimer();
			this.resetMyLocationTool();
			this.destroyRecursive();
		},
		toggleStatus: function()
		{
			this.toggleMyLocationStatus();
		},
		/**
		 * Changes the status of the tool From DISABLED to MARKER_CENTERED, from
		 * MARKER_CENTERED to DISABLED and from MARKER_NOT_CENTERED to
		 * MARKER_CENTERED
		 */
		toggleMyLocationStatus: function()
		{
			switch (this.myLocationToolStatus)
			{
			case ibm.tivoli.fwm.mxmap.toolbar.ext.MyLocationToolStatus.DISABLED:
				// 12-13616. Moving this.setActive(true) here (before this.watchMyLocationMarkerPosition()), because
				// the latter can result in an error and, if so, the error callback will reset the button status to "off"
				this.setActive(true);
				this.myLocationToolStatus = ibm.tivoli.fwm.mxmap.toolbar.ext.MyLocationToolStatus.MARKER_CENTERED;
				this.watchMyLocationMarkerPosition();
				// The tool is active, start the map recentering timer
				this.startSetCenterControlTimer();
				break;
			case ibm.tivoli.fwm.mxmap.toolbar.ext.MyLocationToolStatus.MARKER_NOT_CENTERED:
				this.setActive(true);
				this.myLocationToolStatus = ibm.tivoli.fwm.mxmap.toolbar.ext.MyLocationToolStatus.MARKER_CENTERED;
				// When the tool status change from MARKER_NOT_CENTERED to MARKER_CENTERED
				// for a recenter now.
				this.setCenterAndUpdateMarkerPosition({recenter: true});
				break;
			case ibm.tivoli.fwm.mxmap.toolbar.ext.MyLocationToolStatus.MARKER_CENTERED:
				this.resetMyLocationTool();
				// Tool is not active, stop the map recentering timer
				this.stopSetCenterControlTimer();
				break;
			default:
				break;
			}
			;

		},
		/**
		 * Updates the My Location marker position according to the new current
		 * location If the current status is MARKER_CENTERED, forces the map to be
		 * centered around the marker
		 */
		setCenterAndUpdateMarkerPosition: function(params)
		{
			// This variable indicates whether or not the marker position is to be updated on the map.
			// It should be updated whenever this function is called as a callback from
			// the browsers geolocation API. However, then this function is called explicitly
			// by the map recentering timer or when the user changes the tool status from MARKER_NOT_CENTERED
			// to MARKER_CENTERED, then, only a map recentering is needed (and this variable will be false).
			var updateMarkerPosition = ((params == null) || (params == undefined) || (params.recenter == undefined) || (params.recenter != true)) ? true : false;
			// This cariable Indicates whether or not the map should be recentered around the marker.
			// Basically, only when setCenterAndUpdateMarkerPosition is called explicitly (i.e. when updateMarkerPosition is false).
			// There are 2 exceptions (for which this variable will be true):
			// 1. The this._setCenterTimerInterval is zero: because it means that there is no interval set, i.e. need to recenter the map whenever the marker location is updated.
			// 2. This is the first time that setCenterAndUpdateMarkerPosition is being called since the tool has been activated last.
			var recenterMap = ((this._setCenterTimerInterval == 0) || (this._executedAtLeastOnce == false) || (updateMarkerPosition == false)) ? true: false;

			this._executedAtLeastOnce = true;
			if (this.myLocationToolStatus != ibm.tivoli.fwm.mxmap.toolbar.ext.MyLocationToolStatus.DISABLED)
			{
				if (this.myCurrentLocationInstance)
				{
					if (this.myCurrentLocationInstance.getPosition() && this.myCurrentLocationInstance.getPosition().coords)
					{
						// Retrieve the properties related to My Location
						var coords = this.myCurrentLocationInstance.getPosition().coords;
						var lat = coords.latitude;
						var lng = coords.longitude;
						var accuracy = coords.accuracy;
						var latLonPoint = this.map.latLng(lat, lng);

						if(updateMarkerPosition == true)
						{
							// Remove existing My Location marker (if any)
							this.removeMyLocationMarker();

							// Add the My Location marker with accuracy circle
							this.createMyLocationMarker(latLonPoint, accuracy);

							this._setCenterPending = true;
						}

						if(recenterMap == true)
						{
							this._setCenterPending = false;
							// Move map around the marker only if the marker was already
							// centered
							if (this.myLocationToolStatus == ibm.tivoli.fwm.mxmap.toolbar.ext.MyLocationToolStatus.MARKER_CENTERED)
							{
								// TODO: The event handler calls have been commented out because of a javascript error (_4bc.remove is not a function). Investigate that!
								this.map.removeMapEventHandler(this.map.Events.endPan, this._onEndPanFct);
								this.map.addMapEventHandler(this.map.Events.endPan, this._createOnEndPanFct);
								this._center(latLonPoint);						
							}
						}
					}
				}
			}
		},	
		/**
		 * Changes the position of the marker on the map. This method must be called
		 * when the status changes from DISABLED to MARKER_CENTERED.
		 */
		_handler: null,
		watchMyLocationMarkerPosition: function()
		{
			if (this.myCurrentLocationInstance)
			{
				// The method this.setCenterAndUpdateMarkerPosition must be called
				// whenever the user's current position changes.
				// 12-13674. We need to create the listener prior to calling watchUserLocation on myCurrentLocationInstance
				// because some errors may happen synchronously. When an error happens during the listenToUserLocation() call,
				// the error callback is executed before the handler is returned, so the myCurrentLocationInstance.removeListeners
				// tries to remove the listener using a handler that does not exist yet.
				this._handler = this.myCurrentLocationInstance.createListener(dojo.hitch(this, this.setCenterAndUpdateMarkerPosition), dojo.hitch(this, this.failedToGetLocation));
				this.myCurrentLocationInstance.listenToUserLocation(this._handler);
			}
		},
		/**
		 * Creates the My Location marker according to the specifications (blue dot
		 * with a blue hollow accuracy circle around it)
		 */
		convertedPoints:{},
		createMyLocationMarker: function(latLonPoint, accuracy)
		{

			var succFct = function(points)
			{
				var p = points[0];
				this.convertedPoints[latLonPoint]=p;
				var markerData = this.imageLibManager.getMyLocationMarkerImageInfo().generateMarkerData("");
				this.createAccuracyCircle(p, accuracy);
				this.myLocationMarker = this.map.addMarker(p, markerData);
			};
			var errFct = function(error)
			{
				console.error("error", error);
			};
			this.map.getAllPointsFromWGS84([ latLonPoint ], dojo.hitch(this, succFct), dojo.hitch(this, errFct));


		},
		_center:function(latLonPoint){
			var succFct = function(points)
			{
				var p = points[0];
				this.map.setCenter(p);
			};
			var errFct = function(error)
			{
				console.error("error", error);
			};
			this.map.getAllPointsFromWGS84([ latLonPoint ], dojo.hitch(this, succFct), dojo.hitch(this, errFct));
		},
		/**
		 * Removes the My Location marker and the accuracy circle
		 */
		removeMyLocationMarker: function()
		{
			if (this.myLocationMarker)
			{
				this.map.removeMarker(this.myLocationMarker);
				this.myLocationMarker = null;
			}
			if (this.lbsCircle)
			{
				this.map.removePolyline(this.lbsCircle);
				this.lbsCircle = null;
			}
		},
		// Sends the error message to Maximo (according to specifications) and
		// resets the status of the tool
		failedToGetLocation: function()
		{
			if (this._executedAtLeastOnce == false)
			{
				this.map.failedToGetLocation();
				this.resetMyLocationTool();
			}
			else
			{
				// Send status message to maximo
				this.map.failedToGetLocationStatusMessages();
			}
		},
		/**
		 * Puts the tool in the DISABLED status and removes the marker
		 */
		resetMyLocationTool: function()
		{
			this.myLocationToolStatus = ibm.tivoli.fwm.mxmap.toolbar.ext.MyLocationToolStatus.DISABLED;
			this.removeMyLocationMarker();
			this.stopWatchingMyLocationMarkerPosition();
			this._executedAtLeastOnce = false;
			this.setActive(false);
			this.map.removeMapEventHandler(this.map.Events.endPan, this._onEndPanFct);
		},
		/**
		 * Disables the browser's watchPosition API
		 */
		stopWatchingMyLocationMarkerPosition: function()
		{
			if (this.myCurrentLocationInstance != null)
			{
				this.myCurrentLocationInstance.removeListeners(this._handler);
			}
		},
		/**
		 * This is an auxiliary handler that is added just before the setCenter()
		 * function. The purpose is to avoid the onEndPan being triggered by
		 * the setCenter call.
		 */
		createOnEndPan: function()
		{
			this.map.removeMapEventHandler(this.map.Events.endPan, this._createOnEndPanFct);
			this.map.addMapEventHandler(this.map.Events.endPan, this._onEndPanFct);
		},

		/**
		 * Handler function that changes the status of the tool from MARKER_CENTERED
		 * to MARKER_NOT_CENTERED whenever an endPan event is captured.
		 */
		onEndPan: function(event_name, event_source, event_args)
		{
			if (this.myLocationToolStatus == ibm.tivoli.fwm.mxmap.toolbar.ext.MyLocationToolStatus.MARKER_CENTERED)
			{
				// Defect 57860 - Ignore the pan event if it was triggered by the map full screen operations
				if(this.map.isExecutingFullScreen() == false)
				{
					this.myLocationToolStatus = ibm.tivoli.fwm.mxmap.toolbar.ext.MyLocationToolStatus.MARKER_NOT_CENTERED;			
				}
			}
		},
		// TODO: Refactor: this logic should be moved somewhere else
		createAccuracyCircle: function(point, accuracy)
		{
			if (this.lbsCircle == null)
			{
				var circle = this.map.radius(point, 10);
				var radiusInKms = (accuracy / 1000);
				if(this.lbsCircle){
					this.removeMyLocationMarker();
				}
				this.lbsCircle = circle.getPolyline(radiusInKms, "#C6DBEB");
				this.map.addPolyline(this.lbsCircle, {
					centerPoint: point,
					width: 3,
					opacity: 0.5,
					fillColor: "#D0E0EC",
					closed: true,
					radiusInKMs: radiusInKms
				});
			}
		},
		/**
		 * Creates the instance of dojox.timing.Timer and changes the onTick,
		 * onStart and onStop functions. 
		 * Checks whether or not a map recentering is needed on onTick
		 */
		_doStart: function()
		{
			this._setCenterTimer = new dojox.timing.Timer(this._setCenterTimerInterval * 1000);
			this._setCenterTimer.onTick = dojo.hitch(this, function()
					{
				if (this._setCenterPending == true)
				{
					this.setCenterAndUpdateMarkerPosition({recenter: true});
					this._setCenterPending = false;
				}
					});
			this._setCenterTimer.onStart = dojo.hitch(this, function()
					{
				if (dojo.config.fwm.debug == true)
				{
					console.log("[MyLocationTool] Started timer to recenter map whenever needed");
				}
					});
			this._setCenterTimer.onStop = dojo.hitch(this, function()
					{
				if (dojo.config.fwm.debug == true)
				{
					console.log("[MyLocationTool] Stopped timer to recenter map whenever needed");
				}
					});
			this._setCenterTimer.start();
		},
		/**
		 * Starts the timer (if needed) to control the map recentering.
		 * only if the timer has not yet been created and the interval is greater than zero
		 */
		startSetCenterControlTimer: function()
		{
			if (this._setCenterTimer == null)
			{
				if (this._setCenterTimerInterval > 0)
				{
					if (dojo.config.fwm.debug == true)
					{
						console.log("[MyLocationTool] Starting timer with interval " + this._setCenterTimerInterval);
					}
					this._doStart();
				}
				else
				{
					if (dojo.config.fwm.debug == true)
					{
						console.log("[MyLocationTool] Interal must be greater than zero -- Start ignored.");
					}
				}
			}
			else
			{
				if (dojo.config.fwm.debug == true)
				{
					console.log("[MyLocationTool] Timer already started. Ignoring start");
				}
			}
		},

		/**
		 * Stops the timer
		 */
		stopSetCenterControlTimer: function()
		{
			if (this._setCenterTimer == null)
			{
				if (dojo.config.fwm.debug == true)
				{
					console.log("[MyLocationTool] Timer not started. Ignoring stop");
				}
			}
			else
			{
				if (dojo.config.fwm.debug == true)
				{
					console.log("[MyLocationTool] Stopping timer");
				}
				this._setCenterTimer.stop();
				this._setCenterTimer = null;
			}
		},
		getSetCenterInterval: function()
		{
			return this.map.mapConf.myLocationToolSetCenterInterval;
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/QueryUnassignedWorkTool':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/main", "dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/toolbar/ext/_ToggleTool",
	"dijit/form/Button"], function(dojo, declare, _ToggleTool, Button) {
	
	/**
	 * Query unassigned work tool
	 */
	return declare([_ToggleTool], {
		label: "Unassigned Work Orders",
		iconClass: "basicMapToolbarBtn unassignedWorkOrderMapToolbarBtn",
		map: null,
		layerLabel: null,
		constructor: function(params)
		{
			dojo.mixin(this, params);
			var _label = ibm.tivoli.fwm.i18n.getMaxMsg("map", "unassignedworktool");
			this.label = _label || this.label;
			this.addSubscription("onQueryUnassignedWorkResult_" + this.map.getId(), dojo.hitch(this, this.queryReturned));
			this.addSubscription("onWorkAssigned_" + this.map.getId(), dojo.hitch(this, this.onWorkAssigned));
			this.addSubscription("onQueryUnassignedWorkCancel_" + this.map.getId(), dojo.hitch(this, this.cancelQuery));
		},
		onWorkAssigned: function(data)
		{
			console.log("assigned!",data);
			
			if (this.isActive() == true)
			{
				dojo.publish("removeRecordsFromLayer_" + this.map.getId(), [ this.layerLabel, [data]]);	
			}
		},
		_lastQueryData: null,
		_lastQueryBounds: null,
		// Enables the Unassigned Work Orders tool (show unassigned work orders)
		executeOn: function()
		{
			this._lastQueryBounds = this.map.getBounds();
			this.map.getMaximo().showQueryUnassignedWorkDialog(this._lastQueryBounds);
		},
		// Disables the Unassigned Work Orders tool (hides unassigned work orders)
		executeOff: function()
		{
			this._clearUnassignedLayer();
		},
		_clearUnassignedLayer: function()
		{
			if (this.layerLabel != null)
			{
				dojo.publish("removeLayer_" + this.map.getId(), [ this.layerLabel ]);
			}
		},
		// Handles the response from the server when the OK button is clicked
		queryReturned: function(data, refreshOptions)
		{
			var isAutomaticRefresh = refreshOptions && refreshOptions.automatic;
			var avoidLayerEnabled = false;
			if (refreshOptions) // if this parameter exists, it's a refresh and we don't enable the layers
			{
				avoidLayerEnabled = true;
			}
			if(data==null){
				if (!isAutomaticRefresh)
				{
					this.map.getMaximo().showMessage("mapserver", "noworkordersinarea");
					this.setActive(false);
				}
				return;
			}
			this._lastQueryData = data.queryData;
			// If records were found, sends an event to create a layer and display
			// the records
			if (data.records.length == 0 && (!data.spatialEnabledRecords || data.spatialEnabledRecords.length == 0))
			{
				if (!isAutomaticRefresh)
				{
					if (data.error)
					{
						this.map.getMaximo().showMessage(data.error.group, data.error.key, [ data.error.params ]);
					}
					else
					{
						this.map.getMaximo().showMessage("mapserver", "noworkordersinarea");
					}
					this.setActive(false);
				}
			}
			else
			{
				this.layerLabel = data.layerLabel;
				if (data.spatialEnabledRecords != null && data.spatialEnabledRecords.length > 0)
				{
					var fct = function(mbos, errors)
					{
						console.log("mbos", mbos, errors);
						var records = data.records.concat(mbos);
						if (records.length == 0)
						{
							if (!isAutomaticRefresh)
							{
								this.setActive(false);
								this.map.getMaximo().showMessage("mapserver", "noworkordersinarea");
							}
						}
						else
						{
							this._addDefaultMarkerInfo(records);
							dojo.publish("addRecordsToLayer_" + this.map.getId(), [ data.layerLabel, records, true, null, null, avoidLayerEnabled ]);
						}
					};
					// handle spatial records
					this.map.filterRecordsInMapView(data.spatialEnabledRecords, dojo.hitch(this, fct));

				}
				else
				{
					var records = data.records;
					this._addDefaultMarkerInfo(records);
					dojo.publish("addRecordsToLayer_" + this.map.getId(), [ data.layerLabel, records, true, null, null, avoidLayerEnabled ]);
				}
			}

		},
		_addDefaultMarkerInfo: function(records)
		{
			var defaultUnassignedMarker = {
				"url": ibm.tivoli.fwm.mxmap.ImageLibraryManager.getImageLibraryManager().getResourcesPath() + "/symbology/workorder/map_WO_Unassigned.png",
				"offsetx": 24,
				"offsety": 36,
				"width": 47,
				"height": 36
			};
			for ( var i in records)
			{
				records[i].ownDefaultMarker = defaultUnassignedMarker;
			}
		},
		// Handles the response from the server when the cancel button is clicked
		cancelQuery: function(data)
		{
			this.setActive(false);
		},
		disable: function()
		{
		},
		destroy: function()
		{
			this.destroyRecursive();
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/layers/LayerWidget':function(){
	/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
define(["dojo/_base/declare", "ibm/tivoli/fwm/mxmap/_Base", "dijit/_Widget", "dijit/_Templated"], 
		function(declare, _Base, _Widget, _Templated) {
	
	ibm.tivoli.fwm.mxmap.layers.LayerWidget = declare([_Widget, _Templated], {
		templateString: dojo.cache("ibm.tivoli.fwm.mxmap", "templates/LayerWidget.html", "<div style=\"border: 1px solid #E0E0E0; border-bottom:0px\">\n<table style=\"width: 99%;height:35px;\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td data-dojo-attach-event=\"ondijitclick:_enableOrDisableLayer\" style=\"padding: 5px;\">\n\t\t\t\t<div data-dojo-attach-point=\"activeOrHiddenImage\"></div>\n\t\t\t</td>\n\t\t\t<td style=\"width: 90%;\" data-dojo-attach-event=\"ondijitclick:_enableOrDisableLayer\" >\n\t\t\t\t<div data-dojo-attach-point=\"layerInfo\"></div>\n\t\t\t</td>\n\t\t\t<td data-dojo-attach-event=\"ondijitclick:_showChildrenLayerWidget\" style=\"padding: 0px 4px 0px 12px; height: 35px;\">\n\t\t\t\t<div data-dojo-attach-point=\"submenu\" style=\"float:right;\"></div>\n\t\t\t</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>"),
		layer: null,
		_layerLeftImageDom: null,
		_layerRightImageDom: null,
		layerPanel: null,
		_symbologyPanelManager: null,
		constructor:function(params){
			dojo.mixin(this, params);				
		},
		postCreate:function(){	
			this.layerInfo.textContent = this.layer.getLayerName();
			this.setLeftIcon();
			this.setRightIcon();
			dojo.style(this.layerInfo, "float", (document.body.dir == "rtl") ? "right" : "left");
		},
		_showChildrenLayerWidget: function(){
			if(this.layer.hasChildren() == true){
				// When clicking on the arrow, enable the current layer (or symbology) if it was disabled
				if(this.layer.isDisabled())
				{
					this.layer.toggleState();
				}
				var _childPanelManager = new ibm.tivoli.fwm.mxmap.layers.LayerPanelWidget({map: this.layerPanel.map, tool: this.layerPanel.tool, title: this.layer.getChildrenTitle()});		
				_childPanelManager.updateLayers(this.layer.getChildren());
				this.layerPanel.close();
			}
		},
		_enableOrDisableLayer: function(){
			this.layer.toggleState();
			
			if(this.layerPanel && this.closeOnAction){
				this.layerPanel.close();
			}
			else
			{
				this.layerPanel.updateIcons();
			}
		},
		destroyRecursive: function(){
			this.inherited(arguments);
			if(this._layerImageDom){
				dojo.destroy(this._layerImageDom);
			}
			if(this._layerRightImageDom){
				dojo.destroy(this._layerRightImageDom);
			}
		},
		setLeftIcon: function()
		{
			var leftIconURL = this.layer.getLeftIconURL();
			if(leftIconURL != null)
			{
				// Since this is called both when creating and updating the widget,
				// we only create the image element if it doesn't already exist.
				if (this._layerLeftImageDom)
				{
					dojo.attr(this._layerLeftImageDom, "src", leftIconURL);
				}
				else
				{
					this._layerLeftImageDom = dojo.create("img",{src: leftIconURL},this.activeOrHiddenImage, "only");
					dojo.style(this._layerLeftImageDom, {opacity: 1.0, visibility: "visible"});
				}
			}
		},
		setRightIcon: function()
		{
			var rightIconURL = this.layer.getRightIconURL();
			this._layerRightImageDom = dojo.create("img",{src: rightIconURL},this.submenu,"last");
			// If the layer has no right icon, make it invisible in order to avoid showing a broken image icon.
			if(rightIconURL == null){
				dojo.style(this._layerRightImageDom, {visibility: "hidden"});
			}
		}
	});
	return ibm.tivoli.fwm.mxmap.layers.LayerWidget;
});

},
'dojo/uacss':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["./dom-geometry", "./_base/lang", "./domReady", "./sniff", "./_base/window"],
	function(geometry, lang, domReady, has, baseWindow){

	// module:
	//		dojo/uacss

	/*=====
	return {
		// summary:
		//		Applies pre-set CSS classes to the top-level HTML node, based on:
		//
		//		- browser (ex: dj_ie)
		//		- browser version (ex: dj_ie6)
		//		- box model (ex: dj_contentBox)
		//		- text direction (ex: dijitRtl)
		//
		//		In addition, browser, browser version, and box model are
		//		combined with an RTL flag when browser text is RTL. ex: dj_ie-rtl.
		//
		//		Returns the has() method.
	};
	=====*/

	var
		html = baseWindow.doc.documentElement,
		ie = has("ie"),
		trident = has("trident"),
		opera = has("opera"),
		maj = Math.floor,
		ff = has("ff"),
		boxModel = geometry.boxModel.replace(/-/,''),

		classes = {
			"dj_quirks": has("quirks"),

			// NOTE: Opera not supported by dijit
			"dj_opera": opera,

			"dj_khtml": has("khtml"),

			"dj_webkit": has("webkit"),
			"dj_safari": has("safari"),
			"dj_chrome": has("chrome"),
			"dj_edge": has("edge"),

			"dj_gecko": has("mozilla"),

			"dj_ios": has("ios"),
			"dj_android": has("android")
		}; // no dojo unsupported browsers

	if(ie){
		classes["dj_ie"] = true;
		classes["dj_ie" + maj(ie)] = true;
		classes["dj_iequirks"] = has("quirks");
	}
	if(trident){
		classes["dj_trident"] = true;
		classes["dj_trident" + maj(trident)] = true;
	}
	if(ff){
		classes["dj_ff" + maj(ff)] = true;
	}

	classes["dj_" + boxModel] = true;

	// apply browser, browser version, and box model class names
	var classStr = "";
	for(var clz in classes){
		if(classes[clz]){
			classStr += clz + " ";
		}
	}
	html.className = lang.trim(html.className + " " + classStr);

	// If RTL mode, then add dj_rtl flag plus repeat existing classes with -rtl extension.
	// We can't run the code below until the <body> tag has loaded (so we can check for dir=rtl).
	domReady(function(){
		if(!geometry.isBodyLtr()){
			var rtlClassStr = "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl ");
			html.className = lang.trim(html.className + " " + rtlClassStr + "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl "));
		}
	});
	return has;
});

},
'dijit/Tooltip':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/_base/fx", // fx.fadeIn fx.fadeOut
	"dojo/dom", // dom.byId
	"dojo/dom-class", // domClass.add
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/_base/lang", // lang.hitch lang.isArrayLike
	"dojo/mouse",
	"dojo/on",
	"dojo/sniff", // has("ie"), has("trident")
	"./_base/manager",	// manager.defaultDuration
	"./place",
	"./_Widget",
	"./_TemplatedMixin",
	"./BackgroundIframe",
	"dojo/text!./templates/Tooltip.html",
	"./main"		// sets dijit.showTooltip etc. for back-compat
], function(array, declare, fx, dom, domClass, domGeometry, domStyle, lang, mouse, on, has,
			manager, place, _Widget, _TemplatedMixin, BackgroundIframe, template, dijit){

	// module:
	//		dijit/Tooltip


	// TODO: Tooltip should really share more positioning code with TooltipDialog, like:
	//		- the orient() method
	//		- the connector positioning code in show()
	//		- the dijitTooltip[Dialog] class
	//
	// The problem is that Tooltip's implementation supplies it's own <iframe> and interacts directly
	// with dijit/place, rather than going through dijit/popup like TooltipDialog and other popups (ex: Menu).

	var MasterTooltip = declare("dijit._MasterTooltip", [_Widget, _TemplatedMixin], {
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: manager.defaultDuration,

		templateString: template,

		postCreate: function(){
			this.ownerDocumentBody.appendChild(this.domNode);

			this.bgIframe = new BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = fx.fadeIn({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onShow") });
			this.fadeOut = fx.fadeOut({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onHide") });
		},

		show: function(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if rtl == true)
			// innerHTML: String
			//		Contents of the tooltip
			// aroundNode: DomNode|dijit/place.__Rectangle
			//		Specifies that tooltip should be next to this node / area
			// position: String[]?
			//		List of positions to try to position tooltip (ex: ["right", "above"])
			// rtl: Boolean?
			//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
			//		means "rtl"; specifies GUI direction, not text direction.
			// textDir: String?
			//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
			// onMouseEnter: Function?
			//		Callback function for mouse enter on tooltip
			// onMouseLeave: Function?
			//		Callback function for mouse leave on tooltip

			if(this.aroundNode && this.aroundNode === aroundNode && this.containerNode.innerHTML == innerHTML){
				return;
			}

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;

			if(textDir){
				this.set("textDir", textDir);
			}

			this.containerNode.align = rtl? "right" : "left"; //fix the text alignment

			var pos = place.around(this.domNode, aroundNode,
				position && position.length ? position : Tooltip.defaultPosition, !rtl, lang.hitch(this, "orient"));

			// Position the tooltip connector for middle alignment.
			// This could not have been done in orient() since the tooltip wasn't positioned at that time.
			var aroundNodeCoords = pos.aroundNodePos;
			if(pos.corner.charAt(0) == 'M' && pos.aroundCorner.charAt(0) == 'M'){
				this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
				this.connectorNode.style.left = "";
			}else if(pos.corner.charAt(1) == 'M' && pos.aroundCorner.charAt(1) == 'M'){
				this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
			}else{
				// Not *-centered, but just above/below/after/before
				this.connectorNode.style.left = "";
				this.connectorNode.style.top = "";
			}

			// show it
			domStyle.set(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;

			this.onMouseEnter = onMouseEnter || noop;
			this.onMouseLeave = onMouseLeave || noop;
		},

		orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ tooltipCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.   It will also reduce the tooltip's
			//		width to whatever width is available
			// tags:
			//		protected

			this.connectorNode.style.top = ""; //reset to default

			var heightAvailable = spaceAvailable.h,
				widthAvailable = spaceAvailable.w;

			node.className = "dijitTooltip " +
				{
					"MR-ML": "dijitTooltipRight",
					"ML-MR": "dijitTooltipLeft",
					"TM-BM": "dijitTooltipAbove",
					"BM-TM": "dijitTooltipBelow",
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];

			// reset width; it may have been set by orient() on a previous tooltip show()
			this.domNode.style.width = "auto";

			// Reduce tooltip's width to the amount of width available, so that it doesn't overflow screen.
			// Note that sometimes widthAvailable is negative, but we guard against setting style.width to a
			// negative number since that causes an exception on IE.
			var size = domGeometry.position(this.domNode);
			if(has("ie") || has("trident")){
				// workaround strange IE bug where setting width to offsetWidth causes words to wrap
				size.w += 2;
			}

			var width = Math.min((Math.max(widthAvailable,1)), size.w);

			domGeometry.setMarginBox(this.domNode, {w: width});

			// Reposition the tooltip connector.
			if(tooltipCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B'){
				var bb = domGeometry.position(node);
				var tooltipConnectorHeight = this.connectorNode.offsetHeight;
				if(bb.h > heightAvailable){
					// The tooltip starts at the top of the page and will extend past the aroundNode
					var aroundNodePlacement = heightAvailable - ((aroundNodeCoords.h + tooltipConnectorHeight) >> 1);
					this.connectorNode.style.top = aroundNodePlacement + "px";
					this.connectorNode.style.bottom = "";
				}else{
					// Align center of connector with center of aroundNode, except don't let bottom
					// of connector extend below bottom of tooltip content, or top of connector
					// extend past top of tooltip content
					this.connectorNode.style.bottom = Math.min(
						Math.max(aroundNodeCoords.h/2 - tooltipConnectorHeight/2, 0),
						bb.h - tooltipConnectorHeight) + "px";
					this.connectorNode.style.top = "";
				}
			}else{
				// reset the tooltip back to the defaults
				this.connectorNode.style.top = "";
				this.connectorNode.style.bottom = "";
			}

			return Math.max(0, size.w - widthAvailable);
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(has("ie")){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip

			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}

			this.onMouseEnter = this.onMouseLeave = noop;
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			this.containerNode.innerHTML="";
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		}
	});

	if(has("dojo-bidi")){
		MasterTooltip.extend({
			_setAutoTextDir: function(/*Object*/node){
				// summary:
				//		Resolve "auto" text direction for children nodes
				// tags:
				//		private

				this.applyTextDir(node);
				array.forEach(node.children, function(child){ this._setAutoTextDir(child); }, this);
			},

			_setTextDirAttr: function(/*String*/ textDir){
				// summary:
				//		Setter for textDir.
				// description:
				//		Users shouldn't call this function; they should be calling
				//		set('textDir', value)
				// tags:
				//		private

				this._set("textDir", textDir);

				if (textDir == "auto"){
					this._setAutoTextDir(this.containerNode);
				}else{
					this.containerNode.dir = this.textDir;
				}
			}
		});
	}

	dijit.showTooltip = function(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave){
		// summary:
		//		Static method to display tooltip w/specified contents in specified position.
		//		See description of dijit/Tooltip.defaultPosition for details on position parameter.
		//		If position is not specified then dijit/Tooltip.defaultPosition is used.
		// innerHTML: String
		//		Contents of the tooltip
		// aroundNode: place.__Rectangle
		//		Specifies that tooltip should be next to this node / area
		// position: String[]?
		//		List of positions to try to position tooltip (ex: ["right", "above"])
		// rtl: Boolean?
		//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
		//		means "rtl"; specifies GUI direction, not text direction.
		// textDir: String?
		//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
		// onMouseEnter: Function?
		//		Callback function for mouse over on tooltip
		// onMouseLeave: Function?
		//		Callback function for mouse leave on tooltip

		// After/before don't work, but for back-compat convert them to the working after-centered, before-centered.
		// Possibly remove this in 2.0.   Alternately, get before/after to work.
		if(position){
			position = array.map(position, function(val){
				return {after: "after-centered", before: "before-centered"}[val] || val;
			});
		}

		if(!Tooltip._masterTT){ dijit._masterTT = Tooltip._masterTT = new MasterTooltip(); }
		return Tooltip._masterTT.show(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave);
	};

	dijit.hideTooltip = function(aroundNode){
		// summary:
		//		Static method to hide the tooltip displayed via showTooltip()
		return Tooltip._masterTT && Tooltip._masterTT.hide(aroundNode);
	};

	// Possible states for a tooltip, see Tooltip.state property for definitions
	var DORMANT = "DORMANT",
		SHOW_TIMER = "SHOW TIMER",
		SHOWING = "SHOWING",
		HIDE_TIMER = "HIDE TIMER";

	function noop(){}

	var Tooltip = declare("dijit.Tooltip", _Widget, {
		// summary:
		//		Pops up a tooltip (a help message) when you hover over a node.
		//		Also provides static show() and hide() methods that can be used without instantiating a dijit/Tooltip.

		// label: String
		//		HTML to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// hideDelay: Integer
		//		Number of milliseconds to wait after unhovering the object, before
		//		the tooltip is hidden.  Note that blurring an object hides the tooltip immediately.
		hideDelay: 400,

		// connectId: String|String[]|DomNode|DomNode[]
		//		Id of domNode(s) to attach the tooltip to.
		//		When user hovers over specified dom node(s), the tooltip will appear.
		connectId: [],

		// position: String[]
		//		See description of `dijit/Tooltip.defaultPosition` for details on position parameter.
		position: [],

		// selector: String?
		//		CSS expression to apply this Tooltip to descendants of connectIds, rather than to
		//		the nodes specified by connectIds themselves.    Useful for applying a Tooltip to
		//		a range of rows in a table, tree, etc.   Use in conjunction with getContent() parameter.
		//		Ex: connectId: myTable, selector: "tr", getContent: function(node){ return ...; }
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		selector: "",

		// TODO: in 2.0 remove support for multiple connectIds.   selector gives the same effect.
		// So, change connectId to a "", remove addTarget()/removeTarget(), etc.

		_setConnectIdAttr: function(/*String|String[]|DomNode|DomNode[]*/ newId){
			// summary:
			//		Connect to specified node(s)

			// Remove connections to old nodes (if there are any)
			array.forEach(this._connections || [], function(nested){
				array.forEach(nested, function(handle){ handle.remove(); });
			}, this);

			// Make array of id's to connect to, excluding entries for nodes that don't exist yet, see startup()
			this._connectIds = array.filter(lang.isArrayLike(newId) ? newId : (newId ? [newId] : []),
					function(id){ return dom.byId(id, this.ownerDocument); }, this);

			// Make connections
			this._connections = array.map(this._connectIds, function(id){
				var node = dom.byId(id, this.ownerDocument),
					selector = this.selector,
					delegatedEvent = selector ?
						function(eventType){ return on.selector(selector, eventType); } :
						function(eventType){ return eventType; },
					self = this;
				return [
					on(node, delegatedEvent(mouse.enter), function(){
						self._onHover(this);
					}),
					on(node, delegatedEvent("focusin"), function(){
						self._onHover(this);
					}),
					on(node, delegatedEvent(mouse.leave), lang.hitch(self, "_onUnHover")),
					on(node, delegatedEvent("focusout"), lang.hitch(self, "set", "state", DORMANT))
				];
			}, this);

			this._set("connectId", newId);
		},

		addTarget: function(/*DomNode|String*/ node){
			// summary:
			//		Attach tooltip to specified node if it's not already connected

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node;
			if(array.indexOf(this._connectIds, id) == -1){
				this.set("connectId", this._connectIds.concat(id));
			}
		},

		removeTarget: function(/*DomNode|String*/ node){
			// summary:
			//		Detach tooltip from specified node

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node,	// map from DOMNode back to plain id string
				idx = array.indexOf(this._connectIds, id);
			if(idx >= 0){
				// remove id (modifies original this._connectIds but that's OK in this case)
				this._connectIds.splice(idx, 1);
				this.set("connectId", this._connectIds);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode,"dijitTooltipData");
		},

		startup: function(){
			this.inherited(arguments);

			// If this tooltip was created in a template, or for some other reason the specified connectId[s]
			// didn't exist during the widget's initialization, then connect now.
			var ids = this.connectId;
			array.forEach(lang.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
		},

		getContent: function(/*DomNode*/ node){
			// summary:
			//		User overridable function that return the text to display in the tooltip.
			// tags:
			//		extension
			return this.label || this.domNode.innerHTML;
		},

		// state: [private readonly] String
		//		One of:
		//
		//		- DORMANT: tooltip not SHOWING
		//		- SHOW TIMER: tooltip not SHOWING but timer set to show it
		//		- SHOWING: tooltip displayed
		//		- HIDE TIMER: tooltip displayed, but timer set to hide it
		state: DORMANT,
		_setStateAttr: function(val){
			if(this.state == val ||
				(val == SHOW_TIMER && this.state == SHOWING) ||
				(val == HIDE_TIMER && this.state == DORMANT)){
				return;
			}

			if(this._hideTimer){
				this._hideTimer.remove();
				delete this._hideTimer;
			}
			if(this._showTimer){
				this._showTimer.remove();
				delete this._showTimer;
			}

			switch(val){
				case DORMANT:
					if(this._connectNode){
						Tooltip.hide(this._connectNode);
						delete this._connectNode;
						this.onHide();
					}
					break;
				case SHOW_TIMER:	 // set timer to show tooltip
					// should only get here from a DORMANT state, i.e. tooltip can't be already SHOWING
					if(this.state != SHOWING){
						this._showTimer = this.defer(function(){ this.set("state", SHOWING); }, this.showDelay);
					}
					break;
				case SHOWING:		// show tooltip and clear timers
					var content = this.getContent(this._connectNode);
					if(!content){
						this.set("state", DORMANT);
						return;
					}

					// Show tooltip and setup callbacks for mouseenter/mouseleave of tooltip itself
					Tooltip.show(content, this._connectNode, this.position, !this.isLeftToRight(), this.textDir,
						lang.hitch(this, "set", "state", SHOWING), lang.hitch(this, "set", "state", HIDE_TIMER));

					this.onShow(this._connectNode, this.position);
					break;
				case HIDE_TIMER:	// set timer set to hide tooltip
					this._hideTimer = this.defer(function(){ this.set("state", DORMANT); }, this.hideDelay);
					break;
			}

			this._set("state", val);
		},

		_onHover: function(/*DomNode*/ target){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private

			if(this._connectNode && target != this._connectNode){
				// Tooltip is displaying for another node
				this.set("state", DORMANT);
			}
			this._connectNode = target;		// _connectNode means "tooltip currently displayed for this node"

			this.set("state", SHOW_TIMER);	// no-op if show-timer already set, or if already showing
		},

		_onUnHover: function(/*DomNode*/ target){
			// summary:
			//		Handles mouseleave event on the target node, hiding the tooltip.
			// tags:
			//		private

			this.set("state", HIDE_TIMER);		// no-op if already dormant, or if hide-timer already set
		},

		// open() and close() aren't used anymore, except from the _BidiSupport/misc/Tooltip test.
		// Should probably remove for 2.0, but leaving for now.
		open: function(/*DomNode*/ target){
			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			this.set("state", DORMANT);
			this._connectNode = target;		// _connectNode means "tooltip currently displayed for this node"
			this.set("state", SHOWING);
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			this.set("state", DORMANT);
		},

		onShow: function(/*===== target, position =====*/){
			// summary:
			//		Called when the tooltip is shown
			// tags:
			//		callback
		},

		onHide: function(){
			// summary:
			//		Called when the tooltip is hidden
			// tags:
			//		callback
		},

		destroy: function(){
			this.set("state", DORMANT);

			// Remove connections manually since they aren't registered to be removed by _WidgetBase
			array.forEach(this._connections || [], function(nested){
				array.forEach(nested, function(handle){ handle.remove(); });
			}, this);

			this.inherited(arguments);
		}
	});

	Tooltip._MasterTooltip = MasterTooltip;		// for monkey patching
	Tooltip.show = dijit.showTooltip;		// export function through module return value
	Tooltip.hide = dijit.hideTooltip;		// export function through module return value

	Tooltip.defaultPosition = ["after-centered", "before-centered"];

	/*=====
	lang.mixin(Tooltip, {
		 // defaultPosition: String[]
		 //		This variable controls the position of tooltips, if the position is not specified to
		 //		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the values
		 //		possible for `dijit/place.around()`.   The recommended values are:
		 //
		 //		- before-centered: centers tooltip to the left of the anchor node/widget, or to the right
		 //		  in the case of RTL scripts like Hebrew and Arabic
		 //		- after-centered: centers tooltip to the right of the anchor node/widget, or to the left
		 //		  in the case of RTL scripts like Hebrew and Arabic
		 //		- above-centered: tooltip is centered above anchor node
		 //		- below-centered: tooltip is centered above anchor node
		 //
		 //		The list is positions is tried, in order, until a position is found where the tooltip fits
		 //		within the viewport.
		 //
		 //		Be careful setting this parameter.  A value of "above-centered" may work fine until the user scrolls
		 //		the screen so that there's no room above the target node.   Nodes with drop downs, like
		 //		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
		 //		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
		 //		is only room below (or above) the target node, but not both.
	 });
	=====*/
	return Tooltip;
});

},
'dojo/string':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"./_base/kernel",	// kernel.global
	"./_base/lang"
], function(kernel, lang){

// module:
//		dojo/string
var ESCAPE_REGEXP = /[&<>'"\/]/g;
var ESCAPE_MAP = {
	'&': '&amp;',
	'<': '&lt;',
	'>': '&gt;',
	'"': '&quot;',
	"'": '&#x27;',
	'/': '&#x2F;'
};
var string = {
	// summary:
	//		String utilities for Dojo
};
lang.setObject("dojo.string", string);

string.escape = function(/*String*/str){
	// summary:
	//		Efficiently escape a string for insertion into HTML (innerHTML or attributes), replacing &, <, >, ", ', and / characters.
	// str:
	//		the string to escape
	if(!str){ return ""; }
	return str.replace(ESCAPE_REGEXP, function(c) {
		return ESCAPE_MAP[c];
	});
};

// Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt#Polyfill
string.codePointAt = String.prototype.codePointAt ?
	function (str, position) {
		return String.prototype.codePointAt.call(str, position);
	} :
	function(str, position) {
		if (str == null) {
			throw new TypeError('codePointAt called on null or undefined');
		}

		var size;
		var first;
		var second;
		var index;

		str = String(str);
		size = str.length;
		// `ToInteger`
		index = position ? Number(position) : 0;

		if (index != index) { // better `isNaN`
			index = 0;
		}

		// Account for out-of-bounds indices:
		if (index < 0 || index >= size) {
			return undefined;
		}

		// Get the first code unit
		first = str.charCodeAt(index);

		// check if it's the start of a surrogate pair
		if (first >= 0xD800 && first <= 0xDBFF && // high surrogate
			size > index + 1 // there is a next code unit
		) {
			second = str.charCodeAt(index + 1);
			if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
				// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
				return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
			}
		}

		return first;
	};

// Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint#Polyfill
string.fromCodePoint = String.fromCodePoint || function () {
	var codeUnits = [];
	var codeLen = 0;
	var result = "";
	var codePoint;
	var index;

	for (index = 0, len = arguments.length; index !== len; ++index) {
		codePoint = +arguments[index];
		// correctly handles all cases including `NaN`, `-Infinity`, `+Infinity`
		// The surrounding `!(...)` is required to correctly handle `NaN` cases
		// The (codePoint>>>0) === codePoint clause handles decimals and negatives
		if (!(codePoint < 0x10FFFF && (codePoint>>>0) === codePoint)) {
			throw RangeError("Invalid code point: " + codePoint);
		}

		if (codePoint <= 0xFFFF) { // BMP code point
			codeLen = codeUnits.push(codePoint);
		} else { // Astral code point; split in surrogate halves
			// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
			codePoint -= 0x10000;
			codeLen = codeUnits.push(
				(codePoint >> 10) + 0xD800,  // highSurrogate
				(codePoint % 0x400) + 0xDC00 // lowSurrogate
			);
		}

		if (codeLen >= 0x3fff) {
			result += String.fromCharCode.apply(null, codeUnits);
			codeUnits.length = 0;
		}
	}

	return result + String.fromCharCode.apply(null, codeUnits);
};

string.rep = function(/*String*/str, /*Integer*/num){
	// summary:
	//		Efficiently replicate a string `n` times.
	// str:
	//		the string to replicate
	// num:
	//		number of times to replicate the string

	if(num <= 0 || !str){ return ""; }

	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	// summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	// text:
	//		the string to pad
	// size:
	//		length to provide padding
	// ch:
	//		character to pad, defaults to '0'
	// end:
	//		adds padding at the end if true, otherwise pads at start
	// example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

string.substitute = function(	/*String*/		template,
									/*Object|Array*/map,
									/*Function?*/	transform,
									/*Object?*/		thisObject){
	// summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	// template:
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive.
	//		The special sequence `${}` can be used escape `$`.
	// map:
	//		hash to search for substitutions
	// transform:
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	// thisObject:
	//		where to look for optional format function; default to the global
	//		namespace
	// example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	// example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	// example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || kernel.global;
	transform = transform ?
		lang.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]*)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			if (key == ''){
				return '$';
			}
			var value = lang.getObject(key, false, map);
			if(format){
				value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			var result = transform(value, key);

			if (typeof result === 'undefined') {
				throw new Error('string.substitute could not find key "' + key + '" in template');
			}

			return result.toString();
		}); // String
};

string.trim = String.prototype.trim ?
	lang.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

/*=====
 string.trim = function(str){
	 // summary:
	 //		Trims whitespace from both sides of the string
	 // str: String
	 //		String to be trimmed
	 // returns: String
	 //		Returns the trimmed string
	 // description:
	 //		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	 //		The short yet performant version of this function is dojo/_base/lang.trim(),
	 //		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	 return "";	// String
 };
 =====*/

	return string;
});

},
'ibm/tivoli/fwm/mxmap/routing/RouterFactory':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Base"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.routing.RouterFactory");
dojo.require("ibm.tivoli.fwm.mxmap._Base");
/**
 * This class creates a new Router implementation based on the current map provider.
 */

dojo.declare("ibm.tivoli.fwm.mxmap.routing.RouterFactory", ibm.tivoli.fwm.mxmap._Base, {
	provider:null,
	router:null,
	map:null,
	constructor:function(params){
		dojo.mixin(this,params);
	},
	createRouter:function(params){
		var routerName ="ibm.tivoli.fwm.mxmap.routing.impl."+this.provider;		
		var reqStr = "dojo." + "require('" + routerName+ "')"; // breaking up dojo. and require necessary to fool the dojo parser!

		eval(reqStr);
		//trying to keep one instance of bing maps and google maps only;
		if(this.router!=null)
		{
			return this.router;
		}

		var me = this;
		var routerPromise = new Promise(function(resolve, reject) {
			dojo.ready(function() {
				me._params=params;
				var itemDijitStr = " me._routerInstance = new ibm.tivoli.fwm.mxmap.routing.impl."+me.provider+"(me._params)";
				eval(itemDijitStr);
				me.router = me._routerInstance;
				me._routerInstance.init();
				resolve(me._routerInstance);
			});
		});

		return routerPromise;
	}
});

});

},
'ibm/tivoli/fwm/mxmap/routing/itinerary/Leg':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */


define([
	"dojo/_base/declare",
	"dojo/main",
	"ibm/tivoli/fwm/mxmap/_Base",
	"dijit/_Widget",
	"dijit/_Templated",
	"ibm/tivoli/fwm/mxmap/routing/itinerary/Step",
	"ibm/tivoli/fwm/mxmap/routing/Router"], function(declare, dojo, _Base, _Widget, _Templated, Step, Router) {
	return declare([_Widget, _Templated, _Base], {
		templateString: dojo.cache("ibm.tivoli.fwm.mxmap", "templates/Leg.html", "<div  style=\"width:100%;margin-bottom:10px;\">\n<div data-dojo-attach-point=\"distanceNode\" style=\"text-align: center;width: 100%;\"></div>\n<div data-dojo-attach-point=\"stepsNode\"></div>\n<div data-dojo-attach-event=\"ondijitclick:_onClick\" data-dojo-attach-point=\"legInfo\" style=\"background-color: #FAFAFA;border: 1px solid #E0E0E0;margin: 1px;padding: 10px 2px;\">\n<span data-dojo-attach-point=\"markerNode\" style=\"float:left;margin-top:-10px\"></span>\n<span data-dojo-attach-point=\"endLocDescNode\"></span>\n</div>\n</div>"),
		location: null,
		info: null,
		marker: null,
		steps: [],
		stepWidgets: [],
		needsToGeocode: null,
		distanceToLeg: null,
		durationToLeg: null,
		distanceUnit: null,
		map: null,
		// Maximum icon width used to determine the margins left and right
		_maxMarkerImageWidth: 47,
		setMap: function(map)
		{
			this.map = map;
		},
		constructor: function(params)
		{
			dojo.mixin(this, params);
			this.steps = [];
			this.stepWidgets = [];
		},
		postCreate: function()
		{
			this.addressLoading = ibm.tivoli.fwm.i18n.getMaxMsg("map", "address_being_loaded");
			this.failedToLoadAddress = ibm.tivoli.fwm.i18n.getMaxMsg("map", "address_info_not_found");

			if (this.distanceToLeg != null)
			{

				this.distanceNode.innerHTML = ibm.tivoli.fwm.mxmap.routing.DistanceUnit.formatDistance(this.distanceToLeg, this.distanceUnit);
				this.distanceNode.innerHTML += " - ";
			}
			if (this.durationToLeg != null)
			{
				this.distanceNode.innerHTML += ibm.tivoli.fwm.mxmap.routing.DistanceUnit.formatTime(this.durationToLeg);
			}
			if (this.marker != null)
			{
				dojo.create("img", {
					src: (this.marker.iconUrl != undefined) ? this.marker.iconUrl : this.marker.icon
				}, this.markerNode, "only");
				var markerLabel = (this.marker.labelText != undefined) ? this.marker.labelText : this.marker.label;
				var markerIconSize = (this.marker.attributes.iconSize != undefined) ? this.marker.attributes.iconSize : this.marker.iconSize;
				var markerIconAnchor = (this.marker.attributes.iconAnchor != undefined) ? this.marker.attributes.iconAnchor : this.marker.iconAnchor;
				if (markerLabel)
				{
					var numberOfDigitsOffset = this._calculateLabelOffset(markerLabel);
					var _left;
					var _top;
					if (dojo.isIE)
					{
						// Workaround to overcome the IE "float left" problem
						_left = markerIconAnchor[0] - numberOfDigitsOffset;
						_top = 6 - markerIconSize[1];
					}
					else
					{
						_top = 9;
						_left = markerIconAnchor[0] + 4 + numberOfDigitsOffset;
					}
					_left += "px";
					_top += "px";
					dojo.create("div", {
						innerHTML: markerLabel,
						style: {
							"float": "left",
							"left": _left,
							"top": _top,
							"position": "relative",
							"color": "white"
						}
					}, this.markerNode, "last");
				}
				// 12-12808. Adjust the markerNode width so that all markers in the route directions dialog are aligned
				var maxMarkerNodeMargin = Math.floor(this._maxMarkerImageWidth/2);
				var currentMarkerNodeMargin = markerIconSize[0] - markerIconAnchor[0];
				if(currentMarkerNodeMargin < maxMarkerNodeMargin)
				{
					var marginAdjustment = (maxMarkerNodeMargin - currentMarkerNodeMargin) + "px";
					dojo.style(this.markerNode, "marginLeft", marginAdjustment);
					dojo.style(this.markerNode, "marginRight", marginAdjustment);
				}
			}
			if (this.info || this.needsToGeocode == true)
			{
				if (this.needsToGeocode == true)
				{
					var fctSuccess = function(location)
					{
						var address = location[0].formattedAddress;
						this.endLocDescNode.innerHTML = address;
						this.needsToGeocode = false;
						this.info = address;
					};
					var fctError = function(location)
					{
						this.endLocDescNode.innerHTML = this.failedToLoadAddress;
					};
					this.map.geocoder.reverseGeocode(this.location.lat, this.location.lng, dojo.hitch(this, fctSuccess), dojo.hitch(this, fctError));
					this.endLocDescNode.innerHTML = this.addressLoading;
				}
				else
				{
					this.endLocDescNode.innerHTML = this.info;
				}
			}
			for ( var i = 0; i < this.steps.length; i++)
			{
				var step = this.steps[i];
				step.position = i + 1;
				step.distanceUnit = this.distanceUnit;
				step.map = this.map;
				step.closeDialog = this.closeDialog;
				var legWidget = new ibm.tivoli.fwm.mxmap.routing.itinerary.Step(step, this.map);
				dojo.place(legWidget.domNode, this.stepsNode, 'last');
				this.stepWidgets.push(legWidget);
			}
		},
		_onClick: function(evt)
		{
			console.log("Clicked on leg ", this.location);
			this.map.setCenter(this.location);
			this.closeDialog();

		},
		// Workaround to shift the label text (number) to the right in case it has more than 1 digit
		// in order to center it inside the marker image.
		_calculateLabelOffset: function(labelText)
		{
			var labelOffset = 0;
			var labelNumber = parseInt(labelText);
			if( (labelNumber/100) >= 1 )
			{
				labelOffset = 7;
			}
			else if((labelNumber/10) >= 1)
			{
				labelOffset = 4;
			}
			return labelOffset;
		}
	});
});

},
'dijit/form/DropDownButton':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/_base/kernel",
	"dojo/_base/lang", // hitch
	"dojo/query", // query
	"../registry", // registry.byNode
	"../popup", // dijit.popup2.hide
	"./Button",
	"../_Container",
	"../_HasDropDown",
	"dojo/text!./templates/DropDownButton.html",
	"../a11yclick"	// template uses ondijitclick
], function(declare, kernel, lang, query, registry, popup, Button, _Container, _HasDropDown, template){

	// module:
	//		dijit/form/DropDownButton

	return declare("dijit.form.DropDownButton", [Button, _Container, _HasDropDown], {
		// summary:
		//		A button with a drop down
		//
		// example:
		// |	<button data-dojo-type="dijit/form/DropDownButton">
		// |		Hello world
		// |		<div data-dojo-type="dijit/Menu">...</div>
		// |	</button>
		//
		// example:
		// |	var button1 = new DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
		// |	win.body().appendChild(button1);
		//

		baseClass: "dijitDropDownButton",

		templateString: template,

		_fillContent: function(){
			// Overrides _TemplatedMixin#_fillContent().
			// My inner HTML possibly contains both the button label and/or a drop down widget, like
			// <DropDownButton>  <span>push me</span>  <Menu> ... </Menu> </DropDownButton>

			var source = this.srcNodeRef;
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					var child = source.firstChild;
					if(child.hasAttribute && (child.hasAttribute("data-dojo-type") || child.hasAttribute("dojoType") ||
							child.hasAttribute("data-" + kernel._scopeName + "-type") ||
							child.hasAttribute(kernel._scopeName + "Type"))){
						// The parser hasn't gotten to this node yet, so save it in a wrapper <div>
						// and then grab the instantiated widget in startup().
						this.dropDownContainer = this.ownerDocument.createElement("div");
						this.dropDownContainer.appendChild(child);
					}else{
						dest.appendChild(child);
					}
				}
			}
		},

		startup: function(){
			if(this._started){
				return;
			}

			// the child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
			// make it invisible, and store a reference to pass to the popup code.
			if(!this.dropDown && this.dropDownContainer){
				this.dropDown = registry.byNode(this.dropDownContainer.firstChild);
				delete this.dropDownContainer;
			}
			if(this.dropDown){
				popup.hide(this.dropDown);
			}

			this.inherited(arguments);
		},

		isLoaded: function(){
			// Returns whether or not we are loaded - if our dropdown has an href,
			// then we want to check that.
			var dropDown = this.dropDown;
			return (!!dropDown && (!dropDown.href || dropDown.isLoaded));
		},

		loadDropDown: function(/*Function*/ callback){
			// Default implementation assumes that drop down already exists,
			// but hasn't loaded it's data (ex: ContentPane w/href).
			// App must override if the drop down is lazy-created.
			var dropDown = this.dropDown;
			var handler = dropDown.on("load", lang.hitch(this, function(){
				handler.remove();
				callback();
			}));
			dropDown.refresh();		// tell it to load
		},

		isFocusable: function(){
			// Overridden so that focus is handled by the _HasDropDown mixin, not by
			// the _FormWidget mixin.
			return this.inherited(arguments) && !this._mouseDown;
		}
	});
});

},
'dijit/form/_FormValueMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/keys", // keys.ESCAPE
	"dojo/_base/lang",
	"dojo/on",
	"dojo/sniff", // has("webkit")
	"./_FormWidgetMixin"
], function(declare, domAttr, keys, lang, on, has, _FormWidgetMixin){

	// module:
	//		dijit/form/_FormValueMixin

	return declare("dijit.form._FormValueMixin", _FormWidgetMixin, {
		// summary:
		//		Mixin for widgets corresponding to native HTML elements such as `<input>` or `<select>`
		//		that have user changeable values.
		// description:
		//		Each _FormValueMixin represents a single input value, and has a (possibly hidden) `<input>` element,
		//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
		//		works as expected.

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,

		_setReadOnlyAttr: function(/*Boolean*/ value){
			// IE has a Caret Browsing mode (hit F7 to activate) where disabled textboxes can be modified
			// focusNode enforced readonly if currently disabled to avoid this issue.
			if (has('trident') && 'disabled' in this) {
				domAttr.set(this.focusNode, 'readOnly', value || this.disabled);
			} else {
				domAttr.set(this.focusNode, 'readOnly', value);
			}
			this._set("readOnly", value);
		},

		postCreate: function(){
			this.inherited(arguments);

			// Update our reset value if it hasn't yet been set (because this.set()
			// is only called when there *is* a value)
			if(this._resetValue === undefined){
				this._lastValueReported = this._resetValue = this.value;
			}
		},

		_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the widget.
			//		If the value has changed, then fire onChange event, unless priorityChange
			//		is specified as null (or false?)
			this._handleOnChange(newValue, priorityChange);
		},

		_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Called when the value of the widget has changed.  Saves the new value in this.value,
			//		and calls onChange() if appropriate.   See _FormWidget._handleOnChange() for details.
			this._set("value", newValue);
			this.inherited(arguments);
		},

		undo: function(){
			// summary:
			//		Restore the value to the last value passed to onChange
			this._setValueAttr(this._lastValueReported, false);
		},

		reset: function(){
			// summary:
			//		Reset the widget's value to what it was at initialization time
			this._hasBeenBlurred = false;
			this._setValueAttr(this._resetValue, true);
		}
	});
});

},
'dijit/form/_FormWidgetMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-style", // domStyle.get
	"dojo/_base/lang", // lang.hitch lang.isArray
	"dojo/mouse", // mouse.isLeft
	"dojo/on",
	"dojo/sniff", // has("webkit")
	"dojo/window", // winUtils.scrollIntoView
	"../a11y"    // a11y.hasDefaultTabStop
], function(array, declare, domAttr, domStyle, lang, mouse, on, has, winUtils, a11y){

	// module:
	//		dijit/form/_FormWidgetMixin

	return declare("dijit.form._FormWidgetMixin", null, {
		// summary:
		//		Mixin for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,
		//		which can be children of a `<form>` node or a `dijit/form/Form` widget.
		//
		// description:
		//		Represents a single HTML element.
		//		All these widgets should have these attributes just like native HTML input elements.
		//		You can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.
		//
		//		They also share some common methods.

		// name: [const] String
		//		Name used when submitting form; same as "name" attribute or plain HTML elements
		name: "",

		// alt: String
		//		Corresponds to the native HTML `<input>` element's attribute.
		alt: "",

		// value: String
		//		Corresponds to the native HTML `<input>` element's attribute.
		value: "",

		// type: [const] String
		//		Corresponds to the native HTML `<input>` element's attribute.
		type: "text",

		// type: String
		//		Apply aria-label in markup to the widget's focusNode
		"aria-label": "focusNode",

		// tabIndex: String
		//		Order fields are traversed when user hits the tab key
		tabIndex: "0",
		_setTabIndexAttr: "focusNode", // force copy even when tabIndex default value, needed since Button is <span>

		// disabled: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "disabled='disabled'", or just "disabled".
		disabled: false,

		// intermediateChanges: Boolean
		//		Fires onChange for each value change or only on demand
		intermediateChanges: false,

		// scrollOnFocus: Boolean
		//		On focus, should this widget scroll into view?
		scrollOnFocus: true,

		// Override _WidgetBase mapping id to this.domNode, needs to be on focusNode so <label> etc.
		// works with screen reader
		_setIdAttr: "focusNode",

		_setDisabledAttr: function(/*Boolean*/ value){
			this._set("disabled", value);

			// Set disabled property if focusNode is an <input>, but aria-disabled attribute if focusNode is a <span>.
			// Can't use "disabled" in this.focusNode as a test because on IE, that's true for all nodes.
			if(/^(button|input|select|textarea|optgroup|option|fieldset)$/i.test(this.focusNode.tagName)){
				domAttr.set(this.focusNode, 'disabled', value);
				// IE has a Caret Browsing mode (hit F7 to activate) where disabled textboxes can be modified
				// textboxes marked readonly if disabled to avoid this issue.
				if (has('trident') && 'readOnly' in this) {
					domAttr.set(this.focusNode, 'readonly', value || this.readOnly);
				}
			}else{
				this.focusNode.setAttribute("aria-disabled", value ? "true" : "false");
			}

			// And also set disabled on the hidden <input> node
			if(this.valueNode){
				domAttr.set(this.valueNode, 'disabled', value);
			}

			if(value){
				// reset these, because after the domNode is disabled, we can no longer receive
				// mouse related events, see #4200
				this._set("hovering", false);
				this._set("active", false);

				// clear tab stop(s) on this widget's focusable node(s)  (ComboBox has two focusable nodes)
				var attachPointNames = "tabIndex" in this.attributeMap ? this.attributeMap.tabIndex :
					("_setTabIndexAttr" in this) ? this._setTabIndexAttr : "focusNode";
				array.forEach(lang.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function(attachPointName){
					var node = this[attachPointName];
					// complex code because tabIndex=-1 on a <div> doesn't work on FF
					if(has("webkit") || a11y.hasDefaultTabStop(node)){    // see #11064 about webkit bug
						node.setAttribute('tabIndex', "-1");
					}else{
						node.removeAttribute('tabIndex');
					}
				}, this);
			}else{
				if(this.tabIndex != ""){
					this.set('tabIndex', this.tabIndex);
				}
			}
		},

		_onFocus: function(/*String*/ by){
			// If user clicks on the widget, even if the mouse is released outside of it,
			// this widget's focusNode should get focus (to mimic native browser behavior).
			// Browsers often need help to make sure the focus via mouse actually gets to the focusNode.
			// TODO: consider removing all of this for 2.0 or sooner, see #16622 etc.
			if(by == "mouse" && this.isFocusable()){
				// IE exhibits strange scrolling behavior when refocusing a node so only do it when !focused.
				var focusHandle = this.own(on(this.focusNode, "focus", function(){
					mouseUpHandle.remove();
					focusHandle.remove();
				}))[0];
				// Set a global event to handle mouseup, so it fires properly
				// even if the cursor leaves this.domNode before the mouse up event.
				var event = has("pointer-events") ? "pointerup" : has("MSPointer") ? "MSPointerUp" :
					has("touch-events") ? "touchend, mouseup" :		// seems like overkill but see #16622, #16725
					"mouseup";
				var mouseUpHandle = this.own(on(this.ownerDocumentBody, event, lang.hitch(this, function(evt){
					mouseUpHandle.remove();
					focusHandle.remove();
					// if here, then the mousedown did not focus the focusNode as the default action
					if(this.focused){
						if(evt.type == "touchend"){
							this.defer("focus"); // native focus hasn't occurred yet
						}else{
							this.focus(); // native focus already occurred on mousedown
						}
					}
				})))[0];
			}
			if(this.scrollOnFocus){
				this.defer(function(){
					winUtils.scrollIntoView(this.domNode);
				}); // without defer, the input caret position can change on mouse click
			}
			this.inherited(arguments);
		},

		isFocusable: function(){
			// summary:
			//		Tells if this widget is focusable or not.  Used internally by dijit.
			// tags:
			//		protected
			return !this.disabled && this.focusNode && (domStyle.get(this.domNode, "display") != "none");
		},

		focus: function(){
			// summary:
			//		Put focus on this widget
			if(!this.disabled && this.focusNode.focus){
				try{
					this.focusNode.focus();
				}catch(e){
				}
				/*squelch errors from hidden nodes*/
			}
		},

		compare: function(/*anything*/ val1, /*anything*/ val2){
			// summary:
			//		Compare 2 values (as returned by get('value') for this widget).
			// tags:
			//		protected
			if(typeof val1 == "number" && typeof val2 == "number"){
				return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
			}else if(val1 > val2){
				return 1;
			}else if(val1 < val2){
				return -1;
			}else{
				return 0;
			}
		},

		onChange: function(/*===== newValue =====*/){
			// summary:
			//		Callback when this widget's value is changed.
			// tags:
			//		callback
		},

		// _onChangeActive: [private] Boolean
		//		Indicates that changes to the value should call onChange() callback.
		//		This is false during widget initialization, to avoid calling onChange()
		//		when the initial value is set.
		_onChangeActive: false,

		_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Called when the value of the widget is set.  Calls onChange() if appropriate
			// newValue:
			//		the new value
			// priorityChange:
			//		For a slider, for example, dragging the slider is priorityChange==false,
			//		but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
			//		onChange is only called form priorityChange=true events.
			// tags:
			//		private
			if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
				// this block executes not for a change, but during initialization,
				// and is used to store away the original value (or for ToggleButton, the original checked state)
				this._resetValue = this._lastValueReported = newValue;
			}
			this._pendingOnChange = this._pendingOnChange
				|| (typeof newValue != typeof this._lastValueReported)
				|| (this.compare(newValue, this._lastValueReported) != 0);
			if((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange){
				this._lastValueReported = newValue;
				this._pendingOnChange = false;
				if(this._onChangeActive){
					if(this._onChangeHandle){
						this._onChangeHandle.remove();
					}
					// defer allows hidden value processing to run and
					// also the onChange handler can safely adjust focus, etc
					this._onChangeHandle = this.defer(
						function(){
							this._onChangeHandle = null;
							this.onChange(newValue);
						}); // try to collapse multiple onChange's fired faster than can be processed
				}
			}
		},

		create: function(){
			// Overrides _Widget.create()
			this.inherited(arguments);
			this._onChangeActive = true;
		},

		destroy: function(){
			if(this._onChangeHandle){ // destroy called before last onChange has fired
				this._onChangeHandle.remove();
				this.onChange(this._lastValueReported);
			}
			this.inherited(arguments);
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/util/AddressCandidatesFormatter':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */


define(["dojo/_base/declare",
	"dojo/main", "dijit/main",
	"ibm/tivoli/fwm/mxmap/_Base",
	"ibm/tivoli/fwm/mxmap/panels/MobileInfoPanelLine"],
	function(declare, dojo, dijit, _Base, MobileInfoPanelLine ) {

	/**
	 * @param candidates An array with objects that has formattedAddress attribute
	 * @param mapId the of the geocoder's map.
	 * @param dialog width
	 * @param dialog height
	 * @return a DOM object with the information
	 * */
	return {
		createHTMLDOMWithList: function(candidates, mapId, width, height){
			var holder = dojo.create("div");

			// because of ie does not accept 100%, we do not use the table style
			// we use the dialog width -20 px
			var _width = width - 25;
			var table = dojo.create("table", {role: "grid", valign: "top", width:"100%", "class":"addressCandidateTable"}, holder, "last");

			// 12-10393: ie needs a tbody
			var tbody = dojo.create("tbody", {}, table, "last");	

			// creates a closure to capture the address
			var newPublishFunctionForAddress = function(selectedAddress){
				return function() { 
					dojo.publish("addressCandidateSelectedOnMapId_" + mapId, [selectedAddress]); 
				};
			};
			// as per designed, show only the first 10 candidates
			if(candidates.length > 10){
				candidates = candidates.slice(0, 10);
			}

			for(var index in candidates){
				var candidate = candidates[index];
				//var rowClass = index % 2 != 0 ? "tablerow trodd" : "tablerow  treven";  //breaks the horizontal scroll in small widths
				var rowClass = index % 2 != 0 ? "" : "addresscandidateRowStyle";
				var selectAddress = newPublishFunctionForAddress(candidate);
				var _content = candidate.formattedAddress;
				var newLine = new MobileInfoPanelLine();
				newLine.setRowClass(rowClass);
				newLine.setCallbackFunction(selectAddress);
				newLine.setContent(_content);
				newLine.placeAt(tbody, "last");
			}	
			return holder;
		}
	};
});




},
'dijit/a11yclick':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/keys", // keys.ENTER keys.SPACE
	"dojo/mouse",
	"dojo/on",
	"dojo/touch" // touch support for click is now there
], function(keys, mouse, on, touch){

	// module:
	//		dijit/a11yclick

	/*=====
	return {
		// summary:
		//		Custom press, release, and click synthetic events
		//		which trigger on a left mouse click, touch, or space/enter keyup.

		click: function(node, listener){
			// summary:
			//		Logical click operation for mouse, touch, or keyboard (space/enter key)
		},
		press: function(node, listener){
			// summary:
			//		Mousedown (left button), touchstart, or keydown (space or enter) corresponding to logical click operation.
		},
		release: function(node, listener){
			// summary:
			//		Mouseup (left button), touchend, or keyup (space or enter) corresponding to logical click operation.
		},
		move: function(node, listener){
			// summary:
			//		Mouse cursor or a finger is dragged over the given node.
		}
	};
	=====*/

	function clickKey(/*Event*/ e){
		// Test if this keyboard event should be tracked as the start (if keydown) or end (if keyup) of a click event.
		// Only track for nodes marked to be tracked, and not for buttons or inputs,
		// since buttons handle keyboard click natively, and text inputs should not
		// prevent typing spaces or newlines.
		if((e.keyCode === keys.ENTER || e.keyCode === keys.SPACE) && !/input|button|textarea/i.test(e.target.nodeName)){

			// Test if a node or its ancestor has been marked with the dojoClick property to indicate special processing
			for(var node = e.target; node; node = node.parentNode){
				if(node.dojoClick){ return true; }
			}
		}
	}

	var lastKeyDownNode;

	on(document, "keydown", function(e){
		//console.log("a11yclick: onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
		if(clickKey(e)){
			// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
			lastKeyDownNode = e.target;

			// Prevent viewport scrolling on space key in IE<9.
			// (Reproducible on test_Button.html on any of the first dijit/form/Button examples)
			e.preventDefault();
		}else{
			lastKeyDownNode = null;
		}
	});

	on(document, "keyup", function(e){
		//console.log("a11yclick: onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
		if(clickKey(e) && e.target == lastKeyDownNode){	// === breaks greasemonkey
			//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
			lastKeyDownNode = null;

			on.emit(e.target, "click", {
				cancelable: true,
				bubbles: true,
				ctrlKey: e.ctrlKey,
				shiftKey: e.shiftKey,
				metaKey: e.metaKey,
				altKey: e.altKey,
				_origType: e.type
			});
		}
	});

	// I want to return a hash of the synthetic events, but for backwards compatibility the main return value
	// needs to be the click event.   Change for 2.0.

	var click = function(node, listener){
		// Set flag on node so that keydown/keyup above emits click event.
		// Also enables fast click processing from dojo/touch.
		node.dojoClick = true;

		return on(node, "click", listener);
	};
	click.click = click;	// forward compatibility with 2.0

	click.press =  function(node, listener){
		var touchListener = on(node, touch.press, function(evt){
			if(evt.type == "mousedown" && !mouse.isLeft(evt)){
				// Ignore right click
				return;
			}
			listener(evt);
		}), keyListener = on(node, "keydown", function(evt){
			if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
				listener(evt);
			}
		});
		return {
			remove: function(){
				touchListener.remove();
				keyListener.remove();
			}
		};
	};

	click.release =  function(node, listener){
		var touchListener = on(node, touch.release, function(evt){
			if(evt.type == "mouseup" && !mouse.isLeft(evt)){
				// Ignore right click
				return;
			}
			listener(evt);
		}), keyListener = on(node, "keyup", function(evt){
			if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
				listener(evt);
			}
		});
		return {
			remove: function(){
				touchListener.remove();
				keyListener.remove();
			}
		};
	};

	click.move = touch.move;	// just for convenience

	return click;
});

},
'ibm/tivoli/fwm/mxmap/routing/Route':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Base,ibm/tivoli/fwm/mxmap/ImageLibraryManager"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.routing.Route");
dojo.require("ibm.tivoli.fwm.mxmap._Base");
dojo.require("ibm.tivoli.fwm.mxmap.ImageLibraryManager");
/**
 * This represents a route.<br>
 * 
 */
dojo.declare("ibm.tivoli.fwm.mxmap.routing.Route", ibm.tivoli.fwm.mxmap._Base, {
	totalDuration: 0,
	inputInfo: null,
	totalDistance: 0,
	stops: [],
	legsData: null,
	routeBounds: null,
	copyrights: null,
	polyline: null,
	markers: null,
	map: null,
	itinerary: null,
	initialConf: null,
	originalRouter: null,
	distanceUnit: null,
	lineVisible: true,
	setItinerary: function(data)
	{
		this.itinerary = data;
	},
	customMarkerOptions: null,
	constructor: function(params)
	{
		dojo.mixin(this, params);
		console.log("route created", params);
	},
	zoomToRoute: function()
	{
		try
		{
			this.map.setBounds(this.getBounds());
		}
		catch (e)
		{
			console.error("zoom to route", e);
		}
	},
	getBounds: function()
	{
		if (this.routeBounds == null)
		{
			this.routeBounds = this.map.getBoundingBoxFromPoints(this.polyline.points);
			if(this.routeBounds)
			{
				this.routeBounds.merge(this.map.getBoundingBoxFromPoints(this.stops));
			}
			else
			{
				this.routeBounds = this.map.getBoundingBoxFromPoints(this.stops);
			}
		}
		return this.routeBounds;
	},
	clear: function()
	{
		// Removes all mbo markers (markers that do not belong to mbos will not
		// be removed at this point)
		for ( var i = 0; i < this.inputInfo.stops.length; i++)
		{
			try
			{
				if (this.inputInfo.stops[i].calculatedStop != true)
				{
					this.map.removeMboFromLayerManager(this.inputInfo.stops[i]);
				}
			}
			catch (e)
			{
				console.log("Removing non existing mbo marker");
			}
		}

		this.hideCalculatedMarkers();
		this.markers = null;
		if (this.polyline)
		{
			try
			{
				this.map.removePolyline(this.polyline);
			}
			catch (e)
			{
				console.error("cannot remove polyline");
			}
		}

	},
	showLines: function()
	{
		if (this.lineVisible)
		{
			this.map.addPolyline(this.polyline);
		}
	},
	showMarkers: function()
	{
		if (this.markers == null)
		{
			this._createMarkers();
		}
	},
	show: function()
	{
		this.showLines();
		this.showMarkers();
	},
	redraw: function()
	{
		this.clear();
		this.show();
	},
	_addMarker: function(/* LatLngPoint */p, stopNum)
	{
		console.log("[mxmap.routing.Route._addMarker] Adding Marker: ", stopNum);

		// Get either the start position or the end position marker depending on
		// the stopNum
		var markerInfo = (stopNum > 0) ? ibm.tivoli.fwm.mxmap.ImageLibraryManager.getImageLibraryManager().getEndPositionMarkerImageInfo() : ibm.tivoli.fwm.mxmap.ImageLibraryManager
				.getImageLibraryManager().getStartPositionMarkerImageInfo();

		var aa = {
			label: "",
			tooltip: "",
			draggable: false,
			icon: markerInfo.getImageURL(),
			iconSize: markerInfo.getImageSize(),
			iconAnchor: markerInfo.getImageAnchor(),
			hover: true,
			// Defect 67228 - See explanation in GmapsMarker (toProprietary method)
			dontDrawAsOverlay: true
		};
		var m = this.map.addMarker(p, aa);
		m.label = String(stopNum);
		return m;
	},
	_woStopNumber: 1,
	_addNewMarker: function(index)
	{
		if (this.inputInfo.stops[index].calculatedStop != true)
		{
			// this is a stop based on a mbo

			console.log(index, "mbo stop", this.stops[index], this.inputInfo.stops[index]);

			var mboStop = this.inputInfo.stops[index];

			mboStop.routeInfo = {
				stopNumber: index
			};
			var usedIndex = index;
			var fct = function(marker)
			{
				if(this.markers == null)
				{
					this.markers = [];
				}
				this.markers[usedIndex] = marker;
			};
			var label = "";
			var tooltip = "";

			if (mboStop && mboStop.mxdata && (mboStop.mxdata.mboName == "WORKORDER" || mboStop.mxdata.extendsMboName == "WORKORDER"))
			{
				label = String(this._woStopNumber++);
			}

			// Now the mouseover (tooltip) is part of the mboInfo received from the server
			if (this.map.isMobile != true)
			{
				tooltip = ((mboStop.mouseover != null) && (mboStop.mouseover != undefined)) ? mboStop.mouseover : "";
			}

			// The route cannot retrieve information from the router (originalRouter)
			// because other routes can be executed in parallel
			// Every route data must be passed in as argument
			var markerOptions = {
				"draggable": false,
				"enableMapTips": true,
				"label": label,
				"tooltip": tooltip,
				"color": this.polyline.color,
				"markerReferenceCallback": dojo.hitch(this, fct)
			};
			this.map.addMboToLayerManager(mboStop, markerOptions);

		}
		else
		{
			// this is a configured stop or user location

			console.log(index, "calculated stop", this.stops[index], this.inputInfo.stops[index]);

			var m = this._addMarker(this.stops[index], index);

			this.markers[index] = m;
			this.markers[index].calculated = true;
		}
	},
	getMarkerForStop: function(index)
	{
		if (this.markers != null && this.markers.length > index)
		{
			return this.markers[index];
		}
		else
		{
			console.log("no marker for index ", index);
			return null;
		}
	},
	_createMarkers: function()
	{
		this.markers = [];
		var initialLocation = null;
		if(this.itinerary)
		{
			initialLocation = this.itinerary.getInitialLocation();
		}
		var stopNum = 1;

		console.log("debug", this.stops, this.itinerary);

		if (initialLocation)
		{
			var p = initialLocation.location;
			this._addNewMarker(0);
			// initialLocation.marker = m;
			// this.markers.push(m);
		}
		for ( var i = 1; i < this.stops.length; i++)
		{
			var p = this.stops[i];

			this._addNewMarker(i);

		}
	},
	avoidTollsSupported: true,
	setSupportAvoidToll: function(supported)
	{
		this.avoidTollsSupported = supported;
	},
	avoidHighwaysSupported: true,
	setSupportAvoidHighway: function(supported)
	{
		this.avoidHighwaysSupported = supported;
	},
	hideCalculatedMarkers: function()
	{
		// Removes all remaining markers
		if (this.markers != null)
		{
			for ( var i = 0; i < this.markers.length; i++)
			{
				try
				{
					if (this.markers[i].calculated == true)
					{
						this.map.removeMarker(this.markers[i]);
					}
				}
				catch (e)
				{
					console.log("Removing non existing marker");
				}
			}

		}

	},
	showCalculatedMarkers: function()
	{
		// Removes all remaining markers
		if (this.markers != null)
		{
			for ( var i = 0; i < this.markers.length; i++)
			{
				try
				{
					if (this.markers[i].calculated == true)
					{
						var m = this._addMarker(this.stops[i], i);
						this.markers[i] = m;
						this.markers[i].calculated = true;
					}
				}
				catch (e)
				{
					console.log("error readding marker", e);
				}
			}

		}
	},
	setLineVisible: function(visible)
	{
		if (visible == this.lineVisible)
		{
			return;
		}
		this.lineVisible = visible;
		if (this.lineVisible == true)
		{
			this.map.addPolyline(this.polyline);
		}
		else
		{
			this.map.removePolyline(this.polyline);
		}
		// this.redraw();
	},
	getRouteWarningCodes: function()
	{
		var warnings = [];
		for ( var i = 0; i < this.inputInfo.stops.length; i++)
		{
			if(this.inputInfo.stops[i].warning != undefined)
			{
				warnings.push(this.inputInfo.stops[i].warning);
			}
		}
		return warnings;
	}
});

});

},
'ibm/tivoli/fwm/mxmap/routing/impl/spatial':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
define([
	"dojo/_base/declare", "ibm/tivoli/fwm/mxmap/_Base", "ibm/tivoli/fwm/mxmap/routing/Router", "ibm/tivoli/fwm/mxmap/routing/Route",
	"ibm/tivoli/fwm/mxmap/LoadEsriPlugin!esri/tasks/RouteTask", "ibm/tivoli/fwm/mxmap/LoadEsriPlugin!esri/symbols/SimpleMarkerSymbol",
	"ibm/tivoli/fwm/mxmap/LoadEsriPlugin!esri/symbols/SimpleLineSymbol", "ibm/tivoli/fwm/mxmap/LoadEsriPlugin!esri/tasks/FeatureSet",
	"ibm/tivoli/fwm/mxmap/LoadEsriPlugin!esri/tasks/RouteParameters", "ibm/tivoli/fwm/mxmap/LoadEsriPlugin!esri/geometry/Point", 
	"ibm/tivoli/fwm/mxmap/LoadEsriPlugin!esri/symbols/TextSymbol", "ibm/tivoli/fwm/mxmap/LoadEsriPlugin!esri/symbols/Font",
	"ibm/tivoli/fwm/mxmap/LoadEsriPlugin!esri/graphic", "ibm/tivoli/fwm/mxmap/LoadEsriPlugin!esri/SpatialReference",
	"ibm/tivoli/fwm/mxmap/LoadEsriPlugin!esri/IdentityManager", "ibm/tivoli/fwm/mxmap/LoadEsriPlugin!esri/urlUtils"
	], function(declare, _Base, Router, Route, RouteTask, SimpleMarkerSymbol, 
			SimpleLineSymbol, FeatureSet, RouteParameters, Point, TextSymbol, Font, Graphic, SpatialReference, esriId, urlUtils){

	return declare("ibm.tivoli.fwm.mxmap.routing.impl.spatial", [ibm.tivoli.fwm.mxmap.routing.Router, ibm.tivoli.fwm.mxmap._Base], {


		directionsService: null,
		map: null,
		_stopSymbol: null,
		_routeSymbol: null,
		_spatialReference: null,
		_esriMap: null,
		_spatialReference: null,
		conf: null,
		_lastStop: null,
		_successCallback: null,
		_failureCallback: null,
		_routeLimits: 10,
		_oldWGS84Point: null,
		_token: null,
		// Token expiration period: 12h
		_tokenExpirationPeriod: 720,
		_isRequestingToken: false,
		_routeQueue: null,
		constructor: function(params)
		{
			console.log("Router esri", params);
			dojo.mixin(this, params);// will set conf and map
			this._routeQueue = [];

			// setting stop symbols
			this._stopSymbol = new SimpleMarkerSymbol().setStyle(SimpleMarkerSymbol.STYLE_CROSS).setSize(15);
			this._stopSymbol.outline.setWidth(4);
			// setting route line symbols

			this._routeSymbol = new SimpleLineSymbol().setColor(new dojo.Color()).setWidth(this.routeLineWidth);
			this._esriMap = this.map.getProviderMap();
			this._spatialReference = this._esriMap.spatialReference;
		},
		_init: function()
		{
			// When the router is instantiated, request a token to be added to all future route requests
			// using the user/password passed by the server.
			if((this.getRoutingServiceUserName() != "") && (this.getRoutingServicePassword() != ""))
			{
				this.requestToken();
			} else {
				this.directionsService = new RouteTask(this.routeUrl);			
			}
		},
		/*
		 * Final route step, calls callback function with routeSummary params
		 */
		_onSolveRoute: function(routeSummary, callback)
		{
			if (callback)
			{
				callback(routeSummary);
			}
		},
		_routeFailed: function(error, errCb, errorCode)
		{
			console.log("route failed", error);
			if (errCb)
			{
				if (!errorCode)
				{
					errorCode = ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.UNKNOWN;
				}
				errCb(errorCode, error);
			}
		},
		/**
		 * Based on a lat/lng it creates an esri geometry point.
		 * 
		 * @param lat
		 * @param lng
		 * @returns
		 */
		_createStop: function(lat, lng, text, pointSR)
		{
			var spatialReference = pointSR ? new SpatialReference(pointSR) : this._spatialReference;
			var mappoint = new Point(lng, lat, spatialReference);

			var ss = new TextSymbol(text).setColor(new dojo.Color([ 256, 0, 0 ])).setAlign(Font.ALIGN_START).setFont(
					new Font("12pt").setWeight(Font.WEIGHT_BOLD));
			var stop = new Graphic(mappoint, ss);
			if (window.DEBUGLEVEL && window.DEBUGLEVEL > 1)
			{
				this.map.getProviderMap().graphics.add(stop);
			}

			return stop;

		},

		_getLatLngFromStop: function(stop)
		{
			var point = null;

			// Using the MXRecord wrapper to handle mboInfo's properties
			var mxRec = new ibm.tivoli.fwm.mxmap.MXRecord({
				mboInfo: stop,
				map: this.map
			});
			if (mxRec.hasGISData())
			{
				console.log("mbo SPATIAL? AUTOSPATIAL? stop", mxRec.hasSPATIALCoordinates(), mxRec.hasAutolocateSpatialData(), stop);
				// The first thing is to check if LBS data needs to be used
				// otherwise, go with the existing autolocate fall through logic
				if (mxRec.useLBSData() && mxRec.hasPointInCurrentSR())
				{
					point = mxRec.getPointInCurrentSR();
				}
				else if (mxRec.hasSPATIALCoordinates())
				{
					point = this.map.getPointFromMboInfo(mxRec.getMboInfo());
				}
				else if (mxRec.hasGISCoordinates())
				{
					point = mxRec.getGISPoint();
				}
				else if (mxRec.hasAutolocateSpatialData())
				{

					point = this.map.getPointFromMboInfo(mxRec.getAutolocateMboInfo());
				}
				else if (mxRec.hasAutolocateGISCoordinates())
				{
					point = mxRec.getAutolocateGISPoint();
				}
				else
				{
					console.warn("Stop doesn't have gis coords", stop);
				}
			}

			else
			{
				console.log("stop is calculated", stop);
				if (stop.lat == null)
				{
					console.error("stop does not have lat/lng", stop);
				}
				else
				{
					point = this.map.latLng(stop.lat, stop.lng);
				}
			}
			return point;
		},

		/*
		 * prepare params in order to avoid any esri route limit.
		 */
		_prepareParams: function(start, offset, stops)
		{
			var stopData = new FeatureSet();
			console.info("offset", start, offset, "/", stops.length);
			for ( var i = start; i < offset; i++)
			{
				var stop = stops[i];
				var stopEsri = null;

				var point = this._getLatLngFromStop(stop);
				if(point)
				{
					stopEsri = this._createStop(point.lat, point.lng, i, point.sr);
					if(stopEsri)
					{
						stopData.features.push(stopEsri);
					}
				}
			}
			return stopData;
		},
		/**
		 * converst a si
		 */
		_getLatLngArrayFromStops: function(stops)
		{
			var lls = [];
			for ( var index = 0; index < stops.length; index++)
			{
				lls.push(this._getLatLngFromStop(stops[index]));
			}
			return lls;
		},
		/**
		 * Executes the routing on esri maps provider.
		 * 
		 * @see Router.js#showRoute
		 */
		showRoute: function(stops, successCb, failCb, a, instanceConf)
		{
			if (this._isRequestingToken == true)
			{
				console.warn("Token validation going on, queue the route request.");
				this._routeQueue.push({
					stops: stops,
					callback: successCb,
					errCb: failCb,
					instanceConf: instanceConf
				});
				return;
			}

			// first step, check if any stop is a FEATURE CLASS if so need to get
			// it's X/Y from server
			if (this._checkIfAnyFeaturedClass(stops) == true)
			{
				var fct = function()
				{
					this._showRouteAllPointsWithXY(stops, successCb, failCb, instanceConf);
				};
				this._convertAnyFeatureStop(stops, dojo.hitch(this, fct), failCb);
			}
			else
			{
				console.log("ALL Features have XY");
				this._showRouteAllPointsWithXY(stops, successCb, failCb, instanceConf);
			}

		},
		_convertAnyFeatureStop: function(stops, callback, errCallback)
		{


			var stopsToConvert = [];
			for ( var j = 0; j < stops.length; j++)
			{
				var stop = stops[j];
				// Using the MXRecord wrapper to handle mboInfo's properties
				var mxRec = new ibm.tivoli.fwm.mxmap.MXRecord({
					mboInfo: stop,
					map: this.map
				});
				if ((stop.calculatedStop == null) && !mxRec.useLBSData())
				{
					if (mxRec.hasSPATIALCoordinates() == true)
					{
						stopsToConvert.push(mxRec.getMboInfo());
					}
					else if (mxRec.hasAutolocateSpatialData())
					{
						stopsToConvert.push(mxRec.getAutolocateMboInfo());
					}
					else
					{
						console.warn("no SPATIAL GIS info for stop ", stop);
					}

				}
			}
			var test = function(args)
			{
				callback();
			};
			this.map.queryMultipleRecordsAtOnce(stopsToConvert, test, errCallback);
		},// maybe merge it in maximospatial.js
		_checkIfAnyFeaturedClass: function(stops)
		{
			for ( var i in stops)
			{
				var stop = stops[i];
				var mxrec = new ibm.tivoli.fwm.mxmap.MXRecord({
					mboInfo: stop,
					map: this.map
				});

				if (!mxrec.useLBSData() && mxrec.hasSPATIALCoordinates() || (mxrec.hasGISCoordinates() == false && mxrec.hasAutolocateSpatialData() == true))
				{
					return true;
				}
			}
		},
		_retrieveStopInfo: function(pt, mboInfo, legIndex, itinerary, geocodeCache)
		{
			var txt = "";
			if (mboInfo.mxdata != null && mboInfo.mxdata.attributes != null && mboInfo.mxdata.attributes.formattedaddress != null && mboInfo.mxdata.attributes.formattedaddress.length > 0)
			{
				geocodeCache[pt] = mboInfo.mxdata.attributes.formattedaddress;
				txt = geocodeCache[pt];
			}
			else
			{
				// geocode it
				var legIndex = itinerary.legs.length;
				var fctSuccess = function(location)
				{
					var address = location[0].formattedAddress;
					if (legIndex >= 0)
					{
						itinerary.legs[legIndex].info = address;
					}
					else
					{
						itinerary.initialLocation.info = address;
					}
					geocodeCache[pt] = address;
				};
				var fctError = function(error)
				{
					console.error("could not find leg ", legIndex, "info");
				};
				this.map.geocoder.reverseGeocode(pt.lat, pt.lng, dojo.hitch(this, fctSuccess), dojo.hitch(this, fctError));

			}
			return txt;

		},
		_showRouteAllPointsWithXY: function(stops, successCb, failCb, instanceConf)
		{
			var routeColor = instanceConf.routecolor;
			if (routeColor.indexOf("#") != 0)
			{
				routeColor = "#" + routeColor;
			}

			var routeParams = new RouteParameters();
			if (dojo.config.fwm.debug == true)
			{
				console.info("stops", stops.length, {
					stops: stops
				});
			}

			routeParams.outSpatialReference = new SpatialReference({
				wkid: this._spatialReference
			});

			routeParams.returnDirections = true;
			if (this.isOptimizeRoute())
			{
				// makes optimization but does not change 1st and last stops
				routeParams.findBestSequence = true;
				routeParams.preserveFirstStop = true;
				routeParams.preserveLastStop = true;

			}
			routeParams.directionsLengthUnits = "esriKilometers";// Always in km

			routeParams.travelMode = this.getTravelMode();
			routeParams.returnRoutes = true;
			routeParams.returnStops = true;
			var offset = 0;
			var routeSummary = {
					totalDuration: 0,
					totalDistance: 0,
					stops: [],
					legsData: null,
					polyline: null,
					copyrights: "",
					map: this.map
			};
			var polylinePoints = [];
			var th = this._startTimer();
			var ItineraryClass = dojo.require("ibm.tivoli.fwm.mxmap.routing.itinerary.Itinerary");
			var itinerary = new ItineraryClass();
			var start = 0;
			var successFct = function(solveResult)
			{
				console.log("solveResult", solveResult);
				this._stopTimer(th, stops.length);
				var stopsFromResponse = solveResult.routeResults[0].stops;
				if (solveResult.messages && solveResult.messages.length > 0)
				{
					// not sure what to do.. the routing task never fails, just add
					// messages to the solve result AND documentation is still TBA
					// :(
					// http://help.arcgis.com/en/webapi/javascript/arcgis/help/jsapi/routetask.htm#onSolveComplete
					console.warn("Route service returend the following messages :");
					for ( var i = 0; i < solveResult.messages.length; i++)
					{
						var msg = solveResult.messages[i];
						console.warn(msg.description, msg);
					}
					//TODO check if msf type 50 (warning) should be considered an error
					if (msg.type == 50)
					{
						// Check whether the markers should be drawn even when the provider fails to generate a route
						if(this.map.getShowMarkersOnRouteError() == true)
						{
							this.renderRoute([], routeSummary, itinerary, stops, successCb, failCb, instanceConf, routeColor, stopsFromResponse);
						}
						else
						{
							this._routeFailed(msg, failCb, ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.ZERO_RESULTS);
						}

						if (!solveResult.routeResults || solveResult.routeResults.length == 0 || !solveResult.routeResults[0].directions || !solveResult.routeResults[0].directions.features || solveResult.routeResults[0].directions.features.length == 0)
						{
							return;
						}
					}
				}
				var directions = solveResult.routeResults[0].directions;

				var steps = [];
				var c = 1;
				var legDistance = 0.0;
				var legDuration = 0.0;
				var flagEndStart = false;

				console.log("total route stops", solveResult.routeResults[0].directions.features.length);
				var featuresArray = solveResult.routeResults[0].directions.features;
				for ( var i = 0; i < featuresArray.length; i++)
				{
					var feature = solveResult.routeResults[0].directions.features[i];

					var step = {
							distance: feature.attributes.length,
							duration: feature.attributes.time,
							info: feature.attributes.text,
							location: this.map._getLatLngFromFeature(feature)
					};
					steps.push(step);
					legDistance += feature.attributes.length;
					legDuration += feature.attributes.time;
					// check if this i the last step of a leg
					if (flagEndStart == true && feature.attributes.length == 0)
					{
						console.log("Ok leg completed ", legDuration);
						var pt = this.map._getLatLngFromFeature(feature);

						var txt = feature.attributes.text;
						console.log("legs ", itinerary.legs.length, stops[itinerary.legs.length + 1]);

						var lpos = itinerary.addLeg(pt, txt, legDistance, legDuration, null, steps, null);
						var sInfo = stops[lpos + 1];
						var needsToGeocode = true;
						if (sInfo.mxdata)
						{
							var mxrec = new ibm.tivoli.fwm.mxmap.MXRecord({
								mboInfo: sInfo,
								map: this.map
							});
							if (mxrec.hasGISCoordinates() == true || mxrec.hasSPATIALCoordinates() == true)
							{
								if (mxrec.hasAddress() == true)
								{
									needsToGeocode = false;
									itinerary.legs[lpos].info = mxrec.getAddress();
								}
							}
							else if (mxrec.hasAutolocateGISOnlyCoordinates() == true || mxrec.hasAutolocateSpatialData() == true)
							{
								var autolocateMboInfoAddress = mxrec.getAutolocateAddress();
								if (autolocateMboInfoAddress != null && autolocateMboInfoAddress.length > 0)
								{
									needsToGeocode = false;
									itinerary.legs[lpos].info = autolocateMboInfoAddress;
								}
							}
						}
						itinerary.legs[lpos].needsToGeocode = needsToGeocode;

						steps = [];
						legDistance = 0;
						legDuration = 0;
						c++;
						flagEndStart = false;

					}
					else if (flagEndStart == false && feature.attributes.length == 0)
					{
						flagEndStart = true;
					}
				}

				if (start == 0)
				{
					var geom = solveResult.routeResults[0].directions.features[0].geometry;
					var pt = this.map._getLatLngFromFeature(solveResult.routeResults[0].directions.features[0]);
					var txt = solveResult.routeResults[0].directions.features[0].attributes.text;
					itinerary.setInitialLocation(txt, pt, null, null, true);

				}
				// add this esriroute polyline to the main route polyline points
				// array;
				var PolylineClass = dojo.require("ibm.tivoli.fwm.mxmap.impl.polyline.MaximoSpatialPolyline");
				var pol = new PolylineClass({map: this.map});
				pol.fromProprietary(directions.mergedGeometry);
				polylinePoints = polylinePoints.concat(pol.points);

				// sum total distance and time
				routeSummary.totalDistance += directions.totalLength;
				routeSummary.totalDuration += directions.totalTime;

				// if we still have stops to be added
				if (offset < stops.length)
				{
					start = offset - 1;
					offset = offset + this._routeLimits;
					if (offset > stops.length)
					{
						offset = stops.length;
					}
					if ((offset - start) >= this._routeLimits)
					{
						offset--;
					}
					routeParams.stops = this._prepareParams(start, offset, stops);
					th = this._startTimer(th, stops.length);
					var errorFctAux = function(error)
					{
						this._routeFailed(error, failCb);
					};

					this.directionsService.solve(routeParams, dojo.hitch(this, successFct), dojo.hitch(this, errorFctAux));
				}
				else
				{
					this.renderRoute(polylinePoints, routeSummary, itinerary, stops, successCb, failCb, instanceConf, routeColor, stopsFromResponse);
				}

			};

			if (stops.length > this._routeLimits)
			{

				offset = offset + this._routeLimits;
			}
			else
			{
				offset = stops.length;
			}

			routeParams.stops = this._prepareParams(start, offset, stops);

			if (routeParams.stops.features.length >= 2)
			{
				var errorFctAux = function(error)
				{
					// Check whether the markers should be drawn even when the provider fails to generate a route
					if(this.map.getShowMarkersOnRouteError() == true)
					{
						this.renderRoute([], routeSummary, itinerary, stops, successCb, failCb, instanceConf, routeColor, stopsFromResponse);
					}
					else
					{
						this._routeFailed(error, failCb);
					}
				};

				this.directionsService.solve(routeParams, dojo.hitch(this, successFct), dojo.hitch(this, errorFctAux));
				// this._lastStop = routeParams.stops.features.splice(0,1)[0];
			}
			else
			{
				// We need to consider the possibility of one or more stops
				// failing to comply with Esri's requirements to create the route. 
				// In this case, the number of stops may be lower than 2 and a route cannot be created.
				this._routeFailed("at least 2 stops are needed", failCb, ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.MIN_STOPS_REQ);

			}

		},

		// Steps to create the route data and run the callback.
		// They have been added to this function to avoid code repetition.
		renderRoute: function(polylinePoints, routeSummary, itineraryInfo, stops, callback, errCb, instanceConf, routeColor, stopsFromResponse)
		{
			//get the stops from the route service response
			routeSummary.stops = stopsFromResponse.map(dojo.hitch(this, function(stop) {
				return this.map.latLng(stop.geometry.y, stop.geometry.x, JSON.stringify(stop.geometry.spatialReference));
			}));
			routeSummary.itinerary = itineraryInfo;
			routeSummary.inputInfo = {
					stops: stops,
					successCb: callback,
					errorCb: errCb
			};
			routeSummary.originalRouter = this;
			routeSummary.instanceConf = instanceConf;
			routeSummary.distanceUnit = this.getCurrentDistanceUnit();
			// all route stops were calculated
			var PolylineClass = dojo.require("ibm.tivoli.fwm.mxmap.impl.polyline.MaximoSpatialPolyline");
			var poly = new PolylineClass({points: polylinePoints, map: this.map});
			poly.addData({
				color: routeColor,
				opacity: this.routeOpacity,
				width: this.routeLineWidth
			});
			routeSummary.polyline = poly;

			var routeInfo = new ibm.tivoli.fwm.mxmap.routing.Route(routeSummary);
			routeInfo.setSupportAvoidToll(false);
			routeInfo.setSupportAvoidHighway(false);

			this._onSolveRoute(routeInfo, callback);
			if (dojo.config.fwm.debug == true)
			{
				console.info("stopsEnd", {
					stops: stops
				});
			}
			this._stopTimer(null, stops.length);
		},
		/**
		 * This intercepts the user location call and converts it to spatial
		 * coordinate system.
		 */
		getUserLocation: function(callback, errorCb)
		{
			if (this.myCurrentLocationInstance)
			{
				var errorCallback = function()
				{
					if (this.map)
					{
						this.map.failedToGetLocation();
					}
					errorCb();
				};
				var success = function()
				{
					this._convertToSpatialCoordSystem(callback);
				};

				this.myCurrentLocationInstance.getUserLocation(dojo.hitch(this, success), dojo.hitch(this, errorCallback));
			}
		},
		_convertToSpatialCoordSystem: function(callback)
		{
			var storeConvertedPoint = function(point)
			{
				this.myCurrentLocationInstance._esriSRLatLng = point;
				this.myCurrentLocationInstance._oldWGS84Point = this.myCurrentLocationInstance.getPosition();
				if (callback)
				{
					callback();
				}
			};
			this.myCurrentLocationInstance.convertPositionToMapPoint(this.map, dojo.hitch(this, storeConvertedPoint));
		},
		_isESRIUpToDate: function()
		{
			var currPosition = this.myCurrentLocationInstance.getPosition();
			var esriRefPoint = this.myCurrentLocationInstance._oldWGS84Point;
			if (esriRefPoint == null)
			{
				this._convertToSpatialCoordSystem();
				return false;
			}
			if (currPosition.coords != esriRefPoint.coords)
			{
				this._convertToSpatialCoordSystem();
				return false;
			}
			return true;
		},
		/**
		 * we must convert the w3c position into the same map spatial reference.
		 */
		_getUserLocationStop: function()
		{
			return this.myCurrentLocationInstance._esriSRLatLng;
		},
		isLocationStatusUnassigned: function()
		{
			if (this.myCurrentLocationInstance.isStatusHasLocation())
			{
				return !this.isLocationStatusHasLocation();
			}
			return this.inherited(arguments);
		},
		isLocationStatusHasLocation: function()
		{
			if (this.myCurrentLocationInstance.isStatusHasLocation())
			{
				return this._isESRIUpToDate();
			}
			return this.inherited(arguments);

		},
		/**
		 * Makes a request to ESRI's generateToken service using the credentials
		 * from the map configuration data
		 */
		requestToken: function()
		{
			this._isRequestingToken = true;
			var me = this;
			var _spatialTokenRequestCallback = function(data)
			{
				if(data && data.token)
				{
					// Token obtained successfully
					// Recreate the RouteTask API appending the token to the service URL
					me._token = data.token;

					urlUtils.addProxyRule({
						urlPrefix: "route.arcgis.com",  
						proxyUrl: "/maximo/webclient/pluss/plusstokenproxy.jsp?token=" + me._token + "&"
					});
					me.directionsService = new RouteTask(me.routeUrl + "/plusstokenstart/" + me._token + "/plusstokenend/");
				}
				else if (data && data.error)
				{
					// An error has occurred when trying to obtain the token
					// Show the error message
					var errorData = data.error;
					errorMsg = errorData.message
					if(errorData.details && (errorData.details.length > 0))
					{
						for(var i=0; i < errorData.details.length; i++)
						{
							errorMsg += " " + errorData.details[i];
						}
					}
					console.error("Error validating token: " + errorData.code + ": " + errorMsg);
					var maximo = me.map.getMaximo();
					maximo.showMessage("mapserver", "route_unknown_failure", [ errorMsg ]);
				}
				// Execute all queued route requests
				me._isRequestingToken = false;
				me.executeQueuedRouteRequests();
			};

			var username = this.getRoutingServiceUserName();
			var password = this.getRoutingServicePassword();
			var routeServiceUrl = this.getRoutingServiceUrl();
			var referer = window.location.href.substring(0, window.location.href.indexOf('?'));
			var tokenRequest = "https://www.arcgis.com/sharing/generateToken";
			//var tokenRequest =  routeServiceUrl + "generateToken?username=" + username + "&password=" + password + "&referer=" + referer + "&f=pjson&callback=_spatialTokenRequestCallback";
			//dojo.io.script.get({
			//	url : tokenRequest,
			//	timeout : 10000,
			//	error : function(error) {
			//		var maximo = me.map.getMaximo();
			//		maximo.showMessage("mapserver", "route_unknown_failure", [ error.message ]);
			//		me._isRequestingToken = false;
			//		me.executeQueuedRouteRequests();
			//	}
			//});

			var xhr = this.createCORSRequest('POST', tokenRequest);
			if (!xhr) {
				console.log('CORS not supported');
				return;
			}

			// Response handlers.
			xhr.onreadystatechange = function() {
				if(this.readyState == XMLHttpRequest.DONE && this.status == 200) {
					var data = xhr.responseText;
					console.log('Response from CORS request: ' + data);
					if (typeof data == "string") {
						data = JSON.parse(data);
					}
					_spatialTokenRequestCallback(data);
				}
			};

			xhr.onerror = function() {
				var data = xhr.responseText;
				if (typeof error == "string") {
					data = JSON.parse(data);
				}
				var maximo = me.map.getMaximo();
				maximo.showMessage("mapserver", "route_unknown_failure", [ data.error.message ]);
				me._isRequestingToken = false;
				me.executeQueuedRouteRequests();
			};
			xhr.send("username=" + username + "&password=" + password + "&referer=" + referer + "&f=pjson");
		},

		createCORSRequest: function(method, url)
		{
			var xhr = new XMLHttpRequest();
			if ("withCredentials" in xhr) {
				// XHR for Chrome/Firefox/Opera/Safari.
				xhr.open(method, url, true);
			} else if (typeof XDomainRequest != "undefined") {
				// XDomainRequest for IE.
				xhr = new XDomainRequest();
				xhr.open(method, url);
			} else {
				// CORS not supported.
				xhr = null;
			}
			xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
			return xhr;
		},

		// Since direct REST requests seems to work in all browserss,
		// this solution below (using javascript API) has been commented out
		// because it only works in FF and Chrome
//		requestTokenNonIEBrowsers: function()
//		{
//		this._isRequestingToken = true;
//		var tokenReceived = function(tokenData)
//		{
//		// Token obtained successfully
//		// Recreate the RouteTask API appending the token to the service URL
//		this._token = tokenData.token;
//		this.directionsService = new esri.tasks.RouteTask(this.routeUrl + "?token=" + this._token);
//		// Execute all queued route requests
//		this._isRequestingToken = false;
//		this.executeQueuedRouteRequests();
//		}
//		var tokenRequestError = function(errorData)
//		{
//		// An error has occurred when trying to obtain the token
//		// Show the error message
//		var errorMsg = null;
//		if(errorData && errorData.message)
//		{
//		errorMsg = errorData.message;
//		if(errorData.details && (errorData.details.length > 0))
//		{
//		for(var i=0; i < errorData.details.length; i++)
//		{
//		errorMsg += " " + errorData.details[i];
//		}
//		}
//		}
//		console.error("Error validating token: " + errorData.code + ": " + errorMsg);
//		var maximo = this.map.getMaximo();
//		maximo.showMessage("mapserver", "route_unknown_failure", [ errorMsg ]);
//		// Execute all queued route requests (if the routing service requires a valid token,
//		// then an error is expected when requesting a route).
//		this._isRequestingToken = false;
//		this.executeQueuedRouteRequests();
//		}
//		// Request the token
//		// TODO: This way of requesting a token currently doesn't work in IE
//		esri.request({
//		url: "https://www.arcgis.com/sharing/generateToken",
//		content: {
//		referer: window.location.href.substring(0, window.location.href.indexOf('?')),
//		username: this.getRoutingServiceUserName(),
//		password: this.getRoutingServicePassword(),
//		expiration: this._tokenExpirationPeriod,
//		f: "pjson"
//		},
//		handleAs: "json",
//		load: dojo.hitch(this,tokenReceived),
//		error: dojo.hitch(this,tokenRequestError)
//		},{
//		usePost: true
//		});
//		},
		/**
		 * Returns the username to access ESRI's paid services
		 */
		getRoutingServiceUserName: function()
		{
			var mapConf = this.map.mapConf;
			if((mapConf != null) && (mapConf!= undefined) && (mapConf.username != null) && (mapConf.username != undefined))
			{
				return mapConf.username;
			}
			else
			{
				return "";
			}
		},
		/**
		 * Returns the password to access ESRI's paid services
		 */
		getRoutingServicePassword: function()
		{
			var mapConf = this.map.mapConf;
			if((mapConf != null) && (mapConf!= undefined) && (mapConf.password != null) && (mapConf.password != undefined))
			{
				return mapConf.password;
			}
			else
			{
				return "";
			}
		},
		/**
		 * Returns the Route Service URL to access ESRI's paid services
		 */
		getRoutingServiceUrl: function()
		{
			var mapConf = this.map.mapConf;
			if((mapConf != null) && (mapConf!= undefined) && (mapConf.routeServiceUrl != null) && (mapConf.routeServiceUrl != undefined))
			{
				return mapConf.routeServiceUrl;
			}
			else
			{
				return "";
			}
		},
		/**
		 * Returns the Route Service URL to access ESRI's paid services
		 */
		getTravelMode: function()
		{
			var mapConf = this.map.mapConf;
			if((mapConf != null) && (mapConf!= undefined) && (mapConf.travelMode != null) && (mapConf.travelMode != undefined))
			{
				return mapConf.travelMode;
			}
			else
			{
				return 1; // Driving Time
			}
		},
		/**
		 * Executes all route requests from the queue
		 */
		executeQueuedRouteRequests: function()
		{
			console.log("Executing queued route requests ", this._routeQueue.length);
			while (this._routeQueue.length > 0)
			{
				var obj = this._routeQueue.pop();
				this.showRoute(obj.stops, obj.callback, obj.errCb, null, obj.instanceConf);
			}
		}
	});
});

},
'dijit/Destroyable':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/aspect",
	"dojo/_base/declare"
], function(array, aspect, declare){

	// module:
	//		dijit/Destroyable

	return declare("dijit.Destroyable", null, {
		// summary:
		//		Mixin to track handles and release them when instance is destroyed.
		// description:
		//		Call this.own(...) on list of handles (returned from dojo/aspect, dojo/on,
		//		dojo/Stateful::watch, or any class (including widgets) with a destroyRecursive() or destroy() method.
		//		Then call destroy() later to destroy this instance and release the resources.

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this class, releasing any resources registered via own().
			this._destroyed = true;
		},

		own: function(){
			// summary:
			//		Track specified handles and remove/destroy them when this instance is destroyed, unless they were
			//		already removed/destroyed manually.
			// tags:
			//		protected
			// returns:
			//		The array of specified handles, so you can do for example:
			//	|		var handle = this.own(on(...))[0];

			var cleanupMethods = [
				"destroyRecursive",
				"destroy",
				"remove"
			];

			array.forEach(arguments, function(handle){
				// When this.destroy() is called, destroy handle.  Since I'm using aspect.before(),
				// the handle will be destroyed before a subclass's destroy() method starts running, before it calls
				// this.inherited() or even if it doesn't call this.inherited() at all.  If that's an issue, make an
				// onDestroy() method and connect to that instead.
				var destroyMethodName;
				var odh = aspect.before(this, "destroy", function (preserveDom){
					handle[destroyMethodName](preserveDom);
				});

				// Callback for when handle is manually destroyed.
				var hdhs = [];
				function onManualDestroy(){
					odh.remove();
					array.forEach(hdhs, function(hdh){
						hdh.remove();
					});
				}

				// Setup listeners for manual destroy of handle.
				// Also computes destroyMethodName, used in listener above.
				if(handle.then){
					// Special path for Promises.  Detect when Promise is resolved, rejected, or
					// canceled (nb: cancelling a Promise causes it to be rejected).
					destroyMethodName = "cancel";
					handle.then(onManualDestroy, onManualDestroy);
				}else{
					// Path for other handles.  Just use AOP to detect when handle is manually destroyed.
					array.forEach(cleanupMethods, function(cleanupMethod){
						if(typeof handle[cleanupMethod] === "function"){
							if(!destroyMethodName){
								// Use first matching method name in above listener (prefer destroyRecursive() to destroy())
								destroyMethodName = cleanupMethod;
							}
							hdhs.push(aspect.after(handle, cleanupMethod, onManualDestroy, true));
						}
					});
				}
			}, this);

			return arguments;		// handle
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/UserSessionManager':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

/**
 * 
 */

define(["dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/_Base"],
	 function(declare, _Base ) {
	
	
	return declare([_Base], {
		map:null,
		lastUserLocation:null,
		constructor: function(params)
		{
			dojo.mixin(this, params);

			dojo.addOnUnload(dojo.hitch(this, this.onMapExit));
			
			if(this.map.getSessionData() && this.map.getSessionData().lastUserLocation){			
				this.lastUserLocation=dojo.fromJson(this.map.getSessionData().lastUserLocation);
			}
			console.log(this.lastUserLocation);
		},
		hasLastUserLocation:function(){
			if(this.lastUserLocation!=null && this.lastUserLocation.lat && this.lastUserLocation.lng){
				return true;
			}
			return false;
		},
		getLastUserLocation:function(){
			return this.lastUserLocation;
		},
		
		onMapExit:function(){
			var locInfo ={				
					lat: this.map.getCenter().lat,
					lng: this.map.getCenter().lng,
					level: this.map.getZoom(),
					customData:this.map.getInitialLocationCustomInfo()
			};
			console.info("[UserSessionManager] Saving Location", locInfo);
			if (this.map.toolbar) {
				this.map.toolbar.destroyRecursive();
			}
			this.map.getMaximo().storeUserLocation(locInfo);
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/MXRecord':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/_Base",
	"ibm/tivoli/fwm/mxmap/ImageLibraryManager"],
	function(declare, _Base, ImageLibraryManager) {
		
		var LATLONGWKID = 4326;

	return declare( [_Base], {

		mboInfo: null,
		map: null,

		markerImgUrl: null,
		markerImgInfo: null,
		lbsMarker: null,
		lbsMarkerImgInfo: null,
		lbsCircle: null,
		imageLibManager: null,
		isMboOnMap: false,
		constructor: function(options)
		{
			dojo.mixin(this, options);
			// this.imageLibManager =
				// ibm.tivoli.fwm.mxmap.ImageLibraryManager.getImageLibraryManager();
		},

		/**
		 * Checks if the currrent SA record has an address
		 * 
		 * @returns true if it has any address different than ""
		 */
		hasAddress: function()
		{
			return (this.mboInfo && this.mboInfo.gisdata && this.mboInfo.gisdata.address != null && this.mboInfo.gisdata.address != "");
		},
		getAddress: function()
		{
			return this.getGISData().address;
		},
		getMXData: function()
		{
			return this.mboInfo.mxdata;
		},
		getMboName: function()
		{
			return this.getMXData().mboName;
		},
		setIsOnMap: function(isOnMap)
		{
			this.mboInfo.isOnMap = isOnMap;
		},
		hasAutolocateAddress: function()
		{
			return (this.mboInfo && this.mboInfo.gisdata && this.mboInfo.gisdata.address != null && this.mboInfo.gisdata.address != "");
		},
		getAutolocateAddress: function()
		{
			return this.getAutolocateGISData().address;
		},
		hasGISData: function()
		{
			return (this.mboInfo && (this.mboInfo.gisdata != null) && (this.mboInfo.gisdata != undefined));
		},
		hasGISCoordinates: function()
		{
			return (this.hasGISData() && (this.mboInfo.gisdata.lat != null) && (this.mboInfo.gisdata.lng != null));
		},
		hasAutolocateData: function()
		{
			return (this.mboInfo && this.mboInfo.autolocate != null && this.mboInfo.autolocate.gisdata != null);
		},
		hasAutolocateGISCoordinates: function()
		{
			return (this.hasAutolocateData() && this.getAutolocateGISData().lng != null)
			|| this.hasAutolocateSpatialData();
		},
		hasAutolocateGISOnlyCoordinates: function()
		{
			return (this.hasAutolocateData() && this.mboInfo.autolocate.gisdata.lng != null);
		},
		hasAutolocateSpatialData: function()
		{
			return (this.hasAutolocateData() && this.mboInfo.autolocate.gisdata.PLUSSISGIS != null && this.mboInfo.autolocate.gisdata.PLUSSISGIS == true);
		},
		getAutolocateGISData: function()
		{
			return this.getAutolocateMboInfo().gisdata;
		},
		getAutolocateGISLat: function()
		{
			return this.getAutolocateGISData().lat;
		},
		getAutolocateGISLng: function()
		{
			return this.getAutolocateGISData().lng;
		},
		/*
		 * Returns the latLng point for the GIS data
		 * If the sr is null, it means it has the map Spatial Reference
	 	 */
		getAutolocateGISPoint: function()
		{
			var sr = this.areGISCoordinatesLatLong() ? {"wkid": LATLONGWKID} : null;
			return this.map.latLng(this.getAutolocateGISLat(), this.getAutolocateGISLng(), sr);
		},
		hasAnyGISCoordinates: function()
		{
			return this.hasGISCoordinates() || this.hasAutolocateGISCoordinates() || this.hasSPATIALCoordinates();
		},
		hasAnyCoordinates: function()
		{
			return this.useLBSData() || this.hasAnyGISCoordinates();
		},
		hasLBSData: function()
		{
			return (this.mboInfo && (this.mboInfo.lbsdata != null) && (this.mboInfo.lbsdata != undefined));
		},
		isLBS: function()
		{
			return (this.hasGISData() && (this.getGISData().islbs == true));
		},
		isLBSOnly: function()
		{
			return (this.hasLBSData() && (this.mboInfo.lbsdata.lbsonly == true));
		},
		hasLBSCoordinates: function()
		{
			return (this.hasLBSData() && (this.mboInfo.lbsdata.lat != null));
		},
		getLBSData: function()
		{
			return this.mboInfo.lbsdata;
		},
		getLBSLat: function()
		{
			return this.getLBSData().lat;
		},
		getLBSLng: function()
		{
			return this.getLBSData().lng;
		},
		getLBSPoint: function()
		{
			return this.map.latLng(this.getLBSLat(), this.getLBSLng());
		},
		hasOwnLatLngProperties: function()
		{
			return this.mboInfo.hasOwnProperty("lat") && this.mboInfo.hasOwnProperty("lng");
		},
		getOwnLat: function()
		{
			return this.mboInfo.lat;
		},
		getOwnLng: function()
		{
			return this.mboInfo.lng;
		},
		getOwnLatLng: function()
		{
			return this.map.latLng(this.getOwnLat(), this.getOwnLng());
		},
		hasMouseover: function()
		{
			return (this.getMboInfo().mouseover != null) && (this.getMboInfo() != undefined);
		},
		getMouseover: function()
		{
			return this.getMboInfo().mouseover;
		},
		setMarker: function(marker)
		{
			this.mboInfo.marker = marker;
		},
		useLBSData: function()
		{
			var useLBSData = false;

			if(this.isLBS())
			{
				if(this.isLBSOnly())
				{
					if(this.hasLBSCoordinates())
					{
						useLBSData = true;
					}
				}
				else
				{
					var layer = this.map.getLayersManager().getLayerForObjectName(this.getMboName());
					if(layer)
					{
						var lbsDataEnabledForLayer = layer.useLBSPosition();
						if(lbsDataEnabledForLayer)
						{
							if(this.hasLBSCoordinates())
							{
								useLBSData = lbsDataEnabledForLayer;
							}
							else
							{
								// If the flow has reached here, it means that this record is a 
								// CombinedLBS record (see CombinedLBS.java) that was supposed to be
								// displayed using its LBS coordinates but does not have any.
								// A warning msg should be added to this record so that it can be retrieved later
								// and sent to Maximo
								this.mboInfo.warning = ibm.tivoli.fwm.mxmap.WarningCodes.NO_LBS_LOCATION_FOUND;
							}
						}
					}
				}
			}
			return useLBSData;
		},

		hasSPATIALCoordinates: function()
		{
			return (this.hasGISData() && this.mboInfo.gisdata.PLUSSISGIS == true);
		},
		_removeHighlight: function() {
			console.log("[mxmap.MXRecord._removeHighlight] calling map.removeMboMarker " + this.mboInfo.mxdata.uid.value);
			this.map.removeMboHighligh(this.mboInfo);						
		},
		_removeMarker: function()
		{
			console.log("[mxmap.MXRecord._removeMarker] calling map.removeMboMarker " + this.mboInfo.mxdata.uid.value);
			this.map.removeMboMarker(this.mboInfo);
			this.isMboOnMap = false;
		},
		/**
		 * Triggered always that any new data from server is
		 * received. It will update the current representation of
		 * the current record on the map.
		 */
		serverUpdated: function(data)
		{
			console.log("MXRecord.serverUpdated ");
			this.mboInfo = data;
			this.isMboOnMap = false;
			this._updateMarkerLocation(data);
		},
		/**
		 * Updates the current marker based on the new location
		 * data. It also publishes the event that the current record
		 * location has been updated thru 'onCurrentLocationUpdated'
		 * event
		 */
		_updateMarkerLocation: function(newMboInfo, noZoom)
		{
			console.log("[MXrecord] Updating  Location ", newMboInfo);
			this._removeMarker();
			this._removeHighlight();
			this.mboInfo = newMboInfo;
			if (this.hasAnyCoordinates())
			{
				this._placeMarker();
				if (noZoom != true)
				{
					this.center();
				}
			}

		},

		/**
		 * Places a marker for the current record. Also adds a
		 * handler for dragging event of this marker.
		 */
		_placeMarker: function()
		{

			this.map.addMboToLayerManager(this.mboInfo);
			this.isMboOnMap = true;
		},

		/**
		 * Center the map over the current record
		 */
		center: function()
		{
			this.centerAndZoom();
		},

		/**
		 * Center the map over the current record and zoom.
		 * 
		 * @param zoom
		 *            level
		 */
		centerAndZoom: function(zoomLevel)
		{
			if (this.hasAnyCoordinates())
			{
				console.log("[MXRecord] About to center and zoom on record on marker");
				if (this.isMboOnMap == false)
				{
					this._placeMarker();
				}

				this.map.centerOnMbo(this.mboInfo, zoomLevel);

			}
		},
		getGISData: function()
		{
			return this.mboInfo.gisdata;
		},
		getGISLat: function()
		{
			return this.getGISData().lat;
		},
		getGISLng: function()
		{
			return this.getGISData().lng;
		},
		/*
		 * Returns the latLng point for the GIS data
		 * If the sr is null, it means it has the map Spatial Reference
	 	 */
		getGISPoint: function()
		{
			var sr = this.areGISCoordinatesLatLong() ? {"wkid": LATLONGWKID} : null;
			return this.map.latLng(this.getGISLat(), this.getGISLng(), sr);
		},
		getGISDataFlags: function()
		{
			return this.getGISData().flags;
		},
		areGISCoordinatesLatLong: function() {
			var latLongCoordinates = false;
			if (this.map.providerName == "maximospatial") {
				var gisData = this.getGISData();
				if (gisData && gisData.isCoordLatLong) {
					latLongCoordinates = true;
				}
			}
			return latLongCoordinates;
		},
		isGISDataReadOnly: function()
		{
			return (this.getGISDataFlags().readonly == true);
		},
		hasPointInCurrentSR: function()
		{
			return (this.mboInfo && (this.mboInfo.pointInCurrentSR != null) && (this.mboInfo.pointInCurrentSR != undefined))
		},
		getPointInCurrentSRLat: function()
		{
			return this.mboInfo.pointInCurrentSR.lat;
		},
		getPointInCurrentSRLng: function()
		{
			return this.mboInfo.pointInCurrentSR.lng;
		},
		getPointInCurrentSR: function()
		{
			return this.map.latLng(this.getPointInCurrentSRLat(), this.getPointInCurrentSRLng());
		},
		setPointInCurrentSR: function(point)
		{
			this.mboInfo.pointInCurrentSR = point;
		},
		getMboInfo: function()
		{
			return this.mboInfo;
		},
		getAutolocateMboInfo: function()
		{
			return this.mboInfo.autolocate;
		},
		/* 12-100070 */
		_isDraggable: function()
		{
			if (this.mboInfo.gisdata && this.mboInfo.gisdata.flags && this.mboInfo.gisdata.flags.readonly == true)
			{
				return false;
			}
			return (this.draggable && this.draggable == true);
		},
		hide: function()
		{
			console.log("[MXRecord] hiding marker", this);

		},
		remove: function()
		{
			this._removeMarker();
		},
		show: function()
		{
			if (this.isMboOnMap == false)
			{
				if (this.hasAnyCoordinates() == true)
				{
					this._placeMarker();

				}
			}
		},
		getWarning: function()
		{
			return this.mboInfo.warning;
		},
		getActivityId: function()
		{
			return this.mboInfo.activityid;
		},
		getMapTipOverrides: function()
		{
			return this.mboInfo.maptipoverrides;
		}
	});
});

},
'dijit/layout/_ContentPaneResizeMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.filter array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.contains domClass.toggle
	"dojo/dom-geometry", // domGeometry.contentBox domGeometry.marginBox
	"dojo/dom-style",
	"dojo/_base/lang", // lang.mixin
	"dojo/query", // query
	"../registry", // registry.byId
	"../Viewport",
	"./utils" // marginBox2contextBox
], function(array, declare, domClass, domGeometry, domStyle, lang, query,
			registry, Viewport, layoutUtils){

	// module:
	//		dijit/layout/_ContentPaneResizeMixin

	return declare("dijit.layout._ContentPaneResizeMixin", null, {
		// summary:
		//		Resize() functionality of ContentPane.   If there's a single layout widget
		//		child then it will call resize() with the same dimensions as the ContentPane.
		//		Otherwise just calls resize on each child.
		//
		//		Also implements basic startup() functionality, where starting the parent
		//		will start the children

		// doLayout: Boolean
		//		- false - don't adjust size of children
		//		- true - if there is a single visible child widget, set it's size to however big the ContentPane is
		doLayout: true,

		// isLayoutContainer: [protected] Boolean
		//		Indicates that this widget will call resize() on it's child widgets
		//		when they become visible.
		isLayoutContainer: true,

		startup: function(){
			// summary:
			//		See `dijit/layout/_LayoutWidget.startup()` for description.
			//		Although ContentPane doesn't extend _LayoutWidget, it does implement
			//		the same API.

			if(this._started){
				return;
			}

			var parent = this.getParent();
			this._childOfLayoutWidget = parent && parent.isLayoutContainer;

			// I need to call resize() on my child/children (when I become visible), unless
			// I'm the child of a layout widget in which case my parent will call resize() on me and I'll do it then.
			this._needLayout = !this._childOfLayoutWidget;

			this.inherited(arguments);

			if(this._isShown()){
				this._onShow();
			}

			if(!this._childOfLayoutWidget){
				// Since my parent isn't a layout container, and my style *may be* width=height=100%
				// or something similar (either set directly or via a CSS class),
				// monitor when viewport size changes so that I can re-layout.
				// This is more for subclasses of ContentPane than ContentPane itself, although it
				// could be useful for a ContentPane if it has a single child widget inheriting ContentPane's size.
				this.own(Viewport.on("resize", lang.hitch(this, "resize")));
			}
		},

		_checkIfSingleChild: function(){
			// summary:
			//		Test if we have exactly one visible widget as a child,
			//		and if so assume that we are a container for that widget,
			//		and should propagate startup() and resize() calls to it.
			//		Skips over things like data stores since they aren't visible.

			if(!this.doLayout){ return; }

			var candidateWidgets = [],
				otherVisibleNodes = false;

			query("> *", this.containerNode).some(function(node){
				var widget = registry.byNode(node);
				if(widget && widget.resize){
					candidateWidgets.push(widget);
				}else if(!/script|link|style/i.test(node.nodeName) && node.offsetHeight){
					otherVisibleNodes = true;
				}
			});

			this._singleChild = candidateWidgets.length == 1 && !otherVisibleNodes ?
				candidateWidgets[0] : null;

			// So we can set overflow: hidden to avoid a safari bug w/scrollbars showing up (#9449)
			domClass.toggle(this.containerNode, this.baseClass + "SingleChild", !!this._singleChild);
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		See `dijit/layout/_LayoutWidget.resize()` for description.
			//		Although ContentPane doesn't extend _LayoutWidget, it does implement
			//		the same API.

			this._resizeCalled = true;

			this._scheduleLayout(changeSize, resultSize);
		},

		_scheduleLayout: function(changeSize, resultSize){
			// summary:
			//		Resize myself, and call resize() on each of my child layout widgets, either now
			//		(if I'm currently visible) or when I become visible
			if(this._isShown()){
				this._layout(changeSize, resultSize);
			}else{
				this._needLayout = true;
				this._changeSize = changeSize;
				this._resultSize = resultSize;
			}
		},

		_layout: function(changeSize, resultSize){
			// summary:
			//		Resize myself according to optional changeSize/resultSize parameters, like a layout widget.
			//		Also, since I am an isLayoutContainer widget, each of my children expects me to
			//		call resize() or layout() on it.
			//
			//		Should be called on initialization and also whenever we get new content
			//		(from an href, or from set('content', ...))... but deferred until
			//		the ContentPane is visible

			delete this._needLayout;

			// For the TabContainer --> BorderContainer --> ContentPane case, _onShow() is
			// never called directly, so resize() is our trigger to do the initial href download (see [20099]).
			// However, don't load href for closed TitlePanes.
			if(!this._wasShown && this.open !== false){
				this._onShow();
			}

			// Set margin box size, unless it wasn't specified, in which case use current size.
			if(changeSize){
				domGeometry.setMarginBox(this.domNode, changeSize);
			}

			// Compute content box size of containerNode in case we [later] need to size our single child.
			var cn = this.containerNode;
			if(cn === this.domNode){
				// If changeSize or resultSize was passed to this method and this.containerNode ==
				// this.domNode then we can compute the content-box size without querying the node,
				// which is more reliable (similar to LayoutWidget.resize) (see for example #9449).
				var mb = resultSize || {};
				lang.mixin(mb, changeSize || {}); // changeSize overrides resultSize
				if(!("h" in mb) || !("w" in mb)){
					mb = lang.mixin(domGeometry.getMarginBox(cn), mb); // just use domGeometry.setMarginBox() to fill in missing values
				}
				this._contentBox = layoutUtils.marginBox2contentBox(cn, mb);
			}else{
				this._contentBox = domGeometry.getContentBox(cn);
			}

			this._layoutChildren();
		},

		_layoutChildren: function(){
			// Call _checkIfSingleChild() again in case app has manually mucked w/the content
			// of the ContentPane (rather than changing it through the set("content", ...) API.
			this._checkIfSingleChild();

			if(this._singleChild && this._singleChild.resize){
				var cb = this._contentBox || domGeometry.getContentBox(this.containerNode);

				// note: if widget has padding this._contentBox will have l and t set,
				// but don't pass them to resize() or it will doubly-offset the child
				this._singleChild.resize({w: cb.w, h: cb.h});
			}else{
				// All my child widgets are independently sized (rather than matching my size),
				// but I still need to call resize() on each child to make it layout.
				var children = this.getChildren(),
					widget,
					i = 0;
				while(widget = children[i++]){
					if(widget.resize){
						widget.resize();
					}
				}
			}
		},

		_isShown: function(){
			// summary:
			//		Returns true if the content is currently shown.
			// description:
			//		If I am a child of a layout widget then it actually returns true if I've ever been visible,
			//		not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
			//		tree every call, and at least solves the performance problem on page load by deferring loading
			//		hidden ContentPanes until they are first shown

			if(this._childOfLayoutWidget){
				// If we are TitlePane, etc - we return that only *IF* we've been resized
				if(this._resizeCalled && "open" in this){
					return this.open;
				}
				return this._resizeCalled;
			}else if("open" in this){
				return this.open;		// for TitlePane, etc.
			}else{
				var node = this.domNode, parent = this.domNode.parentNode;
				return (node.style.display != 'none') && (node.style.visibility != 'hidden') && !domClass.contains(node, "dijitHidden") &&
					parent && parent.style && (parent.style.display != 'none');
			}
		},

		_onShow: function(){
			// summary:
			//		Called when the ContentPane is made visible
			// description:
			//		For a plain ContentPane, this is called on initialization, from startup().
			//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
			//		called whenever the pane is made visible.
			//
			//		Does layout/resize of child widget(s)

			// Need to keep track of whether ContentPane has been shown (which is different than
			// whether or not it's currently visible).
			this._wasShown = true;

			if(this._needLayout){
				// If a layout has been scheduled for when we become visible, do it now
				this._layout(this._changeSize, this._resultSize);
			}

			this.inherited(arguments);
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/CurrentMXRecordSet':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */


define(["dojo/main", "dojo/_base/declare",
		 "ibm/tivoli/fwm/mxmap/_Base",
		 "ibm/tivoli/fwm/mxmap/MXRecord"],
		 function(dojo, declare, _Base, MXRecord) {

	return declare( [_Base], {
		map: null,
		records: null,
		mxRecords: null,
		mboInfoArray: null,
		markerImgUrl: null,
		_hidden: false,
		constructor: function(options)
		{
			dojo.mixin(this, options);
			this.mxRecords = [];
			this.mboInfoArray = [];
			// this.records = new ibm.tivoli.fwm.mxmap.MXRecordSet({map: this.map,
			// records: this.records, markerImgUrl: this.markerImgUrl});
			this.addSubscription("onCurrentRecordSetUpdated_" + this.map.getId(), dojo.hitch(this, this.updateRecordSetAndRefresh));
			if (this.records != null)
			{
				this.updateRecordSet(this.records);
			}
		},
		isEmpty: function()
		{
			if (this.mxRecords)
			{
				for ( var id in this.mxRecords)
				{
					return false;
				}
			}
			return true;
		},
		centerAndZoom: function()
		{
			this.map.zoomToMbos(this.mboInfoArray);
		},
		showMXRecordsOnMap: function(noZoom)
		{
			var markerOptions = {
					"enableMapTips": true
			};

			this.map.showAllMboRecords(this.mboInfoArray, markerOptions, noZoom != true);
			this._hidden = false;
		},
		updateRecordSetAndRefresh: function(newRecords, noZoom)
		{
			this.updateRecordSet(newRecords);
			this.showMXRecordsOnMap(noZoom);
		},
		length: function()
		{
			return this.mxRecords.length;
		},
		updateRecordSet: function(newRecords)
		{
			while (this.mxRecords.length > 0)
			{
				var mxRec = this.mxRecords.pop();
				mxRec._removeMarker();
			}

			this.records = newRecords;
			this.mxRecords = [];
			this.mboInfoArray = [];
			for ( var id in this.records)
			{
				var mxRec = new MXRecord({
					mboInfo: this.records[id],
					map: this.map
				});
				if (mxRec.hasAnyCoordinates())
				{
					this.mxRecords.push(mxRec);
					this.mboInfoArray.push(this.records[id]);
				}
			}
		},

		destroyRecursive: function()
		{
			this.inherited(arguments);

		},
		getWarning: function()
		{
			var warning = null;
			for(var i=0; i<this.mxRecords.length; i++)
			{
				warning = this.mxRecords[i].getWarning();
				// TODO: For now there is only one possible warning
				// Add the code to handle more when necessary
				if(warning)
				{
					break;
				}
			}
			return warning;
		}
	});
});

},
'dojo/dnd/Moveable':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"../_base/array", "../_base/declare", "../_base/lang", "../dom", "../dom-class", "../Evented",
	"../has", "../on", "../topic", "../touch", "./common", "./Mover", "../_base/window"
], function(array, declare, lang, dom, domClass, Evented, has, on, topic, touch, dnd, Mover, win){

// module:
//		dojo/dnd/Moveable

var touchActionPropertyName;
var setTouchAction = function () {};

function setTouchActionPropertyName() {
	if ("touchAction" in document.body.style) {
		touchActionPropertyName = "touchAction";
	}
	else if ("msTouchAction" in document.body.style) {
		touchActionPropertyName = "msTouchAction";
	}
	setTouchAction = function setTouchAction(/* Node */ node, /* string */ action) {
		node.style[touchActionPropertyName] = action;
	}
	setTouchAction(arguments[0], arguments[1]);
}

if (has("touch-action")) {
	// Ensure that the logic to determine "touchActionPropertyName" runs
	setTouchAction = setTouchActionPropertyName;
}

var Moveable = declare("dojo.dnd.Moveable", [Evented], {
	// summary:
	//		an object, which makes a node movable

	// object attributes (for markup)
	handle: "",
	delay: 0,
	skip: false,

	constructor: function(node, params){
		// node: Node
		//		a node (or node's id) to be moved
		// params: Moveable.__MoveableArgs?
		//		optional parameters
		this.node = dom.byId(node);
		setTouchAction(this.node, "none");
		if(!params){ params = {}; }
		this.handle = params.handle ? dom.byId(params.handle) : null;
		if(!this.handle){ this.handle = this.node; }
		this.delay = params.delay > 0 ? params.delay : 0;
		this.skip  = params.skip;
		this.mover = params.mover ? params.mover : Mover;
		this.events = [
			on(this.handle, touch.press, lang.hitch(this, "onMouseDown")),
			// cancel text selection and text dragging
			on(this.handle, "dragstart",   lang.hitch(this, "onSelectStart")),
			on(this.handle, "selectstart",   lang.hitch(this, "onSelectStart"))
		];
	},

	// markup methods
	markupFactory: function(params, node, Ctor){
		return new Ctor(node, params);
	},

	// methods
	destroy: function(){
		// summary:
		//		stops watching for possible move, deletes all references, so the object can be garbage-collected
		array.forEach(this.events, function(handle){ handle.remove(); });
		setTouchAction(this.node, "");
		this.events = this.node = this.handle = null;
	},

	// mouse event processors
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown/ontouchstart, creates a Mover for the node
		// e: Event
		//		mouse/touch event
		if(this.skip && dnd.isFormElement(e)){ return; }
		if(this.delay){
			this.events.push(
				on(this.handle, touch.move, lang.hitch(this, "onMouseMove")),
				on(this.handle.ownerDocument, touch.release, lang.hitch(this, "onMouseUp"))
			);
			this._lastX = e.pageX;
			this._lastY = e.pageY;
		}else{
			this.onDragDetected(e);
		}
		e.stopPropagation();
		e.preventDefault();
	},
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove, used only for delayed drags
		// e: Event
		//		mouse/touch event
		if(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay){
			this.onMouseUp(e);
			this.onDragDetected(e);
		}
		e.stopPropagation();
		e.preventDefault();
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup, used only for delayed drags
		// e: Event
		//		mouse event
		for(var i = 0; i < 2; ++i){
			this.events.pop().remove();
		}
		e.stopPropagation();
		e.preventDefault();
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skip || !dnd.isFormElement(e)){
			e.stopPropagation();
			e.preventDefault();
		}
	},

	// local events
	onDragDetected: function(/*Event*/ e){
		// summary:
		//		called when the drag is detected;
		//		responsible for creation of the mover
		new this.mover(this.node, e, this);
	},
	onMoveStart: function(/*Mover*/ mover){
		// summary:
		//		called before every move operation
		topic.publish("/dnd/move/start", mover);
		domClass.add(win.body(), "dojoMove");
		domClass.add(this.node, "dojoMoveItem");
	},
	onMoveStop: function(/*Mover*/ mover){
		// summary:
		//		called after every move operation
		topic.publish("/dnd/move/stop", mover);
		domClass.remove(win.body(), "dojoMove");
		domClass.remove(this.node, "dojoMoveItem");
	},
	onFirstMove: function(/*===== mover, e =====*/){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.
		// mover: Mover
		// e: Event

		// default implementation does nothing
	},
	onMove: function(mover, leftTop /*=====, e =====*/){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		// mover: Mover
		// leftTop: Object
		// e: Event
		this.onMoving(mover, leftTop);
		var s = mover.node.style;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	},
	onMoving: function(/*===== mover, leftTop =====*/){
		// summary:
		//		called before every incremental move; can be overwritten.
		// mover: Mover
		// leftTop: Object

		// default implementation does nothing
	},
	onMoved: function(/*===== mover, leftTop =====*/){
		// summary:
		//		called after every incremental move; can be overwritten.
		// mover: Mover
		// leftTop: Object

		// default implementation does nothing
	}
});

/*=====
Moveable.__MoveableArgs = declare([], {
	// handle: Node||String
	//		A node (or node's id), which is used as a mouse handle.
	//		If omitted, the node itself is used as a handle.
	handle: null,

	// delay: Number
	//		delay move by this number of pixels
	delay: 0,

	// skip: Boolean
	//		skip move of form elements
	skip: false,

	// mover: Object
	//		a constructor of custom Mover
	mover: dnd.Mover
});
=====*/

return Moveable;
});

},
'ibm/tivoli/fwm/mxmap/CurrentMXRecManager':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/main", "dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/MXRecord",
	"ibm/tivoli/fwm/mxmap/_Base",
	"ibm/tivoli/fwm/mxmap/ImageLibraryManager"],
	function(dojo, declare, MXRecord, _Base, ImageLibraryManager) {

	return declare([MXRecord], {

		map: null,
		currentMarker: null,
		markerImgUrl: null,
		recordSet: null,
		currentFromRecSet: false,
		mbo: null,
		mboInfo: null,
		draggable: true,
		constructor: function(options)
		{
			dojo.mixin(this, options);
			if (!this.markerImgUrl)
			{
				this.markerImgUrl = ImageLibraryManager.getImageLibraryManager().getDefaultMarkerImageInfo().getImageURL();
			}
			this.addSubscription("onCurrentRecordUpdate_" + this.map.getId(), dojo.hitch(this, this.serverUpdated));
			this.recordSet = this.map.getCurrentRecordSetControl();
			this.mboInfo = options.mbo;
		},
		disposeMarker: function()
		{
			this._removeMarker();
			// remove current marker listener, return it to rec set if needed
			// if (this.currentFromRecSet == true)
			// {
			// this.recordSet.updateMXRecord(this.mboInfo.mxdata.uid,
			// this.mboInfo.mxdata, this.mboInfo.gisdata);
			// this.recordSet.showMXRecord(this.mboInfo.mxdata.uid);
			//
			// }
		},
		showCurrentRecord: function(noZoom)
		{
			if (this.mbo)
			{
				this.serverUpdated(this.mbo, noZoom);
			}
		},
		/**
		 * Triggered always that any new data from server is received. It will
		 * update the current representation of the current record on the map.
		 */
		serverUpdated: function(data, noZoom)
		{

			console.log("[CurrentMXRecManager] Server Updated with data", data);

			if (this.mboInfo && this.mboInfo.mxdata)
			{

				console.log("[CurrentMXRecManager] Trying to dispose current marker", this.mboInfo.mxdata);

				if (this.mboInfo.mxdata.uid.name != data.mxdata.uid.name || this.mboInfo.mxdata.uid.value != data.mxdata.uid.value)
				{
					this.disposeMarker();
					this.isMboOnMap = false;
				}
			}

			this.currentFromRecSet = false;
			if (this.mboInfo.highlightGraphic) {
				data.highlightGraphic = this.mboInfo.highlightGraphic;
			}
			this.mboInfo = data;
			this.mbo = data;
			this._updateMarkerLocation(data, noZoom);

		},

		/**
		 * Places a marker for the current record. Also adds a handler for dragging
		 * event of this marker.
		 */
		_placeMarker: function()
		{
			var that = this;
			var convertedPoint;

			if (this.map.mapConf.provider == 'spatial') {
				if (this.mboInfo.gisdata.isCoordLatLong && this.map.map.spatialReference.wkid != "4326") {
					var inputPoint = new esri.geometry.Point(that.mboInfo.gisdata.lng, that.mboInfo.gisdata.lat, new esri.SpatialReference({wkid: 4326}));
					convertedPoint = esri.geometry.project(inputPoint, this.map.map.spatialReference);

					that.mboInfo.gisdata.lng = convertedPoint.x;
					that.mboInfo.gisdata.lat = convertedPoint.y;
					that.mboInfo.gisdata.isCoordLatLong = false;
					that.mboInfo.gisdata.convertedFromLatLong = true;
				}
			}		

			var markerOptions = {
					"events": {
						"onMoveEnd": dojo.hitch(that, that.movedMarker)
					},
					"enableMapTips": true,
					"dontDrawAsOverlay": true
			};
			that.map.addMboToLayerManager(that.mboInfo, markerOptions);
			that.isMboOnMap = true;

		},

		/**
		 * Updates the current marker based on the new location data. It also
		 * publishes the event that the current record location has been updated
		 * thru 'onCurrentLocationUpdated' event
		 */
		_updateMarkerLocation: function(newMboInfo, noZoom)
		{
			this.inherited(arguments);
			dojo.publish("onCurrentLocationUpdated_" + this.map.getId());
			// if (noZoom != true)
			// {
			// this.center();
			// }
		},

		/**
		 * Returns a simple map tip for the current record TBD
		 */
		/*
		 * getMapTipData: function(mxdata) { var textBubble = mxdata.mboName + "\n" +
		 * mxdata.mboInfo.ADDRESSCODE + "\n" + mxdata.mboInfo.ORGID; return {
		 * infoBubble: textBubble, label: null,// nothing specified in spec. marker:
		 * 4, icon: this.markerImgUrl, iconSize: [ 32, 32 ], draggable:
		 * this._isDraggable(), hover: false }; },
		 */

		/**
		 * Triggered after the current record marker is moved. It then sends to the
		 * server the new record location
		 */
		movedMarker: function(event_args)
		{
			if (dojo.config.fwm.debug == true)
			{
				console.log("[CurrentMXRecManager] Marker moved", event_args.newLocation);
			}
			this.reverseGeocodeCurrentRecord(event_args.newLocation, false);
		},

		/**
		 * Set the current SA record location
		 * 
		 * @param {lat,lng,address}
		 */
		setServersCurrentRecordLocation: function(newGISlocation)
		{
			this.map.getMaximo().setCurrentRecordLocation(newGISlocation);
		},

		/**
		 * Reverse geocode the current record.
		 * 
		 * @param newGISlocation -
		 *            Opcional, only if want to use a different position than the
		 *            current marker one.
		 */
		reverseGeocodeCurrentRecord: function(newGISlocation, addressOnly)
		{
			if (!newGISlocation)
			{
				if (dojo.config.fwm.debug == true)
				{
					console.log("[CurrentMXRecManager] New Location has no GIS Data - Using current location");
				}
				newGISlocation = this.currentMarker.location;
			}
			var fctError = function(error)
			{
				this.reverseGeocodeCallbackError(error, newGISlocation, addressOnly);
			};
			var fctSuccess = function(revData)
			{
				this.reverseGeocodeCallback(revData, newGISlocation);
			};

			this.map.geocoder.reverseGeocode(newGISlocation.lat, newGISlocation.lng, dojo.hitch(this, fctSuccess), dojo.hitch(this, fctError));
		},
		reverseGeocodeAddressOnly: function()
		{
			this.reverseGeocodeCurrentRecord(null, true);
		},
		/**
		 * In case it fails to find an address based on the coordinates only the
		 * coordinates are set. If the coordinates has not changed nothing is
		 * updated on the server.
		 * 
		 * @param error -
		 *            error code
		 * @see ibm.tivoli.fwm.mxmap.Geocoder.ErrorCodes
		 * @param point -
		 *            from this reverse geocode was executed
		 */
		reverseGeocodeCallbackError: function(error, point, addressOnly)
		{
			if (dojo.config.fwm.debug == true)
			{
				console.log("[CurrentMXRecManager] Error during reverse geocoding for current record", error);
			}
			if (addressOnly && addressOnly == true)
			{
				// only address is needed. no x/y needed.
				if (dojo.config.fwm.debug == true)
				{
					console.log("[CurrentMXRecManager] No address found");
				}
				this.map.getMaximo().showMessage("mapserver", "auto_revgeocode_noresults");
				return;
			}
			else
			{
				if (!this.currentMaker || point.lat != this.currentMarker.location.lat || point.lng != this.currentMarker.location.lng)
				{
					if (dojo.config.fwm.debug == true)
					{
						console.log("[CurrentMXRecManager] Coordinates changed, setting value on server", point);
					}
					if (point.lat && point.lng)
					{
						this.map.getMaximo().setCurrentRecordLocation({
							lat: point.lat,
							lng: point.lng
						}, "FAILED_REV_GEOCODE");
					}
				}
			}
		},

		/**
		 * An address was during reverse geocoding. Only its address is set into the
		 * SA record. The coordinates are the same of the marker.
		 * 
		 * @param location -
		 *            usually where marker was dropped
		 * @param originalLocation -
		 *            from where it was moved
		 */
		reverseGeocodeCallback: function(location, originalLocation)
		{
			if (dojo.config.fwm.debug == true)
			{
				console.log("[CurrentMXRecManager] Processing reverseGeocodeCallback: ", location);
			}
			var point = originalLocation;

			if (this.map.mapConf.provider == 'spatial') {
				if ((this.mboInfo.gisdata.isCoordLatLong || this.mboInfo.gisdata.convertedFromLatLong) && this.map.map.spatialReference.wkid != "4326") {
					var inputPoint = new esri.geometry.Point(point.lng, point.lat, this.map.map.spatialReference);
					convertedPoint = esri.geometry.project(inputPoint, new esri.SpatialReference({wkid: 4326}) );
					point.lng = convertedPoint.x;
					point.lat = convertedPoint.y;
				}
			}		


			// gets the address of the first record as
			// we are working with x/y coordinates
			var address = location[0].formattedAddress;
			this.map.getMaximo().setCurrentRecordLocation({
				lat: point.lat,
				lng: point.lng,
				address: address
			});
		},

		convertFromLatLongToXY: function(lat, lon, callback) {

			if (this.map.mapConf.provider != 'spatial') {
				callback(lat, lon);
				return;
			}

			console.log("[CurrentMXRecManager] Provider is spatial, running convertFromLatLongToXY()");

			if (this.map.mapConf.geometryServiceUrl) {
				console.log("[CurrentMXRecManager] Geometry Service turned on");

				//var GS = new esri.tasks.GeometryService(this.map.mapConf.geometryServiceUrl);

				// LatLong Spatial Reference = 102100
				var SR = new esri.SpatialReference({
					wkid: 102100
				});			

				var p = new esri.geometry.Point(lon, lat, SR);
				console.log("[CurrentMXRecManager] Point Converted to SR 102100");
				console.log("[CurrentMXRecManager] Spatial Ref: "+this.map.map.spatialReference.wkid);
				console.log("[CurrentMXRecManager] Call back");
				callback(p.y, p.x);

			} else {
				console.log("[CurrentMXRecManager] Geometry Service URL is null, skipping convertFromLatLongToXY()");
				callback(lat, lon);
			}			
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/helpers/MapFullScreenHelper':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

/**
 * MapFullScreenHelper implementation. Encapsulates the full screen code.
 */
define(["dojo/_base/declare",
	"dojo/dom",
	"ibm/tivoli/fwm/mxmap/_Base"],
	 function(declare, dom, _Base ) {
		return declare([_Base], {
			map: null,
			mapDivElement: null,
			mapDivWidth: null,
			mapDivHeight: null,
			tabGroupShell: null,
			_fullScreenOn: false,
			_keyHandler: null,
			_origViewPortContent: null,
			_oldOverflow: null,
			_oldBodyParentOverflow: null,
			_origClientAreaInfo: null,
			_origOnScrollFunction: null,
			mapToolbar: null,
			_isAndroid: false,
			constructor: function(options)
			{
				dojo.mixin(this, options);
				this._fullScreenOn = false;
				this._isAndroid = navigator.userAgent.indexOf("Android") > -1;
			},
			_checkForESCKey: function(event)
			{
				if (event.keyCode == dojo.keys.ESCAPE)
				{
					this.fullScreenModeOff();
				}
			},
			_doPreSetupIfIE: function(saveData)
			{
				if (dojo.isIE && true !== this.map.isMobile)
				{
					// Need to adjust the client area due to fix of issue 12-10107
					// we make the client area 'full screen'
					// clientAreaId is a value that is made available by Maximo
					if (window.clientAreaId)
					{
						var clientArea = dojo.byId(window.clientAreaId);
						if (clientArea)
						{
							if (true === saveData)
							{
								var position = (clientArea.style.position || "relative");
								var overflow = (clientArea.style.overflow || "auto");
								this._origClientAreaInfo = {
									height: clientArea.style.height,
									width: clientArea.style.width,
									scrollTop: clientArea.scrollTop,
									scrollLeft: clientArea.scrollLeft,
									position: position,
									overflow: overflow
								};
							}
							else
							{
								this._origClientAreaInfo = {
									height: clientArea.style.height,
									width: clientArea.style.width,
									scrollTop: this._origClientAreaInfo.scrollTop,
									scrollLeft: this._origClientAreaInfo.scrollLeft,
									position: this._origClientAreaInfo.position,
									overflow: this._origClientAreaInfo.overflow
								};
							}
							clientArea.scrollTop = 0;
							clientArea.scrollLeft = 0;
							dojo.style(clientArea, {
								'width': dijit.getViewport().w + "px",
								'height': dijit.getViewport().h + "px",
								'top': '0px',
								'left': '0px',
								'position': 'absolute',
								'overflow': 'hidden'
							});

						}
					}
					// Hides the applet so it will not show up on the map when in full
					// screen mode
					var calendarViewDiv = dojo.byId("calviewAppletDiv");
					if (calendarViewDiv != null)
					{
						dojo.style(calendarViewDiv, {
							'display': 'none'
						});
					}
				}
			},
			_undoPreSetupIfIE: function()
			{
				if (dojo.isIE && true !== this.map.isMobile)
				{
					// Need to adjust the client area due to fix of issue 12-10107
					// we make the client area 'full screen'
					// clientAreaId is a value that is made available by Maximo
					if (window.clientAreaId)
					{
						var clientArea = dojo.byId(window.clientAreaId);
						if (clientArea)
						{
							dojo.style(clientArea, {
								'width': this._origClientAreaInfo.width,
								'height': this._origClientAreaInfo.height,
								'position': this._origClientAreaInfo.position,
								'overflow': this._origClientAreaInfo.overflow
							});
							clientArea.scrollTop = this._origClientAreaInfo.scrollTop;
							clientArea.scrollLeft = this._origClientAreaInfo.scrollLeft;
						}
					}
					// Shows the applet again
					var calendarViewDiv = dojo.byId("calviewAppletDiv");
					if (calendarViewDiv != null)
					{
						dojo.style(calendarViewDiv, {
							'display': 'block'
						});
					}
				}
			},
			fullScreenModeOn: function()
			{
				if (this._fullScreenOn == false)
				{
					this._doPreSetupIfIE(true);
					// 12-12451. _adjustScrolls() is now being called before
					// _adjustMapToFullScreen() so that the scroll does not
					// affect the value of dijit.getViewport().w
					this._adjustScrolls();
					this._setViewPortSettings();
					this._adjustMapToFullScreen();
					this._hideElementsHackOn();
					/* 12-10287 */
					this._adjustOpacity();
					this._fullScreenOn = true;
					this._keyHandler = dojo.connect(document, "onkeypress", dojo.hitch(this, this._checkForESCKey));

					// Issue 12-11271
					var _left = 0;
					window.top.scrollTo(_left, 0);

					// need to notify the map of the changes in div size
					// 12-10547 - reduces in this.map.toolbar.getToolbarHeight() pixels
					// the height to not hide the map info at the bottom
					var toolbarHeight = 0;
					if (this.map.toolbar)
					{
						toolbarHeight = this.map.toolbar.getToolbarHeight();
					}
					this.map.resizeTo(dijit.getViewport().w, dijit.getViewport().h - toolbarHeight);
					dojo.publish("mapFullScreenModeChanged_" + this.map.getId(), [ {
						modeOn: true
					} ]);
				}
				else
				{
					if (dojo.config.fwm.debug == true)
					{
						console.log("[MapFullScreenHelper] Full Screen is already on");
					}
				}
			},
			_getIsRTL: function() {
				if (document && document.body) {
					return document.body.getAttribute('dir') === 'rtl';
				}

				return false;
			},
			_adjustMapToFullScreen: function()
			{
				//console.log("[_adjustMapToFullScreen] Viewport = " + dijit.getViewport().w + "," + dijit.getViewport().h);
				
				// On Android, after we make it full screen and the user had zoomed into the page,
				// the resize event is called multiple times, the last one of which with a wrong
				// (too small) size. We ignore those resize events here, assuming we already
				// resized to the correct size.
				if (dijit.getViewport().w < 200 || dijit.getViewport().h < 200)
				{
					return;
				}

				var _top = "0px";
				var _left = 0;
				var _width = "100%";
				var _spacing = 0;
				var _spacingKey = this._getIsRTL() ? 'right' : 'left';
				
				var applicationNavigationMenu = dojo.query('.application-navigation-menu')[0];
				if (applicationNavigationMenu) {
					_spacing = parseInt(dojo.style(applicationNavigationMenu, 'width')) || 0;
					_width = "calc(100% - " + _spacing + "px)";
				}
				
				if (this.mapToolbar)
				{
					var divElement = this.mapToolbar.getToolbarDivElement();
					this.tabGroupShell = dojo.query('.tabgroupShell');
					// 12-13272. Do not set z-index if IE, otherwise maximo dialogs will
					// be hidden
					if (dojo.isIE && (this.map.isMobile == true))
					{
						dojo.style(divElement, {
							'width': dijit.getViewport().w + "px",
							'top': '0px',
							'left': _left + "px",
							'position': 'absolute'
						});
					}
					else
					{
						var newStyle = {
							'width': _width,
							'top': '0px',
							'position': 'fixed',
							'zIndex': '1001'
						};
						newStyle[_spacingKey] = _spacing + "px";

						dojo.style(divElement, newStyle);
						if (this.tabGroupShell.length) {
							this.tabGroupShell.style('display', 'none');
						}
					}
					_top = divElement.offsetHeight + "px";
				}
				// 12-10547 - reduces in 20 pixels the height to not hide the map info
				// at the bottom
				// 12-10765 and 12-10674 - reduces zIndex
				// 12-12707 - using the correct toolbar height
				var toolbarHeight = 0;
				if (this.map.toolbar)
				{
					toolbarHeight = this.map.toolbar.getToolbarHeight();
				}

				//console.log("[_adjustMapToFullScreen] toolbarHeight = " + toolbarHeight);
				//console.log("[_adjustMapToFullScreen] Viewport = " + dijit.getViewport().w + "," + dijit.getViewport().h);
				
				// 12-13272. Do not set z-index if IE, otherwise maximo dialogs will be
				// hidden
				if (dojo.isIE && (this.map.isMobile == true))
				{
					dojo.style(this.mapDivElement, {
						'width': dijit.getViewport().w + "px",
						'height': (dijit.getViewport().h - toolbarHeight) + "px",
						'top': _top,
						'left': _left + "px",
						'position': 'absolute'
					});
				}
				else
				{
					var newStyle = {
						'width': _width,
						'height': (dijit.getViewport().h - toolbarHeight) + "px",
						'top': _top,
						'position': 'fixed',
						'zIndex': '1001'
					};
					newStyle[_spacingKey] = _spacing + "px";

					dojo.style(this.mapDivElement, newStyle);
				}
			},
			_hideElementsHackOn: function()
			{
				if (this._isAndroid || dojo.isIE)
				{
					// Issue 12-11443
					// Remove the map from the DOM so it doesn't get hidden by the
					// workaround
					this.mapParent = this._removeMapFromParent();
					// Hide all elements in the page that will be behind the map
					this._hidePageElements();
					// Re-add the map to the page
					this._addMapToParent(document.body);
				}
			},
			_hideElementsHackOff: function()
			{
				if (this._isAndroid || dojo.isIE)
				{
					// Issue 12-11443
					// Remove the map from the root node and add it back to its parent
					this._removeMapFromParent();
					this._addMapToParent(this.mapParent);
					// Return all nodes to their previous visibility
					this._showPageElements();
				}
				// Defect 95984: Looks like IE10 has issues when we call window.onresize()
				// so, in order to avoid breaking a previously fixed defect, only allow
				// the execution of window.onresize() for IE versions earlier than 10.
				if (dojo.isIE && (dojo.isIE < 10))
				{
					// After restoring, IE left most of the screen blank. This nudges
					// it to redraw and fixes the problem.
					window.onresize();
				}
			},
			_removeMapFromParent: function()
			{
				var _parent = this.mapDivElement.parentNode;
				_parent.removeChild(this.mapDivElement);
				if (this.mapToolbar)
				{
					_parent.removeChild(this.mapToolbar.getToolbarDivElement());
				}

				return _parent;
			},
			_addMapToParent: function(parent)
			{
				if (this.mapToolbar)
				{
					parent.appendChild(this.mapToolbar.getToolbarDivElement());
				}
				parent.appendChild(this.mapDivElement);
			},
			_hidePageElements: function()
			{
				// Exclude the dialogs HTML from hiding or they won't work
				var dialogholder = dojo.byId("dialogholder");
				var dialogs = dojo.query(".dijitDialog");
				// 12-13323. Adding the wait div to the exclude list.
				var waitDiv = dojo.byId("wait");
				var excludes = [ dialogholder, waitDiv ].concat(dialogs);
				dojo.query("body *").forEach(function(node, index, arr)
				{
					if (node.style
					// Also exclude all the descendants of excluded divs
					&& !dojo.some(excludes, function(parent)
					{
						return dojo.dom.isDescendant(node, parent);
					}))
					{
						node._fwm_display_ = node.style.display;
						node.style.display = "none";
					}
				});
			},
			_showPageElements: function()
			{
				dojo.query("body *").forEach(function(node, index, arr)
				{
					if (node.style && "_fwm_display_" in node)
					{
						node.style.display = node._fwm_display_;
					}
				});
			},
			_adjustOpacity: function()
			{
				// maximo contains opacity from 0 to 100 in increments of 5
				for ( var counter = 0; counter < 100; counter += 5)
				{
					dojo.query(".opacity_" + counter).style("opacity", "1.0");
				}
			},
			_restoreOpacity: function()
			{
				// maximo contains opacity from 0 to 100 in increments of 5
				for ( var counter = 0; counter < 100; counter += 5)
				{
					dojo.query(".opacity_" + counter).style("opacity", "." + counter);
				}
			},
			_adjustScrolls: function()
			{
				// Store the overflow state we have to restore later.
				// IE had issues, so have to check that it's defined. Ugh.
				var body = dojo.body();
				if (body.style && body.style.overflow)
				{
					this._oldOverflow = dojo.style(body, "overflow");
				}
				else
				{
					this._oldOverflow = "";
				}
				if (dojo.isIE)
				{
					// IE will put scrollbars in anyway, html (parent of body)
					// also controls them in standards mode, so we have to
					// remove them, argh.
					if (body.parentNode && body.parentNode.style && body.parentNode.style.overflow)
					{
						this._oldBodyParentOverflow = body.parentNode.style.overflow;
					}
					else
					{
						try
						{
							this._oldBodyParentOverflow = dojo.style(body.parentNode, "overflow");
						}
						catch (e)
						{
							this._oldBodyParentOverflow = "scroll";
						}
					}
					dojo.style(body.parentNode, "overflow", "hidden");
				}
				dojo.style(body, "overflow", "hidden");
				// 12-12456. Intercepts the scroll event and forces a scroll to the top
				// This is necessary because of the middle mouse button scroll (it can't
				// be disabled in FF)
				this._origOnScrollFunction = window.onscroll;
				window.onscroll = function(e)
				{
					window.top.scrollTo(0, 0);
				};
			},
			_restoreScrolls: function()
			{
				var body = dojo.body();
				if (dojo.isIE && !dojo.isQuirks)
				{
					body.parentNode.style.overflow = this._oldBodyParentOverflow;
				}
				dojo.style(body, "overflow", this._oldOverflow);
				// Restores the onscroll handler
				window.onscroll = this._origOnScrollFunction;
			},
			_setViewPortSettings: function()
			{
				// configure viewport settings to no allow users to scale the screen
				var viewPortMeta = dojo.query('meta[name="viewport"]')[0];
				if (viewPortMeta)
				{
					this._origViewPortContent = dojo.attr(viewPortMeta, "content");
					// 12-13165. Removing maximum-scale=1.0. For some reason, even after
					// restoring viewport settings
					// the maximum-scale property was persisting...
					if (this._isAndroid)
					{
						//console.log("[_setViewPortSettings] Viewport before null = " + dijit.getViewport().w + "," + dijit.getViewport().h);
						dojo.attr(viewPortMeta, "content", null);
						//console.log("[_setViewPortSettings] Viewport after null = " + dijit.getViewport().w + "," + dijit.getViewport().h);
						dojo.attr(viewPortMeta, "content", "initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no,width=device-width");
						//console.log("[_setViewPortSettings] Viewport after device-width= " + dijit.getViewport().w + "," + dijit.getViewport().h);
					}
					else
					{
						dojo.attr(viewPortMeta, "content", "initial-scale=1.0,user-scalable=no,width=device-width");
					}
				}
				else
				{
					var meta = dojo.create("meta", {
						name: "viewport",
						content: "initial-scale=1.0, user-scalable=no"
					});
					/* 12-11086 */
					this._origViewPortContent = dojo.create("meta", {
						name: "viewport",
						content: "initial-scale=1.0, user-scalable=yes"
					});
					document.getElementsByTagName("head")[0].appendChild(meta);
				}
			},
			_removeViewPortSettings: function()
			{
				var viewPortMeta = dojo.query('meta[name="viewport"]')[0];
				if (viewPortMeta)
				{
					// The statement below is necessary because of issue 12-13165. It's a
					// workaround for an Android bug.
					dojo.attr(viewPortMeta, "content", null);
					dojo.attr(viewPortMeta, "content", this._origViewPortContent);
				}
			},
			fullScreenModeOff: function()
			{
				if (this._fullScreenOn == true)
				{
					if (this.tabGroupShell.length) {
						this.tabGroupShell.style('display', 'flex');
					}
					this._hideElementsHackOff();

					this._undoPreSetupIfIE();
					this._restoreMapToOriginalSize();
					this._restoreScrolls();
					/* 12-10287 */
					this._restoreOpacity();
					this._fullScreenOn = false;
					if (this._keyHandler)
					{
						dojo.disconnect(this._keyHandler);
						this._keyHandler = null;
					}
					/* 12-11086: changed user-scalable to yes */
					this._removeViewPortSettings();

					// need to notify the map of the changes in div size
					this.map._resize();
					dojo.publish("mapFullScreenModeChanged_" + this.map.getId(), [ {
						modeOn: false
					} ]);
				}
				else
				{
					if (dojo.config.fwm.debug == true)
					{
						console.warn("[MapFullScreenHelper] Full Screen is already off");
					}
				}
			},
			_restoreMapToOriginalSize: function()
			{
				dojo.style(this.mapDivElement, {
					'width': this.mapDivWidth,
					'height': this.mapDivHeight,
					'position': 'relative',
					'zIndex': '',
					'right': '',
					'left': '',
					'top': ''
				});
				if (this.mapToolbar)
				{
					var divElement = this.mapToolbar.getToolbarDivElement();
					dojo.style(divElement, {
						'width': this.mapDivWidth,
						'position': 'relative',
						'zIndex': '',
						'right': '',
						'left': '',
						'top': ''
					});
				}
			},
			updateMapDimensions: function(newWidth, newHeight)
			{
				this.mapDivWidth = newWidth;
				this.mapDivHeight = newHeight;

				// 12-10601
				if (this._fullScreenOn == true)
				{
					this._doPreSetupIfIE(false);
					//console.log("[MapFullScreenHelper] updateMapDimensions");
					this._adjustMapToFullScreen();
				}
			}
	});
})

},
'ibm/tivoli/fwm/mxmap/routing/impl/gmaps':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Base,ibm/tivoli/fwm/mxmap/routing/Router,ibm/tivoli/fwm/mxmap/routing/Route"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.routing.impl.gmaps");
dojo.require("ibm.tivoli.fwm.mxmap._Base");
dojo.require("ibm.tivoli.fwm.mxmap.routing.Router");
dojo.require("ibm.tivoli.fwm.mxmap.routing.Route");
/**
 * Google maps routing implementation.
 */
dojo.declare("ibm.tivoli.fwm.mxmap.routing.impl.gmaps", [ ibm.tivoli.fwm.mxmap.routing.Router, ibm.tivoli.fwm.mxmap._Base ], {
	directionsService: null,
	_routeLimits: 25,// how many stops the routing service allows
	_routeRequestIntervalInMiliseconds: 300, // This interval is intended to get past 
											 // google's request rate limit (https://developers.google.com/maps/documentation/business/faq#places_limits)
	// markers images url prefix
	_markerHost: "http://maps.gstatic.com/mapfiles/markers2/",
	// Parallel requests are enabled as long as google does not start validating
	// request rate limits. If it does, change this variable to false and select the 
	// propper value for _routeRequestIntervalInMiliseconds
	_allowParallelRouteCreation: true,
	constructor: function(params)
	{
		console.log("[Gmaps Router]", params);
		this._routeQueueParallel = [];
		dojo.mixin(this, params);

		this.directionsService = new google.maps.DirectionsService();

		if (this.map.mapConf.key == null || this.map.mapConf.key.length == 0)
		{
			// no premier map
			this._routeLimits = 10;
		}
		var gmapsConfig = this.map.mapConf.GMAPS;
		if(gmapsConfig && (gmapsConfig.routeRequestInterval > 0))
		{
			this._allowParallelRouteCreation = false;
			this._routeRequestIntervalInMiliseconds = gmapsConfig.routeRequestInterval;
		}
		console.log("[Gmaps Router] _routeLimits: ", this._routeLimits);

	},
	/*
	 * Return all the vertices coordinates of the route path
	 */
	_getPathCoords: function(r)
	{
		var coords = [];

		for (var k in r.overview_path)
		{
			var p = r.overview_path[k];
			var mxnll = this.map.pointFromProprietary(p);
			coords.push(mxnll);
		}

		return coords;
	},
	/**
	 * 
	 * @param route
	 * @param addmarkers
	 * @param map
	 * @returns { distance: total distance of this route duration: total
	 *          duration in seconds of this route marker: all the markers for
	 *          each stop of this route }
	 */
	_iterateOverLegs: function(route, addmarkers, map)
	{
		var routingData = {
			distance: 0,
			duration: 0,
			legData: [],
			markers: [],
			stops: [],
			polyline: []
		};
		var lastPoint = null;
		var lastAddress = "";

		for (var k = 0; k < route.legs.length; k++)
		{
			var leg = route.legs[k];
			routingData.distance += leg.distance.value;
			routingData.duration += leg.duration.value;
			var stepsInfo = this._getStepsData(leg.steps);
			var steps = stepsInfo.stepData;
			var startpt = this.map.pointFromProprietary(leg.start_location);
			var ep = this.map.pointFromProprietary(leg.end_location);
			routingData.legData.push({
				distance: leg.distance.value,
				duration: leg.duration.value,
				startAddress: leg.start_address,
				endAddress: leg.end_address,
				endLatLng: ep,
				startLatLng: startpt,
				steps: steps
			});
			routingData.polyline = routingData.polyline.concat(stepsInfo.polyStops);

			routingData.stops.push(startpt);

			lastPoint = leg.end_location;
			lastAddress = leg.end_address;

		}

		var lastpt = this.map.pointFromProprietary(lastPoint);
		routingData.stops.push(lastpt);

		return routingData;
	},
	_getStepsData: function(steps)
	{
		var data = [];
		var polyStops = [];
		if (steps)
		{
			for (var index = 0; index < steps.length; index++)
			{
				var step = steps[index];
				var distance = step.distance.value;

				var loc = this.map.pointFromProprietary(step.start_location);
				distance /= 1000;// google returns in meters, we need in km

				data.push({
					distance: distance,
					duration: step.duration.value,
					info: step.instructions,
					location: loc
				});
				polyStops = polyStops.concat(step.path);
			}
		}
		return {
			stepData: data,
			polyStops: polyStops
		};
	},

	/**
	 * allows to create more than 25 stops route in gmaps. It handles the return
	 * of each 25 stops route requests and and merge them. And returns in teh
	 * call back the routing data:
	 * 
	 * distance: 0, duration: 0, polyline: null, waypoints: [], markers: [],
	 * copyrights:
	 * 
	 */
	ccs: [ "#ff0000", "#00ff00", "#ffffff" ],
	co: 0,
	_multipleRouteSuccess: function(routesResponses, callback, errCb, initialStops, instanceConf)
	{

		var map = this.map.getProviderMap();
		var routingData = {
			totalDistance: 0,
			totalDuration: 0,
			legsData: [],
			polyline: null,
			stops: [],
			copyrights: null
		};

		var plineCoords = [];
		if(routesResponses && (routesResponses.length > 0))
		{
			for (var index = 0; index < routesResponses.length; index++)
			{
				var r = routesResponses[index].routes[0];

				if (routingData.copyrights == null)
				{
					routingData.copyrights = r.copyrights;
				}
				else
				{
					routingData.copyrights += ", " + r.copyrights;
				}

				var rd = this._iterateOverLegs(r, true, map);

				for (var k = 0; k < rd.polyline.length; k++)
				{
					var p = rd.polyline[k];
					var mxnll = this.map.pointFromProprietary(p);
					plineCoords.push(mxnll);
				}

				routingData.totalDistance += rd.distance;
				routingData.totalDuration += rd.duration;

				routingData.legsData = routingData.legsData.concat(rd.legData);
				var rstops = rd.stops;
				if (routesResponses[index].overlapPrevious == true)
				{
					rstops = rstops.slice(1, rstops.length);
				}
				routingData.stops = routingData.stops.concat(rstops);
				// routingData.markers = routingData.markers.concat(rd.markers);
			}
		}
		else
		{
			for (var i = 0; i < initialStops.length; i++)
			{
				routingData.stops.push(this.map.pointFromProprietary(this.__convertMboToGmapsLatLng(initialStops[i])));
			}
		}

		// Now there is only one instance of this class so the routecolor
		// that was passed to the constructor is not good anymore
		// Each route can have a different color
		if (instanceConf != null && instanceConf.routecolor)
		{
			this.routecolor = instanceConf.routecolor;
		}

		var polylineParams = 
		{
			points: plineCoords,
			color: this.routecolor,
			opacity: this.routeOpacity,
			width: this.routeLineWidth
		};
		var poly = this.map.polyline(polylineParams);

		if (dojo.config.fwm.debug == true)
		{
			console.log("points poly", plineCoords.length);
			console.log("poly color", poly.color);
		}

		routingData.polyline = poly;

		routingData.map = this.map;

		var customFct = function(_markerHost)
		{
			this._markerHost = _markerHost;
			this._counter = 0;
			this.getNext = function()
			{
				// this.wp.text=this._generateMarkerText();
				return {
					icon: this._generateMarkerImageUrl(),
					size: [ 20, 34 ],
					anchor: [ 10, 34 ]
				};
			};
			this._generateMarkerImageUrl = function()
			{

				var color = "_green";
				var offset = (this._counter % 26);

				var digit = String.fromCharCode(65 + offset);
				if (dojo.config.fwm.debug == true)
				{
					console.log("custommarker", this._counter, digit);
				}
				this._counter++;

				return this._markerHost + "marker" + color + digit + ".png";
			};
		};

		routingData.customMarkerOptions = new customFct(this._markerHost);

		// maybe moved to the route.
		var itinerary = new ibm.tivoli.fwm.mxmap.routing.itinerary.Itinerary();
		var mustGeocode = false;
		if (initialStops[0].calculatedStop == true)
		{
			mustGeocode = true;
		}
		if (routingData.legsData && routingData.legsData.length > 0)
		{
			itinerary.setInitialLocation(routingData.legsData[0].startAddress, routingData.legsData[0].startLatLng, null, null, mustGeocode);

			for (var index = 0; index < routingData.legsData.length; index++)
			{
				var loc = routingData.legsData[index].endLatLng;
				var info = routingData.legsData[index].endAddress;
				var distanceToLeg = routingData.legsData[index].distance;
				var durationToLeg = routingData.legsData[index].duration / 60;/*
																				 * supposed
																				 * to
																				 * be
																				 * in
																				 * minutes
																				 */
				var steps = routingData.legsData[index].steps;

				distanceToLeg /= 1000;/*
										 * google returns in meters, we need in
										 * km
										 */

				itinerary.addLeg(loc, info, distanceToLeg, durationToLeg, null, steps, null, null);
			}

			// check if last stop was calculated we must force geocode
			if (initialStops[initialStops.length - 1].calculatedStop == true)
			{
				itinerary.legs[itinerary.legs.length - 1].needsToGeocode = true;
			}
		}
		routingData.itinerary = itinerary;
		routingData.inputInfo = {
			stops: initialStops,
			successCb: callback,
			errorCb: errCb
		};
		routingData.originalRouter = this;
		routingData.distanceUnit = this.getCurrentDistanceUnit();
		var routeInfo = new ibm.tivoli.fwm.mxmap.routing.Route(routingData);

		if (callback)
		{
			callback(routeInfo);
		}
	},

	distanceUnit: null,
	/**
	 * Executes the routing on gmaps provider.
	 * 
	 * @see Router.js#showRoute
	 */
	_routeQueueParalel: null,
	// In order to avoid reaching google's request rate limit
	// we do not allow showRoute to make requests to google maps when it is called
	// from outside of this class, because this happens in a for loop.
	// Instead, we buffer all the calls so that they can be fired in a more
	// controlled fashion (timed calls).
	showRoute: function(stops, callback, errCb, a, instanceConf, internalRequest)
	{
		
		if(this._allowParallelRouteCreation == false)
		{
			if (internalRequest != true)
			{
				this._routeQueueParallel.push({
					stops: stops,
					callback: callback,
					errCb: errCb,
					instanceConf: instanceConf
				});
				if(this._routeQueueParallel.length == 1)
				{
					this.executeQueuedParallel();
				}
				return;
			}
		}
		
		this._counter = 0;
		console.log("stops", {
			stops: stops
		});
		var offset = 0;
		var completedOnes = 0;
		var routes = [];
		var th = this._startTimer();
		this.distanceUnit = google.maps.UnitSystem.IMPERIAL;
		if (this.getCurrentDistanceUnit() == ibm.tivoli.fwm.mxmap.routing.DistanceUnit.KM)
		{
			this.distanceUnit = google.maps.UnitSystem.METRIC;
		}
		var start = 0;
		var overlap = false;
		var complFct = function(response)
		{
			if(response)
			{
				response.overlapPrevious = overlap;
				overlap = false;
				routes.push(response);
				if (dojo.config.fwm.debug == true)
				{
					console.log("total", offset, stops.length);
				}
				if (offset < stops.length)
				{
					start = offset;
					offset += this._routeLimits;
					if (offset >= stops.length)
					{
						offset = stops.length;
					}
					/**
					 * we need to connect route n with route n-1. Suppose we have
					 * limit of 2 stops and we got 3 stops, then we route 1 to 2 and
					 * 2 to 3.
					 */
					if (start > 0)
					{
						console.log("Using last stop from previous request", start, offset, (offset - start));
						start--;
						if ((offset - start) >= this._routeLimits)
						{
							offset--;
						}
						overlap = true;

					}
					var subStopsSet = stops.slice(start, offset);
					if (dojo.config.fwm.debug == true)
					{
						console.log("start", start, "end", offset, subStopsSet.length, subStopsSet[0], subStopsSet[subStopsSet.length - 1]);
					}
					this._calculateRoute(subStopsSet, dojo.hitch(this, complFct), errCb);
				}
				else
				{
					this._multipleRouteSuccess(routes, callback, errCb, stops, instanceConf);
					this._stopTimer(null, stops.length);
				}
				// }
			}
			else
			{
				// If response is null, it means that the route could not be generated
				// but we want at least the markers to be drawn.
				routes = [];
				this._multipleRouteSuccess(routes, callback, errCb, stops, instanceConf);
				this._stopTimer(null, stops.length);
			}
		};

		offset += this._routeLimits;

		if (offset >= stops.length)
		{
			offset = stops.length;
		}
		th = this._startTimer();
		if (dojo.config.fwm.debug == true)
		{
			console.log("start", start, "end", offset, stops.slice(start, offset).length);
		}
		this._calculateRoute(stops.slice(start, offset), dojo.hitch(this, complFct), errCb);

	},
	__convertMboToGmapsLatLng: function(mboInfo)
	{
		var latLng = null;
		// Using the MXRecord wrapper to handle mboInfo's properties
		var mxRec = new ibm.tivoli.fwm.mxmap.MXRecord({
			mboInfo: mboInfo,
			map: this.map
		});

		if (mxRec.hasGISData())
		{
			// The first thing is to check if LBS data needs to be used
			// otherwise, go with the existing autolocate fall through logic
			if(mxRec.useLBSData())
			{
				if(mxRec.hasPointInCurrentSR())
				{
					latLng = new google.maps.LatLng(parseFloat(mxRec.getPointInCurrentSRLat()), parseFloat(mxRec.getPointInCurrentSRLng()));
				}
				else
				{
					latLng = new google.maps.LatLng(parseFloat(mxRec.getLBSLat()), parseFloat(mxRec.getLBSLng()));
				}
			}
			else if (mxRec.hasGISCoordinates())
			{
				latLng = new google.maps.LatLng(parseFloat(mxRec.getGISLat()), parseFloat(mxRec.getGISLng()));
			}
			else if (mxRec.hasAutolocateGISOnlyCoordinates())
			{
				latLng = new google.maps.LatLng(parseFloat(mxRec.getAutolocateGISLat()), parseFloat(mxRec.getAutolocateGISLng()));
			}
			else if (mxRec.hasOwnLatLngProperties())
			{
				latLng = new google.maps.LatLng(parseFloat(mxRec.getOwnLat()), parseFloat(mxRec.getOwnLng()));
			}
			else
			{
				console.warn("Stop doesn't have gis coords", mboInfo);
			}
		}
		else
		{
			latLng = new google.maps.LatLng(parseFloat(mxRec.getOwnLat()), parseFloat(mxRec.getOwnLng()));
		}
		return latLng;

	},
	/**
	 * calculates one route.
	 * 
	 * @param stops
	 * @param callback
	 * @param errCb
	 */
	_calculateRoute: function(stops, callback, errCb)
	{

		var start = this.__convertMboToGmapsLatLng(stops[0]);

		var end = this.__convertMboToGmapsLatLng(stops[stops.length - 1]);

		var request = {
			origin: start,
			destination: end,
			travelMode: google.maps.TravelMode.DRIVING,
			unitSystem: google.maps.UnitSystem.METRIC,// always in km (meters
			// here)
			waypoints: []
		};

		request.avoidHighways = this.getAvoidHighways();
		request.avoidTolls = this.getAvoidTolls();

		for (var i = 1; i < stops.length - 1; i++)
		{
			var stop = stops[i];

			var ll = this.__convertMboToGmapsLatLng(stop);// new
			// google.maps.LatLng(parseFloat(stop.lat),
			// parseFloat(stop.lng));
			
			if((ll != null) && (ll != undefined))
			{
				var wp = {
						location: ll,
						stopover: true
					};
					request.waypoints.push(wp);
			}
		}
		if (this.isOptimizeRoute())
		{
			request.optimizeWaypoints = true;// NOT sure what
			// to do with
			// this since
			// gmaps only
			// suppot 10 orr
			// 25 stops
		}
		if (dojo.config.fwm.debug == true)
		{
			console.log("Route request", request);
		}
		var th = this._startTimer();
		var me = this;
		this.directionsService.route(request, function(response, status)
		{
			if (dojo.config.fwm.debug == true)
			{
				console.log("status", status);
				console.log("response", response);
			}
			me._stopTimer(th, stops.length);

			/**
			 * Google's status codes (the ones with & are supported by our api): &
			 * OK indicates the response contains a valid result. NOT_FOUND
			 * indicates at least one of the locations specified in the
			 * requests's origin, destination, or waypoints could not be
			 * geocoded. & ZERO_RESULTS indicates no route could be found
			 * between the origin and destination. MAX_WAYPOINTS_EXCEEDED
			 * indicates that too many waypoints were provided in the request
			 * The maximum allowed waypoints is 8, plus the origin, and
			 * destination. ( Google Maps API for Business customers may contain
			 * requests with up to 23 waypoints.) INVALID_REQUEST indicates that
			 * the provided request was invalid. & OVER_QUERY_LIMIT indicates
			 * the service has received too many requests from your application
			 * within the allowed time period. & REQUEST_DENIED indicates that
			 * the service denied use of the directions service by your
			 * application. & UNKNOWN_ERROR indicates a directions request could
			 * not be processed due to a server error. The request may succeed
			 * if you try again.
			 */
			if (status == google.maps.DirectionsStatus.OK)
			{
				if (callback)
				{
					callback(response);
				}
			}
			else
			{
				// Check whether the markers should be drawn even when the provider fails to generate a route
				if(this.map && this.map.getShowMarkersOnRouteError() == true)
				{
					if (callback)
					{
						callback(null);
					}
				}
				else
				{
					if (errCb)
					{
						switch (status)
						{
							case google.maps.DirectionsStatus.ZERO_RESULTS:
								errCb(ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.ZERO_RESULTS, status);
								break;
							case google.maps.DirectionsStatus.OVER_QUERY_LIMIT:
								errCb(ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.OVER_LIMIT, status);
								break;
							case google.maps.DirectionsStatus.REQUEST_DENIED:
								errCb(ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.REQUEST_DENIED, status);
								break;
							default:
								errCb(ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.UNKNOWN_ERROR, status);
								break;
						}
					}
				}
			}
		});
	},
	executeQueuedParallel: function()
	{
		var me = this;
		if (this._routeQueueParallel.length > 0)
		{
			setTimeout(function(){
				var obj = me._routeQueueParallel.pop();
				me.showRoute(obj.stops, obj.callback, obj.errCb, null, obj.instanceConf, true);
				me.executeQueuedParallel();
			}, me._routeRequestIntervalInMiliseconds);
		}
	}

});

});

},
'dijit/MenuItem':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/sniff", // has("ie")
	"dojo/_base/lang", // lang.hitch
	"./_Widget",
	"./_TemplatedMixin",
	"./_Contained",
	"./_CssStateMixin",
	"dojo/text!./templates/MenuItem.html"
], function(declare, dom, domAttr, domClass, kernel, has, lang,
			_Widget, _TemplatedMixin, _Contained, _CssStateMixin, template){

	// module:
	//		dijit/MenuItem

	var MenuItem = declare("dijit.MenuItem" + (has("dojo-bidi") ? "_NoBidi" : ""),
		[_Widget, _TemplatedMixin, _Contained, _CssStateMixin], {
		// summary:
		//		A line item in a Menu Widget

		// Make 3 columns
		// icon, label, and expand arrow (BiDi-dependent) indicating sub-menu
		templateString: template,

		baseClass: "dijitMenuItem",

		// label: String
		//		Menu text as HTML
		label: "",
		_setLabelAttr: function(val){
			this._set("label", val);
			var shortcutKey = "";
			var text;
			var ndx = val.search(/{\S}/);
			if(ndx >= 0){
				shortcutKey = val.charAt(ndx + 1);
				var prefix = val.substr(0, ndx);
				var suffix = val.substr(ndx + 3);
				text = prefix + shortcutKey + suffix;
				val = prefix + '<span class="dijitMenuItemShortcutKey">' + shortcutKey + '</span>' + suffix;
			}else{
				text = val;
			}
			this.domNode.setAttribute("aria-label", text + " " + this.accelKey);
			this.containerNode.innerHTML = val;
			this._set('shortcutKey', shortcutKey);
		},

		/*=====
		// shortcutKey: [readonly] String
		//		Single character (underlined when the parent Menu is focused) used to navigate directly to this widget,
		//		also known as [a mnemonic](http://en.wikipedia.org/wiki/Mnemonics_(keyboard%29).
		//		This is denoted in the label by surrounding the single character with {}.
		//		For example, if label="{F}ile", then shortcutKey="F".
		shortcutKey: "",
		=====*/

		// iconClass: String
		//		Class to apply to DOMNode to make it display an icon.
		iconClass: "dijitNoIcon",
		_setIconClassAttr: { node: "iconNode", type: "class" },

		// accelKey: String
		//		Text for the accelerator (shortcut) key combination, a control, alt, etc. modified keystroke meant to
		//		execute the menu item regardless of where the focus is on the page.
		//
		//		Note that although Menu can display accelerator keys, there is no infrastructure to actually catch and
		//		execute those accelerators.
		accelKey: "",

		// disabled: Boolean
		//		If true, the menu item is disabled.
		//		If false, the menu item is enabled.
		disabled: false,

		_fillContent: function(/*DomNode*/ source){
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			if(source && !("label" in this.params)){
				this._set('label', source.innerHTML);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			var label = this.id + "_text";
			domAttr.set(this.containerNode, "id", label); // only needed for backward compat
			if(this.accelKeyNode){
				domAttr.set(this.accelKeyNode, "id", this.id + "_accel"); // only needed for backward compat
			}
			dom.setSelectable(this.domNode, false);
		},

		onClick: function(/*Event*/){
			// summary:
			//		User defined function to handle clicks
			// tags:
			//		callback
		},

		focus: function(){
			// summary:
			//		Focus on this MenuItem
			try{
				if(has("ie") == 8){
					// needed for IE8 which won't scroll TR tags into view on focus yet calling scrollIntoView creates flicker (#10275)
					this.containerNode.focus();
				}
				this.focusNode.focus();
			}catch(e){
				// this throws on IE (at least) in some scenarios
			}
		},

		_setSelected: function(selected){
			// summary:
			//		Indicate that this node is the currently selected one
			// tags:
			//		private

			domClass.toggle(this.domNode, "dijitMenuItemSelected", selected);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.   Use set('label', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
			this.set("label", content);
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use set('disabled', bool) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.Menu.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
			this.set('disabled', disabled);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// summary:
			//		Hook for attr('disabled', ...) to work.
			//		Enable or disable this menu item.

			this.focusNode.setAttribute('aria-disabled', value ? 'true' : 'false');
			this._set("disabled", value);
		},

		_setAccelKeyAttr: function(/*String*/ value){
			// summary:
			//		Hook for attr('accelKey', ...) to work.
			//		Set accelKey on this menu item.

			if(this.accelKeyNode){
				this.accelKeyNode.style.display = value ? "" : "none";
				this.accelKeyNode.innerHTML = value;
				//have to use colSpan to make it work in IE
				domAttr.set(this.containerNode, 'colSpan', value ? "1" : "2");
			}
			this._set("accelKey", value);
		}
	});

	if(has("dojo-bidi")){
		MenuItem = declare("dijit.MenuItem", MenuItem, {
			_setLabelAttr: function(val){
				this.inherited(arguments);
				if(this.textDir === "auto"){
					this.applyTextDir(this.textDirNode);
				}
			}
		});
	}

	return MenuItem;
});

},
'ibm/tivoli/fwm/mxmap/panels/MobileInfoPanelDialog':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/_base/declare",
	"dojo/main", "dijit/main",
	"dijit/Dialog",
	"dijit/form/Button"],
	function(declare, dojo, dijit, Dialog, Button, MobileInfoPanelDialog, i18n  ) {


	return declare(null, {
		map: null,
		title: null,
		_theDialog: null,
		_content: null,
		mainSec: null,
		undercontent: null,
		fitHeight: false,
		constructor: function(options)
		{
			dojo.mixin(this, options);
		},
		createDialog: function()
		{
			var height = this.getCalculatedHeight();
			var width = this.getCalculatedWidth();

			var title = this.title || "";

			var dialogOpts = {
					title: title,
					// 12-12908. Dijit.Dialog has a bug in which the title bar's "x" close button does not
					// work in mobile devices if draggable is set to true.
					draggable: this.map.isMobile ? false:true,
							closable: false,
							style: "width: " + (width) + "px; max-height: " + (height) + "px; overflow-y: auto;"
			};

			// Make the dialog non-modal only in non-mobile browsers
			if (this.nonModal && !this.map.isMobile)
			{
				dialogOpts['class'] = 'nonModal';
			}			

			this._theDialog = new Dialog(dialogOpts);
			this._cancelHandler=dojo.connect(this._theDialog,"onCancel",dojo.hitch(this,this._resetMaximoDialogStates));

			dojo.connect(window, "onresize", this, this._onResize);
		},
		full: null,
		center: null,
		bottom: null,
		_createContentSection: function(content)
		{
			if (this.center != null && false)
			{
				dojo.place(content, this.center, 'first');
				return this.full;
			}
			else
			{

				var _content = dojo.create("div", {
					style: {
						width: (this.getCalculatedWidth() - this.fixedpaddingw) + "px"
					}
				});
				this.full = _content;
				var mainSec = dojo.create("div", {
					style: {
						overflowY: "auto",
						overflowX: "auto",
						maxHeight: (this.getCalculatedHeight() - this.fixedpaddingh) + "px",
						width: (this.getCalculatedWidth() - this.fixedpaddingw) + "px"
					}
				}, _content);
				// 12-12821. IE ignores the "max-height" attribute so
				// "height" must be used instead.
				if (dojo.isIE && this.fitHeight)
				{
					mainSec.style.height = (this.getCalculatedHeight() - this.fixedpaddingh) + "px";
				}
				this.center = mainSec;
				dojo.place(content, mainSec, 'only');

				var btnDiv = dojo.create("div", {
					"mxnId": "btnDiv",
					"class": "infoPanelCloseBtn",
					"style": {
						"textAlign": (document.body.dir == "rtl") ? "left" : "right"
					}
				}, _content);
				this.btnDiv = btnDiv;

				// Add custom buttons (if any) to the left side of the close button
				if(this.customButtons && (this.customButtons.length > 0))
				{ 
					for(var i = 0; i < this.customButtons.length; i++)
					{
						var customBtnDiv = dojo.create("div" + i, {}, btnDiv);
						new dijit.form.Button(
								{
									label: this.customButtons[i].label,
									onClick: this.customButtons[i].onClick
								}, customBtnDiv
						);
					}
				}

				var btn2 = dojo.create("div", {
					"mxnId": "btn"
				}, btnDiv);

				var _closeButtonLabel = ibm.tivoli.fwm.i18n.getMaxMsg("map", "infopaneldialogclose");
				this.closeBtn = new Button({
					label: _closeButtonLabel,
					onClick: dojo.hitch(this, function()
							{					
						this.close();
							})
				}, btn2);

				return _content;
			}

		},
		_myFct: function()
		{

		},
		setContent: function(content)
		{
			// Issue 12-11310. The dialog needs to be created every time because the
			// browser window may have
			// been resized since the last time that setContent was called.
			// if (this._theDialog == null)
			// {
			this.createDialog();
			// }
			// console.log("CALLED
			// setContent",this._createContentSections(content));
			this._theDialog._myFct = function()
			{

			};
			this._theDialog.set("content", this._createContentSection(content));

		},
		_onResize: function()
		{
			if (this._theDialog && this._theDialog.get("open"))
			{
				this._recalculateDimensions();
			}
		},
		_recalculateDimensions: function()
		{
			var width = this.getCalculatedWidth();

			if (this.fitHeight)
			{
				var height = this.getCalculatedHeight();
				this._theDialog.resize({w: width, h: height});
				this.center.style.height = (height - this.fixedpaddingh) + "px";
			}
			else
			{
				this._theDialog.resize({w: width});
			}
			this.center.style.width = (width - this.fixedpaddingw) + "px";
			this.btnDiv.style.width = (width - this.fixedpaddingw) + "px";

			this._theDialog.show();
		},
		getCalculatedWidth: function()
		{
			// 12-13416. Very ugly workaround to overcome the fact that there is no way
			// to handle a pinch zoom event in Android
			var isAndroid = navigator.userAgent.indexOf("Android") > -1;
			if(isAndroid)
			{
				this.map._resize();
			}

			var MIN_WIDTH = 310;
			var viewPortWidth = this.map.getWidthInPixels();

			if (this.map.isMobile)
			{
				var width = Math.ceil(viewPortWidth * 0.4);
			}
			else
			{
				var width = Math.ceil(viewPortWidth * 0.5);
			}

			if (width > MIN_WIDTH)
			{
				return width;
			}
			// 12-13416. Never let the dialog width be greater than the viewport width.
			if (MIN_WIDTH > viewPortWidth)
			{
				return viewPortWidth;
			}

			return MIN_WIDTH;
		},
		getCalculatedHeight: function()
		{
			// var height = this.map.getHeightInPixels(); //gets the wrong height in
			// fullscreenmode
			var mapHeight = Math.min(dojo.window.getBox().h,
					dojo.marginBox(this.map.getElement()).h);

			// Defect 61760. Minimum height defined for dialogs when the map height is too small
			// This does not apply to mobile maps (everyplace apps), otherwise the close buttons can be hidden in iDevices.
			var height = Math.ceil(mapHeight * 0.85);

			if (this.map.isMobile)
			{
				return height;
			}

			var MIN_HEIGHT = 400;
			if (height > MIN_HEIGHT)
			{
				return height;
			}

			return MIN_HEIGHT;
		},
		close: function()
		{
			if (this._theDialog)
			{
				// destroy on the dialog has a conflict with Maximo code.
				// removing all the descendants ease enough the nodes on the DOM
				// tree
				// this._theDialog.destroyDescendants(false);
				this._theDialog.hide();
				// this._theDialog = null;
				// this.closeBtn.destroyRecursive();
				// this.closeBtn = null;
				// maximo!
			}
			this._resetMaximoDialogStates();
		},
		_resetMaximoDialogStates:function(){
			if(dialogCount > 0)
			{
				dialogCount--;
			}
			showObjs();		
		},
		fixedpaddingw: 25,
		fixedpaddingh: 80,
		show: function()
		{
			this._recalculateDimensions();
			this._theDialog.show();
			// MAXIMO hide applets
			hideObjs();
			dialogCount++;
		},
		closeBtn: null,
		onCancel: function()
		{
			this.close();
		}
	});
});

},
'dijit/ToolbarSeparator':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"./_Widget",
	"./_TemplatedMixin"
], function(declare, dom, _Widget, _TemplatedMixin){

	// module:
	//		dijit/ToolbarSeparator


	return declare("dijit.ToolbarSeparator", [_Widget, _TemplatedMixin], {
		// summary:
		//		A spacer between two `dijit.Toolbar` items

		templateString: '<div class="dijitToolbarSeparator dijitInline" role="presentation"></div>',

		buildRendering: function(){
			this.inherited(arguments);
			dom.setSelectable(this.domNode, false);
		},

		isFocusable: function(){
			// summary:
			//		This widget isn't focusable, so pass along that fact.
			// tags:
			//		protected
			return false;
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/_MapProvider':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */


define([
	"dojo/_base/declare",
	"dojo/main",
	"dijit/main", "dojox/main",
	"dojo/topic",
	"ibm/tivoli/fwm/mxmap/_Base",
	"ibm/tivoli/fwm/mxmap/Radius",
	"ibm/tivoli/fwm/mxmap/_BoundingBox"
	],
	function (declare, dojo, dijit, dojox, topic, _Base, Radius,  _BoundingBox  ) {

	return declare([_Base], {
		WGS84WKID: 4326,
		Events: {
			click: 'click',
			rightclick: 'righclick',
			endPan: 'endPan',
			changeZoom: 'changeZoom',
			dragEnd: 'dragEnd',
			load: 'load'
		},
		MapType: {
			ROAD: 1,
			SATELLITE: 2,
			HYBRID: 3,
			PHYSICAL: 4
		},
		providerInitialized: false,
		/**
		 * The markers currently loaded.
		 */
		markers: [],

		/**
		 * The polylines currently loaded.
		 */
		polylines: [],

		map: null,

		element: null,

		init: function(element, options)
		{
			var me = this;
			this.providerInitialized = true;
			var def = new dojo.Deferred();
			if (this.mapConf.provider == "spatial") {
				this._init(element, options).then(function(){
					me.addSubscription("startedUserInteractionOnMap_" + me.compId, dojo.hitch(me, me.closeAllOtherMarkerInfoBubbles));
					def.callback(me);
				});
			} else {
				this._init(element, options);
				this.addSubscription("startedUserInteractionOnMap_" + me.compId, dojo.hitch(me, me.closeAllOtherMarkerInfoBubbles));
			}


			return def;
		},
		/* To be implemented by providers */
		_init: function(element, options)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},
		isProviderInitialized: function()
		{
			return this.providerInitialized;
		},
		destroyMap: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		isLoaded: function()
		{
			return this.loaded;
		},
		addOnload: function(fct)
		{
			this.addSubscription(this.Events.load + this.getId(), dojo.hitch(this, fct));
		},
		_loaded: function()
		{
			dojo.publish(this.Events.load + this.getId());
		},

		/* Returns the map's container DOM element. */
		getElement: function()
		{
			return this.element;
		},

		getProviderMap: function()
		{
			return this.map;
		},

		getMapType: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},
		setMapType: function(type)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		getCenter: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},
		setCenter: function(point, options)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		getZoom: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},
		setZoom: function(zoom)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		setCenterAndZoom: function(point, zoom)
		{
			this.setCenter(point);
			this.setZoom(zoom);
		},
		/* center and zoom over all markers on the map */
		autoCenterAndZoom: function(mboInfoArray)
		{
			// In spatial, there may be some delay between the markers being drawn
			// and the autoCenterAndZoom method being called, so if markers have not yet being drawn,
			// we wait some time and try again
			if((mboInfoArray != undefined) && (mboInfoArray.length > this.markers.length))
			{
				var me = this;
				setTimeout(function()
						{
					me.autoCenterAndZoom();
						},
						5000);
			}
			else
			{
				var atLeastOnePoint = false;
				//TODO Code copied from Mapstraction
				// var lat_max = -90;
				// var lat_min = 90;
				// var lon_max = -180;
				// var lon_min = 180;
				// limits changed due to x,y coordinates of ESRI
				var lat_max = -(2e32);
				var lat_min = (2e32);
				var lon_max = -(2e32);
				var lon_min = (2e32);

				var lat, lon;
				var checkMinMax = function()
				{
					if (lat > lat_max)
					{
						lat_max = lat;
					}
					if (lat < lat_min)
					{
						lat_min = lat;
					}
					if (lon > lon_max)
					{
						lon_max = lon;
					}
					if (lon < lon_min)
					{
						lon_min = lon;
					}
				};
				for ( var i = 0; i < this.markers.length; i++)
				{
					lat = this.markers[i].location.lat;
					lon = this.markers[i].location.lon;
					checkMinMax();
					atLeastOnePoint = true;
				}
				for (i = 0; i < this.polylines.length; i++)
				{
					for ( var j = 0; j < this.polylines[i].points.length; j++)
					{
						lat = this.polylines[i].points[j].lat;
						lon = this.polylines[i].points[j].lon;
						checkMinMax();
					}
					atLeastOnePoint = true;
				}
				if(atLeastOnePoint == true)
				{
					this.setBounds(new this.getBoundingBox(lat_min, lon_min, lat_max, lon_max));
				}
			}
		},

		getBounds: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},
		setBounds: function(bounds)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		getBoundingBox: function(swLat, swLng, neLat, neLng)
		{
			return new ibm.tivoli.fwm.mxmap._BoundingBox(swLat, swLng, neLat, neLng);
		},
		getBoundingBoxFromPoints: function(points)
		{
			var bounds = null;
			if(points && points.length > 0)
			{
				bounds = this.getBoundingBox(points[0].lat, points[0].lng, points[0].lat, points[0].lng);
				for ( var i = 1, len = points.length; i < len; i++)
				{
					bounds.extend(points[i]);
				}
			}
			return bounds;
		},

		getBoundingBoxFromSwAndNe: function(sw, ne)
		{
			var bounds = null;
			if(sw && ne)
			{
				bounds = this.getBoundingBox(sw.lat, sw.lng, ne.lat, ne.lng);
			}
			return bounds;
		},

		getAllPointsFromWGS84: function(points, callback, errCb)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},
		getAllPointsInWGS84: function(points, callback, errCb)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		resizeTo: function(width, height)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		addMarker: function(point, markerData)
		{
			// the placeMarker replaces the invoker from mapstraction
			var marker = this.createProviderMarker(point, markerData);

			this.markers.push(marker);

			return marker;
		},

		// Implemented by specific provider code
		createProviderMarker: function(params)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},


		removeMarker: function(marker)
		{
			var current_marker;
			for ( var i = 0; i < this.markers.length; i++)
			{
				current_marker = this.markers[i];
				if (marker == current_marker)
				{
					this.removeProviderMarker(marker);
					marker.onmap = false;
					this.markers.splice(i, 1);
					current_marker.destroyRecursive();
					break;
				}
			}
		},

		// Implemented by specific provider code
		removeProviderMarker: function(marker)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		removeAllMarkers: function()
		{
			var current_marker;
			while (this.markers.length > 0)
			{
				current_marker = this.markers.pop();
				this.removeProviderMarker(current_marker);
				current_marker.destroyRecursive();
			}
		},

		addPolyline: function(polyline, polylineData)
		{
			var propPoly = this.createProviderPolyline(polyline, polylineData);
			polyline.setChild(propPoly);
			this.polylines.push(polyline);
		},

		// Implemented by specific provider code
		createProviderPolyline: function(params)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		removePolyline: function(polyline)
		{
			var current_polyline;
			for ( var i = 0; i < this.polylines.length; i++)
			{
				current_polyline = this.polylines[i];
				if (polyline == current_polyline)
				{
					this.polylines.splice(i, 1);
					this.removeProviderPolyline(polyline);
					polyline.onmap = false;
					break;
				}
			}
		},

		// Implemented by specific provider code
		removeProviderPolyline: function(polyline)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		removeAllPolylines: function()
		{
			var current_polyline;
			while (this.polylines.length > 0)
			{
				current_polyline = this.polylines.pop();
				this.removeProviderPolyline(current_polyline);
				current_polyline.onmap = false;
			}
		},

		/* enables or disables the traffic layer */
		setShowTraffic: function(state)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		latLng: function(lat, lng, sr)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		polyline: function(points)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		// Looks like there is no specific implementation of Radius for the providers
		radius: function(center, quality)
		{
			var params = {center: center, quality: quality, map: this};
			return new Radius(params);
		},

		addMapEventHandler: function(event, handler)
		{
			this.addSubscription('mapProvider_' + event + '_' + this.getId(), handler);
		},
		removeMapEventHandler: function(event, handler)
		{
			this.removeSubscription('mapProvider_' + event + '_' + this.getId(), handler);
		},
		fireMapEvent: function(event, data)
		{
			dojo.publish('mapProvider_' + event + '_' + this.getId(), data);
		},

		pointToProprietary: function(point)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},
		pointFromProprietary: function(point)
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},


		geocode: function(callback, errorCallback, key, address)
		{
			this.providerGeocode(callback, errorCallback, key, address);
		},
		reverseGeocode: function(callback, errorCallback, key, lat, lng)
		{
			this.providerReverseGeocode(callback, errorCallback, key, lat, lng);
		},

		// Implemented by specific provider code
		providerGeocode: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},
		providerReverseGeocode: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},
		getMarkers: function()
		{
			return this.markers;
		},

		destroyRecursive: function()
		{
			if (this.markers)
			{
				this.removeAllMarkers();
				this.removeAllPolylines();
			}
			this.inherited(arguments)
		},

		stopEventPropagation: function (e)
		{
			if (!e) var e = window.event;

			e.cancelBubble = true;
			if (e.stopPropagation){
				e.stopPropagation();
			}
			if (e.stopEvent){
				e.stopEvent();
			}
			e.handled=true;
			if(e.originalEvent){
				e.originalEvent.cancelBubble=true;
				e.originalEvent.handled=true;
				stopBubble(e.originalEvent);
				cancelEvent(e.originalEvent);
				if (e.originalEvent.stopPropagation){
					e.originalEvent.stopPropagation();
				}
			}
		},
		// Whenever a maptip opens, check all other markers
		// and close their maptips if necessary (i.e. if they are showing)
		closeAllOtherMarkerInfoBubbles: function(e)
		{
			if(e.eventName == "openBubble")
			{
				var sourceMarker = e.objectSource;
				if((sourceMarker != null) && (sourceMarker != undefined))
				{
					for ( var i = 0; i < this.markers.length; i++)
					{
						if(this.markers[i] != sourceMarker)
						{
							this.markers[i].closeBubbleIfNecessary();
						}
					}
				}
			}
		}

	});

});





},
'ibm/tivoli/fwm/mxmap/factories/bingmaps':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dojo/io/script,ibm/tivoli/fwm/mxmap/impl/BingMaps"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.factories.bingmaps");
dojo.require("dojo.io.script");
dojo.require("ibm.tivoli.fwm.mxmap.impl.BingMaps");
/**
 * Factory to load bing maps api javascripts
 */
ibm.tivoli.fwm.mxmap.factories.bingmaps = {
	/**
	 * After we load the bing maps javascripts this method is called. 
	 */
	loaded:false,
	apiLoaded : function() {		
		console.log('Bing Maps API is now available');
		ibm.tivoli.fwm.mxmap.factories.bingmaps.loaded=true;
		ibm.tivoli.fwm.mxmap.factory.apiInitialized("ibm.tivoli.fwm.mxmap.impl.BingMaps","bingmaps");
	},
	/**
	 * method to be overriden by all map factory implementation 
	 * @param options
	 */
	init : function(options) {
		this._loadJSApi(options.mapConf.key, options.mapConf.https, options.mapConf.locale);
	},
	/**
	 * this method loads the bing maps api and the mapstraction js for bing.
	 */
	_loadJSApi : function(key, https, locale) {
		var queryStr = "";
		var protocol = 'http';
		var license = '';
		if(https){
			protocol = 'https';
		}
		if(key){
			license = '&key=' + key;
			queryStr+=license;
		}else{
			console.warn("no bing maps key was set.");
		}
		
		window.fwmBingMapsLoaded=function(){
			ibm.tivoli.fwm.mxmap.factories.bingmaps.apiLoaded();
		};
		dojo.io.script.get({
			url : protocol + '://www.bing.com/api/maps/mapcontrol?callback=fwmBingMapsLoaded' + queryStr,
			timeout : 30000,
			error : function() {
				console.error('Failed to load bing apis');
				alert('Failed to load bing maps api');
			}
		});
		//NOT NEEDED since the onscriptload method is working.
		//ibm.tivoli.fwm.mxmap.factories.bingmaps.apiPooler();
	},
	 
	apiPooler:function(){
		try{
		if(Microsoft && Microsoft.Maps){
			ibm.tivoli.fwm.mxmap.factories.bingmaps.apiLoaded();
			return;
		}
		}catch (e) {
			// todo: handle exception
		}
		
			if(ibm.tivoli.fwm.mxmap.factories.bingmaps.loaded!=true){
				setTimeout("ibm.tivoli.fwm.mxmap.factories.bingmaps.apiPooler",500);
			}
		
		
	}
};

});

},
'ibm/tivoli/fwm/mxmap/MapResize':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18
 *
 * (C) COPYRIGHT IBM CORP. 2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define( 
    [
        "dojo/_base/declare"
    ], 
    function ( 
        declare
    ) {
        return declare(null, {

            _isLayoutReady: false,
            MAP_TAB_PARENT_ID: "SystemNavAppContent-sc_div",
            DEFINED_APP_PARENTS_WIDTH: {
                TECHTABLET: {
                    width: "100%",
                },
            },

            constructor: function (options, map) {
                this.mapConf = options.mapConf;
                this.divId = options.divId;
                this.map = map;
            },

            destroy: function() {
                if (this.scrollbarsObserver) {
                    this.scrollbarsObserver.disconnect();
                }
                this.scrollbarsObserver = null;
            },

            resize: function() {
                if (this.mapConf.isInMapManager) {
                    return;
                }

                this.resizer = setInterval(dojo.hitch(this, function() {
                    if (!this.isLayoutReady()) {
                        return;
                    }

                    clearInterval(this.resizer);

                    this.resizeAfterReady();
                    this.createScroolbarsObserver();
				}), 50);
            },

            createScroolbarsObserver: function() {
                var scrollbars = this.getScrollbars();
                if (!scrollbars.length) {
                    return;
                }
    
                if (!this.scrollbarsObserver) {
                    this.scrollbarsObserver = new MutationObserver(dojo.hitch(this, this.onScrollbarChanged));
                }
    
                dojo.forEach(scrollbars, dojo.hitch(this, function(scrollbar) {
                    this.scrollbarsObserver.observe(scrollbar, { attributes: true });
                }));
            },
    
            onScrollbarChanged: function() {
                var scroller = dojo.query('.custom-scroller', this.MAP_TAB_PARENT_ID)[0];
                if (scroller) {
                    var firstChild = scroller.children[0];
                    if (firstChild) {
                        dojo.style(firstChild, {
                            'margin-inline-end': '0px',
                            'margin-bottom': '0px'
                        });
                    }
                }
                
                this.resizeAfterReady();
                this.hideScrollbars();
            },
    
            getScrollbars: function() {
                return dojo.query('.custom-scroller-track', this.MAP_TAB_PARENT_ID);
            },
    
            hideScrollbars: function() {
                var scrollbars = this.getScrollbars();
                if (scrollbars) {
                    dojo.forEach(scrollbars, dojo.hitch(this, function(scrollbar) {
                        dojo.style(scrollbar, 'display', 'none');
                    }));
                }
            },

            resizeAfterReady: function() {
                this.removeMapBorder();
                this.fillMapSpace(this.divId);
            },

            isLayoutReady: function() {
                if (this._isLayoutReady) {
                    return this._isLayoutReady;
                }
                
                var mapParentApplication = this.getMapParentApplication()
                if (this.getDefinedAppParent(mapParentApplication)) {
                    return this._isLayoutReady = true;
                }

                var isTabGroupDefined = this.mapConf && this.mapConf.tabGroupId;
                if (isTabGroupDefined) {
                    return this._isLayoutReady = dojo.byId(this.mapConf.tabGroupId).style.paddingTop === '3rem';
                }
    
                return this._isLayoutReady = true;
            },
    
            removeMapBorder: function() {
                var tableBodyElements = document.getElementsByClassName("tabBodyTableStretch");
                if (tableBodyElements.length > 0) {
                    var tableBodyTable = tableBodyElements[0];
                    dojo.setStyle(tableBodyTable, "border-spacing", "0px");
                }
            },
    
            fillMapSpace: function(mapId) {
                var mapIFrame = dojo.byId(mapId);
                if (!mapIFrame) {
                    return;
                }

                if (mapIFrame.contentDocument && mapIFrame.contentDocument.body) {
                    dojo.setStyle(mapIFrame.contentDocument.body, "overflow", "hidden");
                }

                var mapParentTab = this.getMapParentTab();
                if (!mapParentTab) {
                    var mapParentApplication = this.getMapParentApplication();
                    if (mapParentApplication){
                        this.setMapSpaceByParentApplication(mapParentApplication, mapIFrame)
                    }

                    return;
                }

                var widthPercentage = 1.0;
                if (this.inDispatchMap()) {
                    widthPercentage = 0.5;
                }
    
                var mapParentTabStyles = window.getComputedStyle(mapParentTab);
                var mapParentTabWidthPX = mapParentTabStyles.width;
                var mapParentTabWidthNumber = parseFloat(mapParentTabWidthPX.replace("px", ""));
                var mapParentTabWidth = (mapParentTabWidthNumber * widthPercentage) + "px";
                dojo.setStyle(mapIFrame, "width", mapParentTabWidth);

                var heightPercentage = 1.0;
                if (this.isLinearVisualControlOpen()) {
                    heightPercentage = 0.5;
                }
    
                var height = mapParentTab.offsetHeight - mapIFrame.offsetTop;
                dojo.setStyle(mapIFrame, "height", (height * heightPercentage) + "px");
            },

            getMapParentTab: function() {
                return dojo.byId(this.MAP_TAB_PARENT_ID);
            },

            inDispatchMap: function() {
                var dispatchTabs = dojo.query(".dispatch");

                return dispatchTabs.length > 0;
            },

            isLinearVisualControlOpen: function() {
                if (!this.map || !this.map.RefLinearView || !this.map.RefLinearView.setMapVisibleCtrl) {
                    return false;
                }

                return true;
            },

            getMapParentApplication: function(){
                return this.mapConf.parentApplication;
            },

            setMapSpaceByParentApplication: function(mapParentApplication, mapIframe){
                var appParent = this.getDefinedAppParent(mapParentApplication)
                if (appParent) {
                    dojo.setStyle(mapIframe, "width", appParent.width);
                }
            },

            getDefinedAppParent: function(mapParentApplication) {
                var appParent = this.DEFINED_APP_PARENTS_WIDTH[mapParentApplication]
                return appParent;
            }
            
        });
    } 
);

},
'dojo/request/script':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	'module',
	'./watch',
	'./util',
	'../_base/kernel',
	'../_base/array',
	'../_base/lang',
	'../on',
	'../dom',
	'../dom-construct',
	'../has',
	'../_base/window'/*=====,
	'../request',
	'../_base/declare' =====*/
], function(module, watch, util, kernel, array, lang, on, dom, domConstruct, has, win/*=====, request, declare =====*/){
	has.add('script-readystatechange', function(global, document){
		var script = document.createElement('script');
		return typeof script['onreadystatechange'] !== 'undefined' &&
			(typeof global['opera'] === 'undefined' || global['opera'].toString() !== '[object Opera]');
	});

	var mid = module.id.replace(/[\/\.\-]/g, '_'),
		counter = 0,
		loadEvent = has('script-readystatechange') ? 'readystatechange' : 'load',
		readyRegExp = /complete|loaded/,
		callbacks = kernel.global[mid + '_callbacks'] = {},
		deadScripts = [];

	function attach(id, url, frameDoc, errorHandler){
		var doc = (frameDoc || win.doc),
			element = doc.createElement('script');

		if (errorHandler) {
			on.once(element, 'error', errorHandler);
		}

		element.type = 'text/javascript';
		try {
			element.src = url;
		} catch(err) {
			errorHandler && errorHandler(element);
		}

		element.id = id;
		element.async = true;
		element.charset = 'utf-8';

		return doc.getElementsByTagName('head')[0].appendChild(element);
	}

	function remove(id, frameDoc, cleanup){
		domConstruct.destroy(dom.byId(id, frameDoc));

		if(callbacks[id]){
			if(cleanup){
				// set callback to a function that deletes itself so requests that
				// are in-flight don't error out when returning and also
				// clean up after themselves
				callbacks[id] = function(){
					delete callbacks[id];
				};
			}else{
				delete callbacks[id];
			}
		}
	}

	function _addDeadScript(dfd){
		// Be sure to check ioArgs because it can dynamically change in the dojox/io plugins.
		// See http://bugs.dojotoolkit.org/ticket/15890.
		var options = dfd.response.options,
			frameDoc = options.ioArgs ? options.ioArgs.frameDoc : options.frameDoc;

		deadScripts.push({ id: dfd.id, frameDoc: frameDoc });

		if(options.ioArgs){
			options.ioArgs.frameDoc = null;
		}
		options.frameDoc = null;
	}

	function canceler(dfd, response){
		if(dfd.canDelete){
			//For timeouts and cancels, remove the script element immediately to
			//avoid a response from it coming back later and causing trouble.
			script._remove(dfd.id, response.options.frameDoc, true);
		}
	}
	function isValid(response){
		//Do script cleanup here. We wait for one inflight pass
		//to make sure we don't get any weird things by trying to remove a script
		//tag that is part of the call chain (IE 6 has been known to
		//crash in that case).
		if(deadScripts && deadScripts.length){
			array.forEach(deadScripts, function(_script){
				script._remove(_script.id, _script.frameDoc);
				_script.frameDoc = null;
			});
			deadScripts = [];
		}

		return response.options.jsonp ? !response.data : true;
	}
	function isReadyScript(response){
		return !!this.scriptLoaded;
	}
	function isReadyCheckString(response){
		var checkString = response.options.checkString;

		return checkString && eval('typeof(' + checkString + ') !== "undefined"');
	}
	function handleResponse(response, error){
		if(this.canDelete){
			_addDeadScript(this);
		}
		if(error){
			this.reject(error);
		}else{
			this.resolve(response);
		}
	}

	function script(url, options, returnDeferred){
		var response = util.parseArgs(url, util.deepCopy({}, options));
		url = response.url;
		options = response.options;

		var dfd = util.deferred(
			response,
			canceler,
			isValid,
			options.jsonp ? null : (options.checkString ? isReadyCheckString : isReadyScript),
			handleResponse
		);

		lang.mixin(dfd, {
			id: mid + (counter++),
			canDelete: false
		});

		if(options.jsonp){
			var queryParameter = new RegExp('[?&]' + options.jsonp + '=');
			if(!queryParameter.test(url)){
				url += (~url.indexOf('?') ? '&' : '?') +
					options.jsonp + '=' +
					(options.frameDoc ? 'parent.' : '') +
					mid + '_callbacks.' + dfd.id;
			}

			dfd.canDelete = true;
			callbacks[dfd.id] = function(json){
				response.data = json;
				dfd.handleResponse(response);
			};
		}

		if(util.notify){
			util.notify.emit('send', response, dfd.promise.cancel);
		}

		if(!options.canAttach || options.canAttach(dfd)){
			var node = script._attach(dfd.id, url, options.frameDoc, function (error) {
				if (!(error instanceof Error)) {
					var newError = new Error('Error loading ' + (error.target ? error.target.src : 'script'));
					newError.source = error;
					error = newError;
				}
				dfd.reject(error);
				script._remove(dfd.id, options.frameDoc, true);
			});

			if(!options.jsonp && !options.checkString){
				var handle = on(node, loadEvent, function(evt){
					if(evt.type === 'load' || readyRegExp.test(node.readyState)){
						handle.remove();
						dfd.scriptLoaded = evt;
					}
				});
			}
		}

		watch(dfd);

		return returnDeferred ? dfd : dfd.promise;
	}
	script.get = script;
	/*=====
	script = function(url, options){
		// summary:
		//		Sends a request using a script element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/script.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	script.__BaseOptions = declare(request.__BaseOptions, {
		// jsonp: String?
		//		The URL parameter name that indicates the JSONP callback string.
		//		For instance, when using Yahoo JSONP calls it is normally,
		//		jsonp: "callback". For AOL JSONP calls it is normally
		//		jsonp: "c".
		// checkString: String?
		//		A string of JavaScript that when evaluated like so:
		//		"typeof(" + checkString + ") != 'undefined'"
		//		being true means that the script fetched has been loaded.
		//		Do not use this if doing a JSONP type of call (use `jsonp` instead).
		// frameDoc: Document?
		//		The Document object of a child iframe. If this is passed in, the script
		//		will be attached to that document. This can be helpful in some comet long-polling
		//		scenarios with Firefox and Opera.
	});
	script.__MethodOptions = declare(null, {
		// method: String?
		//		This option is ignored. All requests using this transport are
		//		GET requests.
	});
	script.__Options = declare([script.__BaseOptions, script.__MethodOptions]);

	script.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using a script element with the given URL and options.
		// url: String
		//		URL to request
		// options: dojo/request/script.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/

	// TODO: Remove in 2.0
	script._attach = attach;
	script._remove = remove;
	script._callbacksProperty = mid + '_callbacks';

	return script;
});

},
'dijit/popup':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach array.some
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-construct", // domConstruct.create domConstruct.destroy
	"dojo/dom-geometry", // domGeometry.isBodyLtr
	"dojo/dom-style", // domStyle.set
	"dojo/has", // has("config-bgIframe")
	"dojo/keys",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"./place",
	"./BackgroundIframe",
	"./Viewport",
	"./main",    // dijit (defining dijit.popup to match API doc)
	"dojo/touch"		// use of dojoClick
], function(array, aspect, declare, dom, domAttr, domConstruct, domGeometry, domStyle, has, keys, lang, on,
			place, BackgroundIframe, Viewport, dijit){

	// module:
	//		dijit/popup

	/*=====
	 var __OpenArgs = {
		 // popup: Widget
		 //		widget to display
		 // parent: Widget
		 //		the button etc. that is displaying this popup
		 // around: DomNode
		 //		DOM node (typically a button); place popup relative to this node.  (Specify this *or* "x" and "y" parameters.)
		 // x: Integer
		 //		Absolute horizontal position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
		 // y: Integer
		 //		Absolute vertical position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
		 // orient: Object|String
		 //		When the around parameter is specified, orient should be a list of positions to try, ex:
		 //	|	[ "below", "above" ]
		 //		For backwards compatibility it can also be an (ordered) hash of tuples of the form
		 //		(around-node-corner, popup-node-corner), ex:
		 //	|	{ "BL": "TL", "TL": "BL" }
		 //		where BL means "bottom left" and "TL" means "top left", etc.
		 //
		 //		dijit/popup.open() tries to position the popup according to each specified position, in order,
		 //		until the popup appears fully within the viewport.
		 //
		 //		The default value is ["below", "above"]
		 //
		 //		When an (x,y) position is specified rather than an around node, orient is either
		 //		"R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
		 //		specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
		 //		fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
		 //		and the top-right corner.
		 // onCancel: Function
		 //		callback when user has canceled the popup by:
		 //
		 //		1. hitting ESC or
		 //		2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
		 //		   i.e. whenever popupWidget.onCancel() is called, args.onCancel is called
		 // onClose: Function
		 //		callback whenever this popup is closed
		 // onExecute: Function
		 //		callback when user "executed" on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
		 // padding: place.__Position
		 //		adding a buffer around the opening position. This is only useful when around is not set.
		 // maxHeight: Integer
		 //		The max height for the popup.  Any popup taller than this will have scrollbars.
		 //		Set to Infinity for no max height.  Default is to limit height to available space in viewport,
		 //		above or below the aroundNode or specified x/y position.
	 };
	 =====*/

	function destroyWrapper(){
		// summary:
		//		Function to destroy wrapper when popup widget is destroyed.
		//		Left in this scope to avoid memory leak on IE8 on refresh page, see #15206.
		if(this._popupWrapper){
			domConstruct.destroy(this._popupWrapper);
			delete this._popupWrapper;
		}
	}

	var PopupManager = declare(null, {
		// summary:
		//		Used to show drop downs (ex: the select list of a ComboBox)
		//		or popups (ex: right-click context menus).

		// _stack: dijit/_WidgetBase[]
		//		Stack of currently popped up widgets.
		//		(someone opened _stack[0], and then it opened _stack[1], etc.)
		_stack: [],

		// _beginZIndex: Number
		//		Z-index of the first popup.   (If first popup opens other
		//		popups they get a higher z-index.)
		_beginZIndex: 1000,

		_idGen: 1,

		_repositionAll: function(){
			// summary:
			//		If screen has been scrolled, reposition all the popups in the stack.
			//		Then set timer to check again later.

			if(this._firstAroundNode){	// guard for when clearTimeout() on IE doesn't work
				var oldPos = this._firstAroundPosition,
					newPos = domGeometry.position(this._firstAroundNode, true),
					dx = newPos.x - oldPos.x,
					dy = newPos.y - oldPos.y;

				if(dx || dy){
					this._firstAroundPosition = newPos;
					for(var i = 0; i < this._stack.length; i++){
						var style = this._stack[i].wrapper.style;
						style.top = (parseFloat(style.top) + dy) + "px";
						if(style.right == "auto"){
							style.left = (parseFloat(style.left) + dx) + "px";
						}else{
							style.right = (parseFloat(style.right) - dx) + "px";
						}
					}
				}

				this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), dx || dy ? 10 : 50);
			}
		},

		_createWrapper: function(/*Widget*/ widget){
			// summary:
			//		Initialization for widgets that will be used as popups.
			//		Puts widget inside a wrapper DIV (if not already in one),
			//		and returns pointer to that wrapper DIV.

			var wrapper = widget._popupWrapper,
				node = widget.domNode;

			if(!wrapper){
				// Create wrapper <div> for when this widget [in the future] will be used as a popup.
				// This is done early because of IE bugs where creating/moving DOM nodes causes focus
				// to go wonky, see tests/robot/Toolbar.html to reproduce
				wrapper = domConstruct.create("div", {
					"class": "dijitPopup",
					style: { display: "none"},
					role: "region",
					"aria-label": widget["aria-label"] || widget.label || widget.name || widget.id
				}, widget.ownerDocumentBody);
				wrapper.appendChild(node);

				var s = node.style;
				s.display = "";
				s.visibility = "";
				s.position = "";
				s.top = "0px";

				widget._popupWrapper = wrapper;
				aspect.after(widget, "destroy", destroyWrapper, true);

				// Workaround iOS problem where clicking a Menu can focus an <input> (or click a button) behind it.
				// Need to be careful though that you can still focus <input>'s and click <button>'s in a TooltipDialog.
				// Also, be careful not to break (native) scrolling of dropdown like ComboBox's options list.
				if("ontouchend" in document) {
					on(wrapper, "touchend", function (evt){
						if(!/^(input|button|textarea)$/i.test(evt.target.tagName)) {
							evt.preventDefault();
						}
					});
				}

				// Calling evt.preventDefault() suppresses the native click event on most browsers.  However, it doesn't
				// suppress the synthetic click event emitted by dojo/touch.  In order for clicks in popups to work
				// consistently, always use dojo/touch in popups.  See #18150.
				wrapper.dojoClick = true;
			}

			return wrapper;
		},

		moveOffScreen: function(/*Widget*/ widget){
			// summary:
			//		Moves the popup widget off-screen.
			//		Do not use this method to hide popups when not in use, because
			//		that will create an accessibility issue: the offscreen popup is
			//		still in the tabbing order.

			// Create wrapper if not already there
			var wrapper = this._createWrapper(widget);

			// Besides setting visibility:hidden, move it out of the viewport, see #5776, #10111, #13604
			var ltr = domGeometry.isBodyLtr(widget.ownerDocument),
				style = {
					visibility: "hidden",
					top: "-9999px",
					display: ""
				};
			style[ltr ? "left" : "right"] = "-9999px";
			style[ltr ? "right" : "left"] = "auto";
			domStyle.set(wrapper, style);

			return wrapper;
		},

		hide: function(/*Widget*/ widget){
			// summary:
			//		Hide this popup widget (until it is ready to be shown).
			//		Initialization for widgets that will be used as popups
			//
			//		Also puts widget inside a wrapper DIV (if not already in one)
			//
			//		If popup widget needs to layout it should
			//		do so when it is made visible, and popup._onShow() is called.

			// Create wrapper if not already there
			var wrapper = this._createWrapper(widget);

			domStyle.set(wrapper, {
				display: "none",
				height: "auto",			// Open() may have limited the height to fit in the viewport,
				overflowY: "visible",	// and set overflowY to "auto".
				border: ""				// Open() may have moved border from popup to wrapper.
			});

			// Open() may have moved border from popup to wrapper.  Move it back.
			var node = widget.domNode;
			if("_originalStyle" in node){
				node.style.cssText = node._originalStyle;
			}
		},

		getTopPopup: function(){
			// summary:
			//		Compute the closest ancestor popup that's *not* a child of another popup.
			//		Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
			var stack = this._stack;
			for(var pi = stack.length - 1; pi > 0 && stack[pi].parent === stack[pi - 1].widget; pi--){
				/* do nothing, just trying to get right value for pi */
			}
			return stack[pi];
		},

		open: function(/*__OpenArgs*/ args){
			// summary:
			//		Popup the widget at the specified position
			//
			// example:
			//		opening at the mouse position
			//		|		popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
			//
			// example:
			//		opening the widget as a dropdown
			//		|		popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
			//
			//		Note that whatever widget called dijit/popup.open() should also listen to its own _onBlur callback
			//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.

			var stack = this._stack,
				widget = args.popup,
				node = widget.domNode,
				orient = args.orient || ["below", "below-alt", "above", "above-alt"],
				ltr = args.parent ? args.parent.isLeftToRight() : domGeometry.isBodyLtr(widget.ownerDocument),
				around = args.around,
				id = (args.around && args.around.id) ? (args.around.id + "_dropdown") : ("popup_" + this._idGen++);

			// If we are opening a new popup that isn't a child of a currently opened popup, then
			// close currently opened popup(s).   This should happen automatically when the old popups
			// gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].
			while(stack.length && (!args.parent || !dom.isDescendant(args.parent.domNode, stack[stack.length - 1].widget.domNode))){
				this.close(stack[stack.length - 1].widget);
			}

			// Get pointer to popup wrapper, and create wrapper if it doesn't exist.  Remove display:none (but keep
			// off screen) so we can do sizing calculations.
			var wrapper = this.moveOffScreen(widget);

			if(widget.startup && !widget._started){
				widget.startup(); // this has to be done after being added to the DOM
			}

			// Limit height to space available in viewport either above or below aroundNode (whichever side has more
			// room), adding scrollbar if necessary. Can't add scrollbar to widget because it may be a <table> (ex:
			// dijit/Menu), so add to wrapper, and then move popup's border to wrapper so scroll bar inside border.
			var maxHeight, popupSize = domGeometry.position(node);
			if("maxHeight" in args && args.maxHeight != -1){
				maxHeight = args.maxHeight || Infinity;	// map 0 --> infinity for back-compat of _HasDropDown.maxHeight
			}else{
				var viewport = Viewport.getEffectiveBox(this.ownerDocument),
					aroundPos = around ? domGeometry.position(around, false) : {y: args.y - (args.padding||0), h: (args.padding||0) * 2};
				maxHeight = Math.floor(Math.max(aroundPos.y, viewport.h - (aroundPos.y + aroundPos.h)));
			}
			if(popupSize.h > maxHeight){
				// Get style of popup's border.  Unfortunately domStyle.get(node, "border") doesn't work on FF or IE,
				// and domStyle.get(node, "borderColor") etc. doesn't work on FF, so need to use fully qualified names.
				var cs = domStyle.getComputedStyle(node),
					borderStyle = cs.borderLeftWidth + " " + cs.borderLeftStyle + " " + cs.borderLeftColor;
				domStyle.set(wrapper, {
					overflowY: "scroll",
					height: maxHeight + "px",
					border: borderStyle	// so scrollbar is inside border
				});
				node._originalStyle = node.style.cssText;
				node.style.border = "none";
			}

			domAttr.set(wrapper, {
				id: id,
				style: {
					zIndex: this._beginZIndex + stack.length
				},
				"class": "dijitPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] + "Popup",
				dijitPopupParent: args.parent ? args.parent.id : ""
			});

			if(stack.length == 0 && around){
				// First element on stack. Save position of aroundNode and setup listener for changes to that position.
				this._firstAroundNode = around;
				this._firstAroundPosition = domGeometry.position(around, true);
				this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), 50);
			}

			if(has("config-bgIframe") && !widget.bgIframe){
				// setting widget.bgIframe triggers cleanup in _WidgetBase.destroyRendering()
				widget.bgIframe = new BackgroundIframe(wrapper);
			}

			// position the wrapper node and make it visible
			var layoutFunc = widget.orient ? lang.hitch(widget, "orient") : null,
				best = around ?
					place.around(wrapper, around, orient, ltr, layoutFunc) :
					place.at(wrapper, args, orient == 'R' ? ['TR', 'BR', 'TL', 'BL'] : ['TL', 'BL', 'TR', 'BR'], args.padding,
						layoutFunc);

			wrapper.style.visibility = "visible";
			node.style.visibility = "visible";	// counteract effects from _HasDropDown

			var handlers = [];

			// provide default escape and tab key handling
			// (this will work for any widget, not just menu)
			handlers.push(on(wrapper, "keydown", lang.hitch(this, function(evt){
				if(evt.keyCode == keys.ESCAPE && args.onCancel){
					evt.stopPropagation();
					evt.preventDefault();
					args.onCancel();
				}else if(evt.keyCode == keys.TAB){
					evt.stopPropagation();
					evt.preventDefault();
					var topPopup = this.getTopPopup();
					if(topPopup && topPopup.onCancel){
						topPopup.onCancel();
					}
				}
			})));

			// watch for cancel/execute events on the popup and notify the caller
			// (for a menu, "execute" means clicking an item)
			if(widget.onCancel && args.onCancel){
				handlers.push(widget.on("cancel", args.onCancel));
			}

			handlers.push(widget.on(widget.onExecute ? "execute" : "change", lang.hitch(this, function(){
				var topPopup = this.getTopPopup();
				if(topPopup && topPopup.onExecute){
					topPopup.onExecute();
				}
			})));

			stack.push({
				widget: widget,
				wrapper: wrapper,
				parent: args.parent,
				onExecute: args.onExecute,
				onCancel: args.onCancel,
				onClose: args.onClose,
				handlers: handlers
			});

			if(widget.onOpen){
				// TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
				widget.onOpen(best);
			}

			return best;
		},

		close: function(/*Widget?*/ popup){
			// summary:
			//		Close specified popup and any popups that it parented.
			//		If no popup is specified, closes all popups.

			var stack = this._stack;

			// Basically work backwards from the top of the stack closing popups
			// until we hit the specified popup, but IIRC there was some issue where closing
			// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
			// closing C might close B indirectly and then the while() condition will run where stack==[A]...
			// so the while condition is constructed defensively.
			while((popup && array.some(stack, function(elem){
				return elem.widget == popup;
			})) ||
				(!popup && stack.length)){
				var top = stack.pop(),
					widget = top.widget,
					onClose = top.onClose;

				if (widget.bgIframe) {
					// push the iframe back onto the stack.
					widget.bgIframe.destroy();
					delete widget.bgIframe;
				}

				if(widget.onClose){
					// TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here).
					// Actually, StackContainer also calls onClose(), but to mean that the pane is being deleted
					// (i.e. that the TabContainer's tab's [x] icon was clicked)
					widget.onClose();
				}

				var h;
				while(h = top.handlers.pop()){
					h.remove();
				}

				// Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.
				if(widget && widget.domNode){
					this.hide(widget);
				}

				if(onClose){
					onClose();
				}
			}

			if(stack.length == 0 && this._aroundMoveListener){
				clearTimeout(this._aroundMoveListener);
				this._firstAroundNode = this._firstAroundPosition = this._aroundMoveListener = null;
			}
		}
	});

	return (dijit.popup = new PopupManager());
});

},
'dijit/_base/manager':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array",
	"dojo/_base/config", // defaultDuration
	"dojo/_base/lang",
	"../registry",
	"../main"	// for setting exports to dijit namespace
], function(array, config, lang, registry, dijit){

	// module:
	//		dijit/_base/manager

	var exports = {
		// summary:
		//		Deprecated.  Shim to methods on registry, plus a few other declarations.
		//		New code should access dijit/registry directly when possible.
	};

	array.forEach(["byId", "getUniqueId", "findWidgets", "_destroyAll", "byNode", "getEnclosingWidget"], function(name){
		exports[name] = registry[name];
	});

	 lang.mixin(exports, {
		 // defaultDuration: Integer
		 //		The default fx.animation speed (in ms) to use for all Dijit
		 //		transitional fx.animations, unless otherwise specified
		 //		on a per-instance basis. Defaults to 200, overrided by
		 //		`djConfig.defaultDuration`
		 defaultDuration: config["defaultDuration"] || 200
	 });

	lang.mixin(dijit, exports);

	/*===== return exports; =====*/
	return dijit;	// for back compat :-(
});

},
'dojo/dnd/Mover':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"../_base/array", "../_base/declare", "../_base/lang", "../sniff", "../_base/window",
	"../dom", "../dom-geometry", "../dom-style", "../Evented", "../on", "../touch", "./common", "./autoscroll"
], function(array, declare, lang, has, win, dom, domGeom, domStyle, Evented, on, touch, dnd, autoscroll){

// module:
//		dojo/dnd/Mover

return declare("dojo.dnd.Mover", [Evented], {
	// summary:
	//		an object which makes a node follow the mouse, or touch-drag on touch devices.
	//		Used as a default mover, and as a base class for custom movers.

	constructor: function(node, e, host){
		// node: Node
		//		a node (or node's id) to be moved
		// e: Event
		//		a mouse event, which started the move;
		//		only pageX and pageY properties are used
		// host: Object?
		//		object which implements the functionality of the move,
		//	 	and defines proper events (onMoveStart and onMoveStop)
		this.node = dom.byId(node);
		this.marginBox = {l: e.pageX, t: e.pageY};
		this.mouseButton = e.button;
		var h = (this.host = host), d = node.ownerDocument;

		function stopEvent(e){
			e.preventDefault();
			e.stopPropagation();
		}

		this.events = [
			// At the start of a drag, onFirstMove is called, and then the following
			// listener is disconnected.
			on(d, touch.move, lang.hitch(this, "onFirstMove")),

			// These are called continually during the drag
			on(d, touch.move, lang.hitch(this, "onMouseMove")),

			// And these are called at the end of the drag
			on(d, touch.release,  lang.hitch(this, "onMouseUp")),

			// cancel text selection and text dragging
			on(d, "dragstart",   stopEvent),
			on(d.body, "selectstart", stopEvent)
		];

		// Tell autoscroll that a drag is starting
		autoscroll.autoScrollStart(d);

		// notify that the move has started
		if(h && h.onMoveStart){
			h.onMoveStart(this);
		}
	},
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove
		// e: Event
		//		mouse/touch event
		autoscroll.autoScroll(e);
		var m = this.marginBox;
		this.host.onMove(this, {l: m.l + e.pageX, t: m.t + e.pageY}, e);
		e.preventDefault();
		e.stopPropagation();
	},
	onMouseUp: function(e){
		if(has("webkit") && has("mac") && this.mouseButton == 2 ?
				e.button == 0 : this.mouseButton == e.button){ // TODO Should condition be met for touch devices, too?
			this.destroy();
		}
		e.preventDefault();
		e.stopPropagation();
	},
	// utilities
	onFirstMove: function(e){
		// summary:
		//		makes the node absolute; it is meant to be called only once.
		//		relative and absolutely positioned nodes are assumed to use pixel units
		var s = this.node.style, l, t, h = this.host;
		switch(s.position){
			case "relative":
			case "absolute":
				// assume that left and top values are in pixels already
				l = Math.round(parseFloat(s.left)) || 0;
				t = Math.round(parseFloat(s.top)) || 0;
				break;
			default:
				s.position = "absolute";	// enforcing the absolute mode
				var m = domGeom.getMarginBox(this.node);
				// event.pageX/pageY (which we used to generate the initial
				// margin box) includes padding and margin set on the body.
				// However, setting the node's position to absolute and then
				// doing domGeom.marginBox on it *doesn't* take that additional
				// space into account - so we need to subtract the combined
				// padding and margin.  We use getComputedStyle and
				// _getMarginBox/_getContentBox to avoid the extra lookup of
				// the computed style.
				var b = win.doc.body;
				var bs = domStyle.getComputedStyle(b);
				var bm = domGeom.getMarginBox(b, bs);
				var bc = domGeom.getContentBox(b, bs);
				l = m.l - (bc.l - bm.l);
				t = m.t - (bc.t - bm.t);
				break;
		}
		this.marginBox.l = l - this.marginBox.l;
		this.marginBox.t = t - this.marginBox.t;
		if(h && h.onFirstMove){
			h.onFirstMove(this, e);
		}

		// Disconnect touch.move that call this function
		this.events.shift().remove();
	},
	destroy: function(){
		// summary:
		//		stops the move, deletes all references, so the object can be garbage-collected
		array.forEach(this.events, function(handle){ handle.remove(); });
		// undo global settings
		var h = this.host;
		if(h && h.onMoveStop){
			h.onMoveStop(this);
		}
		// destroy objects
		this.events = this.node = this.host = null;
	}
});

});

},
'dojo/request/default':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	'exports',
	'require',
	'../has'
], function(exports, require, has){
	var defId = has('config-requestProvider'),
		platformId;

	if( 1  || has('host-webworker')){
		platformId = './xhr';
	}else if( 0 ){
		platformId = './node';
	/* TODO:
	}else if( 0 ){
		platformId = './rhino';
   */
	}

	if(!defId){
		defId = platformId;
	}

	exports.getPlatformDefaultId = function(){
		return platformId;
	};

	exports.load = function(id, parentRequire, loaded, config){
		require([id == 'platform' ? platformId : defId], function(provider){
			loaded(provider);
		});
	};
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/QueryWeatherAlertsTool':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/toolbar/ext/QueryWeatherAlerts"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.toolbar.ext.QueryWeatherAlertsTool");
dojo.require("ibm.tivoli.fwm.mxmap.toolbar.ext.QueryWeatherAlerts");

/**
 * Query nearby resources tool (with one more menu option)
 */
dojo.declare("ibm.tivoli.fwm.mxmap.toolbar.ext.QueryWeatherAlertsTool", ibm.tivoli.fwm.mxmap.toolbar.ext.QueryWeatherAlerts, {
	
	// This version of _sendEventToLayer tries to append routeInfo to the resource record
	// so that the route color can be obtained and the icon color can match the route color
	_sendEventToLayer: function(layerName, layerData, avoidLayerEnabled)
	{
		var disp = this.map.getDispatcher();
		if(disp)
		{
			for (var i in layerData)
			{
				// Convert location accuracy from kilometers to meters.
				layerData[i].lbsdata.location_accuracy = layerData[i].lbsdata.location_accuracy * 1000;
			}

		}
		dojo.publish("addRecordsToLayer_" + this.map.getId(), [ layerName, layerData, true, null, null, avoidLayerEnabled ]);
	}
});

});

},
'dijit/BackgroundIframe':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"require",			// require.toUrl
	"./main",	// to export dijit.BackgroundIframe
	"dojo/_base/config",
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-style", // domStyle.set
	"dojo/_base/lang", // lang.extend lang.hitch
	"dojo/on",
	"dojo/sniff" // has("ie"), has("trident"), has("quirks")
], function(require, dijit, config, domConstruct, domStyle, lang, on, has){

	// module:
	//		dijit/BackgroundIFrame

	// Flag for whether to create background iframe behind popups like Menus and Dialog.
	// A background iframe is useful to prevent problems with popups appearing behind applets/pdf files,
	// and is also useful on older versions of IE (IE6 and IE7) to prevent the "bleed through select" problem.
	// By default, it's enabled for IE6-11, excluding Windows Phone 8.
	// TODO: For 2.0, make this false by default.  Also, possibly move definition to has.js so that this module can be
	// conditionally required via  dojo/has!bgIfame?dijit/BackgroundIframe
	has.add("config-bgIframe",
    	(has("ie") || has("trident")) && !/IEMobile\/10\.0/.test(navigator.userAgent)); // No iframe on WP8, to match 1.9 behavior

	var _frames = new function(){
		// summary:
		//		cache of iframes

		var queue = [];

		this.pop = function(){
			var iframe;
			if(queue.length){
				iframe = queue.pop();
				iframe.style.display="";
			}else{
				// transparency needed for DialogUnderlay and for tooltips on IE (to see screen near connector)
				if(has("ie") < 9){
					var burl = config["dojoBlankHtmlUrl"] || require.toUrl("dojo/resources/blank.html") || "javascript:\"\"";
					var html="<iframe src='" + burl + "' role='presentation'"
						+ " style='position: absolute; left: 0px; top: 0px;"
						+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
					iframe = document.createElement(html);
				}else{
					iframe = domConstruct.create("iframe");
					iframe.src = 'javascript:""';
					iframe.className = "dijitBackgroundIframe";
					iframe.setAttribute("role", "presentation");
					domStyle.set(iframe, "opacity", 0.1);
				}
				iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didn't work.
			}
			return iframe;
		};

		this.push = function(iframe){
			iframe.style.display="none";
			queue.push(iframe);
		}
	}();


	dijit.BackgroundIframe = function(/*DomNode*/ node){
		// summary:
		//		For IE/FF z-index shenanigans. id attribute is required.
		//
		// description:
		//		new dijit.BackgroundIframe(node).
		//
		//		Makes a background iframe as a child of node, that fills
		//		area (and position) of node

		if(!node.id){ throw new Error("no id"); }
		if(has("config-bgIframe")){
			var iframe = (this.iframe = _frames.pop());
			node.appendChild(iframe);
			if(has("ie")<7 || has("quirks")){
				this.resize(node);
				this._conn = on(node, 'resize', lang.hitch(this, "resize", node));
			}else{
				domStyle.set(iframe, {
					width: '100%',
					height: '100%'
				});
			}
		}
	};

	lang.extend(dijit.BackgroundIframe, {
		resize: function(node){
			// summary:
			//		Resize the iframe so it's the same size as node.
			//		Needed on IE6 and IE/quirks because height:100% doesn't work right.
			if(this.iframe){
				domStyle.set(this.iframe, {
					width: node.offsetWidth + 'px',
					height: node.offsetHeight + 'px'
				});
			}
		},
		destroy: function(){
			// summary:
			//		destroy the iframe
			if(this._conn){
				this._conn.remove();
				this._conn = null;
			}
			if(this.iframe){
				this.iframe.parentNode.removeChild(this.iframe);
				_frames.push(this.iframe);
				delete this.iframe;
			}
		}
	});

	return dijit.BackgroundIframe;
});

},
'dojo/json5/unicode':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define({
	Space_Separator: /[\u1680\u2000-\u200A\u202F\u205F\u3000]/,
	ID_Start: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/,
	ID_Continue: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
});

},
'ibm/tivoli/fwm/mxmap/routing/Router':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Base,ibm/tivoli/fwm/mxmap/geolocation/MyCurrentLocation,ibm/tivoli/fwm/mxmap/MXRecord"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.routing.Router");
dojo.require("ibm.tivoli.fwm.mxmap._Base");
dojo.require("ibm.tivoli.fwm.mxmap.geolocation.MyCurrentLocation");
dojo.require("ibm.tivoli.fwm.mxmap.MXRecord");
/**
 * Maximo router main helper class.<br>
 * Map providers must extend this class
 */
ibm.tivoli.fwm.mxmap.routing.CalculatedStops = {
	CONF_START_STOP: "ConfiguredStartLocation",
	CONF_END_STOP: "ConfiguredEndLocation",
	USER_LOCATION_STOP: "UserGeoLocation"
};
ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes = {
	ZERO_RESULTS: "ZERO_RESULTS",
	INVALID_REQUEST: "INVALID_REQUEST",
	REQUEST_DENIED: "REQUEST_DENIED",
	OVER_LIMIT: "OVER_LIMIT",
	MIN_STOPS_REQ: "MIN_STOPS_REQ",
	TIMEOUT: "TIMEOUT",
	UNKNOWN: "UNKNOWN"
};
ibm.tivoli.fwm.mxmap.routing.DistanceUnit = {
	KM: 0,
	MILES: 1,
	getLabel: function(unitType)
	{
		if (unitType == this.KM)
		{
			return ibm.tivoli.fwm.i18n.getMaxMsg("map", "distancekm");
		}
		else
		{
			return ibm.tivoli.fwm.i18n.getMaxMsg("map", "distancemi");
		}
	},
	getBy1000Label: function(unitType)
	{
		if (unitType == this.KM)
		{
			return ibm.tivoli.fwm.i18n.getMaxMsg("map", "distancemeters");
		}
		else
		{
			return ibm.tivoli.fwm.i18n.getMaxMsg("map", "distanceft");
		}
	},
	formatDistance: function(valueInKilometers, unit)
	{
		var val = 0;
		var tokenStr = "";
		var strVal = "";

		if (unit == this.MILES)
		{
			valueInKilometers = valueInKilometers / 1.6;
		}
		if (valueInKilometers <= 0.1)
		{
			val = (valueInKilometers * 10000);
			tokenStr = this.getBy1000Label(unit);
		}
		else
		{
			val = valueInKilometers * 10;
			tokenStr = this.getLabel(unit);
		}
		val = Math.round(val);
		val = val / 10;
		
		strVal = tokenStr.replace("{0}", val.toString());
		
		return strVal;
	},
	formatTime: function(time)
	{
		var tokenStr = "";
		var strVal = "";
		var hr = Math.floor(time / 60), // Important to use math.floor with
		// hours
		min = Math.round(time % 60);

		if (hr < 1 && min < 1)
		{
			return strVal;
		}
		else if (hr < 1)
		{
			tokenStr = ibm.tivoli.fwm.i18n.getMaxMsg("map", "timemin");
			strVal = tokenStr.replace("{0}", min.toString());
		}
		else
		{
			tokenStr = ibm.tivoli.fwm.i18n.getMaxMsg("map", "timehmin");
			strVal = tokenStr.replace("{0}", hr.toString());
			strVal = strVal.replace("{1}", min.toString());
		}
		return strVal;

	}
};
dojo.declare("ibm.tivoli.fwm.mxmap.routing.Router", ibm.tivoli.fwm.mxmap._Base, {
	routecolor: null,
	endLocation: null,
	startLocation: null,
	optimizeroute: false,
	myCurrentLocationInstance: null,
	constructor: function(params)
	{
		dojo.mixin(this, params);
		this.myCurrentLocationInstance = ibm.tivoli.fwm.mxmap.geolocation.MyCurrentLocation.getMyCurrentLocationInstance();
	},
	init: function()
	{
		this._init();
	},
	_init: function()
	{
	},
	/**
	 * Tries to get the device location thru the w3c Geolocation API.<br>
	 * It has a timeout of 10 seconds and if device does not support geolocation
	 * it returns an error code 4.
	 * 
	 * @see http://dev.w3.org/geo/api/spec-source.html
	 * @param callback
	 * @param errorCb
	 */
	getUserLocation: function(callback, errorCb)
	{
		if (this.myCurrentLocationInstance)
		{
			var errorCallback = function()
			{
				if (this.map)
				{
					this.map.failedToGetLocation();
				}
				errorCb();
			};
			
			this.myCurrentLocationInstance.getUserLocation(callback, dojo.hitch(this, errorCallback));
		}
	},
	/**
	 * Converts the current geolocation position into a standard stop.
	 * 
	 * @returns
	 */
	_getUserLocationStop: function()
	{
		var userLocStop = null;
		if (this.myCurrentLocationInstance)
		{
			var position = this.myCurrentLocationInstance.getPosition();
			userLocStop = {
				name: "currentLocation",
				lat: position.coords.latitude,
				lng: position.coords.longitude
			};
		}
		return userLocStop;
	},
	isLocationStatusUnassigned: function()
	{
		var isLocStatUnassigned = false;
		if (this.myCurrentLocationInstance)
		{
			isLocStatUnassigned = this.myCurrentLocationInstance.isStatusUnassigned();
		}
		return isLocStatUnassigned;
	},
	isLocationStatusHasLocation: function()
	{
		var isLocStatHasLoc = false;
		if (this.myCurrentLocationInstance)
		{
			isLocStatHasLoc = this.myCurrentLocationInstance.isStatusHasLocation();
		}
		return isLocStatHasLoc;
	},
	_checkForCalculatedAndLBSStops: function(stops, callback)
	{
		if (stops && stops.length > 0)
		{
			console.log("Total stops " + stops.length);			
						
			if (stops[0].calculatedStop == true)
			{
				stops = stops.slice(1, stops.length );
			}
			if (dojo.config.fwm.debug == true)
			{
				console.log(stops.length, stops);
			}
			var lastStopIndex = 0;
			if (stops.length == 0)
			{
				return stops;
			}
			if (stops.length > 0)
			{
				lastStopIndex = stops.length - 1;
			}
			if (stops[stops.length - 1].calculatedStop == true)
			{
				stops = stops.slice(0, stops.length - 1);
			}
		}

		// check if any missing GISDATA stop
		var i = 0;
		var stopsToConvert = [];
		while (i < stops.length)
		{
			var stop = stops[i];
			var mxRec = new ibm.tivoli.fwm.mxmap.MXRecord({
				mboInfo: stop,
				map: this.map
			});
			if (mxRec.useLBSData())
			{
				// Creating an array of points as expected by the getAllPointsFromWGS84() function
				var point = mxRec.getLBSPoint();
				point.sr = this.map.WGS84WKID;
				// store the index so we can overwrite only the LBS stops in the "stops" array
				point.idx = i;
				stopsToConvert.push(point);
				// Assume that the point in current SR is the lat/lng from lbsdata before the conversion
				mxRec.setPointInCurrentSR(mxRec.getLBSPoint());
				i++;
			}
			else if (mxRec.hasAnyGISCoordinates() == false)
			{
				console.warn("Stop", stop, "Has no GIS info",stops.length);				
				stops=stops.slice(0,i).concat(stops.slice(i+1));
				console.warn("Stop", stops.length);
			}
			else
			{
				i++;
			}
		}
		
		if(stopsToConvert.length > 0)
		{
			var successFct = function(/* array of projected points */points)
			{
				for (i = 0; i < stopsToConvert.length; i++)
				{
					stops[stopsToConvert[i].idx].pointInCurrentSR = points[i];
				}
				callback(stops);
			};
			var errFct = function(err)
			{
				console.error("Error converting point to current SR", err);
			};
			this.map.getAllPointsFromWGS84(stopsToConvert, dojo.hitch(this, successFct));
		}
		else
		{
			callback(stops);
		}

		return stops;
	},
	/**
	 * Draw the route based on a set of stops and the current route
	 * configuration.<br>
	 * If route starts with current location it retrieves the current location
	 * and inserts it into the 1st stop.<br>
	 * Else if there is a starting point set with lat/lng it inserts the
	 * starting point into the 1st stop.<br>
	 * If there is an ending point set with lat/lng it inserts the ending point
	 * into the 1st stop.<br>
	 * 
	 * @param stops []
	 * @param successcallback
	 * @param errorCallback
	 */
	drawRoute: function(stops, callback, errorCallback, instanceConf)
	{

		// _checkForCalculatedAndLBSStops now relies on a callback return to parse all the route stops
		// so all statements from drawRoute are now in a callback function
		this._checkForCalculatedAndLBSStops(stops, dojo.hitch(this, function(stops)
		{
			if (this.isStartWithCurrentLocation(instanceConf) && this.isLocationStatusUnassigned())
			{
				var fct = function()
				{
					console.info("continuing to draw route WITH user start location");	
					// The instanceConf parameter must always be passed
					this.drawRoute(stops, callback, errorCallback, instanceConf);
				};
				var fctError = function()
				{
					console.info("continuing to draw route without user start location");
					// The instanceConf parameter must always be passed
					this.drawRoute(stops, callback, errorCallback, instanceConf);
				};
				console.log("getting user location");
				this.getUserLocation(dojo.hitch(this, fct), dojo.hitch(this, fctError));
			}
			else
			{
				var _stops = [];
				if (this.isStartWithCurrentLocation(instanceConf) && this.isLocationStatusHasLocation())
				{
					var ul = this._getUserLocationStop(instanceConf);
					ul.calculatedStop = true;
					ul.calculatedStopType = ibm.tivoli.fwm.mxmap.routing.CalculatedStops.USER_LOCATION_STOP;
					_stops.push(ul);
				}
				else
				{
					var startLocation = this.startLocation;
					if (instanceConf && instanceConf.startLocation != null)
					{
						startLocation = instanceConf.startLocation;
					}
					if (startLocation && startLocation.hasOwnProperty("lat") && startLocation.lat != null)
					{
						startLocation.calculatedStop = true;
						startLocation.calculatedStopType = ibm.tivoli.fwm.mxmap.routing.CalculatedStops.CONF_START_STOP;
						_stops.push(startLocation);
					}
				}

				_stops = _stops.concat(stops);
				var endLocation = this.endLocation;
				if (instanceConf && instanceConf.endLocation != null)
				{
					endLocation = instanceConf.endLocation;
				}
				if (endLocation && endLocation.hasOwnProperty("lat") && endLocation.lat != null)
				{
					endLocation.calculatedStop = true;
					endLocation.calculatedStopType = ibm.tivoli.fwm.mxmap.routing.CalculatedStops.CONF_END_STOP;
					_stops.push(endLocation);
				}
				if (_stops.length < 2)
				{
					console.warn("at least 2 stops are needed");
					errorCallback(ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.MIN_STOPS_REQ, "at least 2 stops are needed");
					return;
				}
				this.showRoute(_stops, callback, errorCallback, true, instanceConf);
			}
		}));
	},
	
	/**
	 * this is the extension point of routing. All implementations must override
	 * this method
	 * 
	 * @param stops
	 * @param cb
	 * @param errcb
	 */
	showRoute: function(stops, cb, errcb, zoomToRoute)
	{
		throw "No showRoute implementation";
	},
	isStartWithCurrentLocation: function(instanceConf)
	{
		if (instanceConf && instanceConf.startithcurrentlocation)
		{
			return instanceConf.startwithcurrentlocation == "true";
		}
		else
		{
			return this.startwithcurrentlocation == "true";
		}
	},
	isOptimizeRoute: function()
	{
		return this.optimizeroute == "true";
	},

	destroyRecursive: function()
	{
		this.inherited(arguments);
	},

	getCurrentDistanceUnit: function()
	{
		if (this.customConf)
		{
			return this.customConf.distanceUnit;
		}
		else
		{
			return ibm.tivoli.fwm.mxmap.routing.DistanceUnit.KM;
		}

	},
	getAvoidHighways: function()
	{
		if (this.customConf)
		{
			return this.customConf.avoidHighway;
		}
		return false;

	},
	getAvoidTolls: function()
	{
		if (this.customConf)
		{
			return this.customConf.avoidToll;
		}
		return false;

	},
	/**
	 * The code below is only for evaluating route performance.
	 */
	timers: null,
	_startTimer: function()
	{
		try
		{
			if (dojo.config.fwm.debug == true)
			{
				if (this.timers == null)
				{
					this.timers = [];
				}

				this.timers.push(new Date().getTime());
				return this.timers.length - 1;
			}
			return -1;
		}
		catch (e)
		{
			console.log("error starting timer", e);
		}
	},

	_stopTimer: function(h, total)
	{
		try
		{
			if (dojo.config.fwm.debug == true)
			{
				var endt = new Date().getTime();
				if (h == null)
				{
					console.info("Total routing time for " + total + " stops in (s) ", (endt - this.timers[0]) / 1000);
					this.timers = null;
				}
				else
				{
					console.log("Route step routing time for " + total + " stops in (s) ", (endt - this.timers[h]) / 1000);
				}
			}
		}
		catch (e)
		{
			console.log("error stopping timer", e);
		}
	}

});

});

},
'ibm/tivoli/fwm/mxmap/impl/polyline/GmapsPolyline':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Polyline"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

dojo.require("ibm.tivoli.fwm.mxmap._Polyline");
dojo.provide("ibm.tivoli.fwm.mxmap.impl.polyline.GmapsPolyline");

/**
 * GmapsPolyline
 */
dojo.declare("ibm.tivoli.fwm.mxmap.impl.polyline.GmapsPolyline", ibm.tivoli.fwm.mxmap._Polyline, {
	
	toProprietary: function()
	{
		var points = [];
		for ( var i = 0; i < this.points.length; i++)
		{
			points.push(this.points[i].toProprietary('googlev3'));
		}
		var polyline = null;
		/* if it is closed, created a polygon */
		if (this.closed && this.closed == true)
		{
			var polygonOptions = {
				paths: [ points ],
				fillColor: this.fillColor || '#000000',
				fillOpacy: this.opacity || 1.0,
				strokeColor: this.color || '#000000',
				strokeOpacity: this.borderOpacity || 1.0,
				strokeWeight: this.width || 3,
				clickable: false,
				editable: false
			};
			polyline = new google.maps.Polygon(polygonOptions);
		}
		else
		{
			var polyOptions = {
				path: points,
				strokeColor: this.color || '#000000',
				strokeOpacity: this.opacity || 1.0,
				strokeWeight: this.width || 3,
				clickable: false
			};

			polyline = new google.maps.Polyline(polyOptions);
		}

		return polyline;
	}

});

});

},
'dijit/form/Button':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"require",
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"dojo/has", // has("dijit-legacy-requires")
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.trim
	"dojo/ready",
	"./_FormWidget",
	"./_ButtonMixin",
	"dojo/text!./templates/Button.html",
	"../a11yclick"	// template uses ondijitclick
], function(require, declare, domClass, has, kernel, lang, ready, _FormWidget, _ButtonMixin, template){

	// module:
	//		dijit/form/Button

	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/form/DropDownButton", "dijit/form/ComboButton", "dijit/form/ToggleButton"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	var Button = declare("dijit.form.Button" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormWidget, _ButtonMixin], {
		// summary:
		//		Basically the same thing as a normal HTML button, but with special styling.
		// description:
		//		Buttons can display a label, an icon, or both.
		//		A label should always be specified (through innerHTML) or the label
		//		attribute.  It can be hidden via showLabel=false.
		// example:
		// |	<button data-dojo-type="dijit/form/Button" onClick="...">Hello world</button>
		//
		// example:
		// |	var button1 = new Button({label: "hello world", onClick: foo});
		// |	dojo.body().appendChild(button1.domNode);

		// showLabel: Boolean
		//		Set this to true to hide the label text and display only the icon.
		//		(If showLabel=false then iconClass must be specified.)
		//		Especially useful for toolbars.
		//		If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
		//
		//		The exception case is for computers in high-contrast mode, where the label
		//		will still be displayed, since the icon doesn't appear.
		showLabel: true,

		// iconClass: String
		//		Class to apply to DOMNode in button to make it display an icon
		iconClass: "dijitNoIcon",
		_setIconClassAttr: { node: "iconNode", type: "class" },

		baseClass: "dijitButton",

		templateString: template,

		// Map widget attributes to DOMNode attributes.
		_setValueAttr: "valueNode",
		_setNameAttr: function(name){
			// avoid breaking existing subclasses where valueNode undefined.  Perhaps in 2.0 require it to be defined?
			if(this.valueNode){
				this.valueNode.setAttribute("name", name);
			}
		},

		postCreate: function(){
			this.inherited(arguments);
			this._setLabelFromContainer();
		},

		_setLabelFromContainer: function(){
			if(this.containerNode && !this.label){
				// When markup was set as srcNodeRef.innerHTML, copy it to this.label, in case someone tries to
				// reference that variable.  Alternately, could have a _getLabelAttr() method to return
				// this.containerNode.innerHTML.
				this.label = lang.trim(this.containerNode.innerHTML);
				this.onLabelSet();		// set this.titleNode.title etc. according to label
			}
		},

		_setShowLabelAttr: function(val){
			if(this.containerNode){
				domClass.toggle(this.containerNode, "dijitDisplayNone", !val);
			}
			this._set("showLabel", val);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.  Use set('label', ...) instead.
			kernel.deprecated("dijit.form.Button.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
			this.set("label", content);
		},

		onLabelSet: function(){
			this.inherited(arguments);
			if(!this.showLabel && !("title" in this.params)){
				this.titleNode.title = lang.trim(this.containerNode.innerText || this.containerNode.textContent || '');
			}
		}
	});

	if(has("dojo-bidi")){
		Button = declare("dijit.form.Button", Button, {
			onLabelSet: function(){
				this.inherited(arguments);
				if(this.titleNode.title){
					this.applyTextDir(this.titleNode, this.titleNode.title);
				}
			},

			_setTextDirAttr: function(/*String*/ textDir){
				if(this._created && this.textDir != textDir){
					this._set("textDir", textDir);
					this._setLabelAttr(this.label); // call applyTextDir on both focusNode and titleNode
				}
			}
		});
	}

	return Button;
});

},
'dijit/_WidgetBase':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"require", // require.toUrl
	"dojo/_base/array", // array.forEach array.map
	"dojo/aspect",
	"dojo/_base/config", // config.blankGif
	"dojo/_base/connect", // connect.connect
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/dom-attr", // domAttr.set domAttr.remove
	"dojo/dom-class", // domClass.add domClass.replace
	"dojo/dom-construct", // domConstruct.destroy domConstruct.place
	"dojo/dom-geometry", // isBodyLtr
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/has",
	"dojo/_base/kernel",
	"dojo/_base/lang", // mixin(), isArray(), etc.
	"dojo/on",
	"dojo/ready",
	"dojo/Stateful", // Stateful
	"dojo/topic",
	"dojo/_base/window", // win.body()
	"./Destroyable",
	"dojo/has!dojo-bidi?./_BidiMixin",
	"./registry"    // registry.getUniqueId(), registry.findWidgets()
], function(require, array, aspect, config, connect, declare,
			dom, domAttr, domClass, domConstruct, domGeometry, domStyle, has, kernel,
			lang, on, ready, Stateful, topic, win, Destroyable, _BidiMixin, registry){

	// module:
	//		dijit/_WidgetBase

	// Flag to make dijit load modules the app didn't explicitly request, for backwards compatibility
	has.add("dijit-legacy-requires", !kernel.isAsync);

	// Flag to enable support for textdir attribute
	has.add("dojo-bidi", false);


	// For back-compat, remove in 2.0.
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/_base/manager"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	// Nested hash listing attributes for each tag, all strings in lowercase.
	// ex: {"div": {"style": true, "tabindex" true}, "form": { ...
	var tagAttrs = {};

	function getAttrs(obj){
		var ret = {};
		for(var attr in obj){
			ret[attr.toLowerCase()] = true;
		}
		return ret;
	}

	function nonEmptyAttrToDom(attr){
		// summary:
		//		Returns a setter function that copies the attribute to this.domNode,
		//		or removes the attribute from this.domNode, depending on whether the
		//		value is defined or not.
		return function(val){
			domAttr[val ? "set" : "remove"](this.domNode, attr, val);
			this._set(attr, val);
		};
	}

	function isEqual(a, b){
		//	summary:
		//		Function that determines whether two values are identical,
		//		taking into account that NaN is not normally equal to itself
		//		in JS.

		return a === b || (/* a is NaN */ a !== a && /* b is NaN */ b !== b);
	}

	var _WidgetBase = declare("dijit._WidgetBase", [Stateful, Destroyable], {
		// summary:
		//		Future base class for all Dijit widgets.
		// description:
		//		Future base class for all Dijit widgets.
		//		_Widget extends this class adding support for various features needed by desktop.
		//
		//		Provides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),
		//		postCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().
		//
		//		Widgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).
		//		For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
		//
		//		_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget's DOMNodes:
		//
		//		- DOM node attribute
		// |		_setFocusAttr: {node: "focusNode", type: "attribute"}
		// |		_setFocusAttr: "focusNode"	(shorthand)
		// |		_setFocusAttr: ""		(shorthand, maps to this.domNode)
		//		Maps this.focus to this.focusNode.focus, or (last example) this.domNode.focus
		//
		//		- DOM node innerHTML
		//	|		_setTitleAttr: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		_setTitleAttr: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		_setMyClassAttr: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		- Toggle DOM node CSS class
		// |		_setMyClassAttr: { node: "domNode", type: "toggleClass" }
		//		Toggles myClass on this.domNode by this.myClass
		//
		//		If the value of _setXXXAttr is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		If the custom setter is null, no action is performed other than saving the new value
		//		in the widget (in this).
		//
		//		If no custom setter is defined for an attribute, then it will be copied
		//		to this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.
		//		That's only done though for attributes that match DOMNode attributes (title,
		//		alt, aria-labelledby, etc.)

		// id: [const] String
		//		A unique, opaque ID string that can be assigned by users or by the
		//		system. If the developer passes an ID which is known not to be
		//		unique, the specified ID is ignored and the system-generated ID is
		//		used instead.
		id: "",
		_setIdAttr: "domNode", // to copy to this.domNode even for auto-generated id's

		// lang: [const] String
		//		Rarely used.  Overrides the default Dojo locale used to render this widget,
		//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
		//		Value must be among the list of locales specified during by the Dojo bootstrap,
		//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
		lang: "",
		// set on domNode even when there's a focus node.	but don't set lang="", since that's invalid.
		_setLangAttr: nonEmptyAttrToDom("lang"),

		// dir: [const] String
		//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
		//		attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
		//		default direction.
		dir: "",
		// set on domNode even when there's a focus node.	but don't set dir="", since that's invalid.
		_setDirAttr: nonEmptyAttrToDom("dir"), // to set on domNode even when there's a focus node

		// class: String
		//		HTML class attribute
		"class": "",
		_setClassAttr: { node: "domNode", type: "class" },

		// Override automatic assigning type --> focusNode, it causes exception on IE6-8.
		// Instead, type must be specified as ${type} in the template, as part of the original DOM.
		_setTypeAttr: null,

		// style: String||Object
		//		HTML style attributes as cssText string or name/value hash
		style: "",

		// title: String
		//		HTML title attribute.
		//
		//		For form widgets this specifies a tooltip to display when hovering over
		//		the widget (just like the native HTML title attribute).
		//
		//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
		//		etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
		//		interpreted as HTML.
		title: "",

		// tooltip: String
		//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
		//		this specifies the tooltip to appear when the mouse is hovered over that text.
		tooltip: "",

		// baseClass: [protected] String
		//		Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
		//		widget state.
		baseClass: "",

		// srcNodeRef: [readonly] DomNode
		//		pointer to original DOM node
		srcNodeRef: null,

		// domNode: [readonly] DomNode
		//		This is our visible representation of the widget! Other DOM
		//		Nodes may by assigned to other properties, usually through the
		//		template system's data-dojo-attach-point syntax, but the domNode
		//		property is the canonical "top level" node in widget UI.
		domNode: null,

		// containerNode: [readonly] DomNode
		//		Designates where children of the source DOM node will be placed.
		//		"Children" in this case refers to both DOM nodes and widgets.
		//		For example, for myWidget:
		//
		//		|	<div data-dojo-type=myWidget>
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//		|	</div>
		//
		//		containerNode would point to:
		//
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//
		//		In templated widgets, "containerNode" is set via a
		//		data-dojo-attach-point assignment.
		//
		//		containerNode must be defined for any widget that accepts innerHTML
		//		(like ContentPane or BorderContainer or even Button), and conversely
		//		is null for widgets that don't, like TextBox.
		containerNode: null,

		// ownerDocument: [const] Document?
		//		The document this widget belongs to.  If not specified to constructor, will default to
		//		srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
		ownerDocument: null,
		_setOwnerDocumentAttr: function(val){
			// this setter is merely to avoid automatically trying to set this.domNode.ownerDocument
			this._set("ownerDocument", val);
		},

		/*=====
		// _started: [readonly] Boolean
		//		startup() has completed.
		_started: false,
		=====*/

		// attributeMap: [protected] Object
		//		Deprecated.	Instead of attributeMap, widget should have a _setXXXAttr attribute
		//		for each XXX attribute to be mapped to the DOM.
		//
		//		attributeMap sets up a "binding" between attributes (aka properties)
		//		of the widget and the widget's DOM.
		//		Changes to widget attributes listed in attributeMap will be
		//		reflected into the DOM.
		//
		//		For example, calling set('title', 'hello')
		//		on a TitlePane will automatically cause the TitlePane's DOM to update
		//		with the new title.
		//
		//		attributeMap is a hash where the key is an attribute of the widget,
		//		and the value reflects a binding to a:
		//
		//		- DOM node attribute
		// |		focus: {node: "focusNode", type: "attribute"}
		//		Maps this.focus to this.focusNode.focus
		//
		//		- DOM node innerHTML
		//	|		title: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		title: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		myClass: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		If the value is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		There are also some shorthands for backwards compatibility:
		//
		//		- string --> { node: string, type: "attribute" }, for example:
		//
		//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
		//
		//		- "" --> { node: "domNode", type: "attribute" }
		attributeMap: {},

		// _blankGif: [protected] String
		//		Path to a blank 1x1 image.
		//		Used by `<img>` nodes in templates that really get their image via CSS background-image.
		_blankGif: config.blankGif || require.toUrl("dojo/resources/blank.gif"),

		// textDir: String
		//		Bi-directional support,	the main variable which is responsible for the direction of the text.
		//		The text direction can be different than the GUI direction by using this parameter in creation
		//		of a widget.
		//
		//		This property is only effective when `has("dojo-bidi")` is defined to be true.
		//
		//		Allowed values:
		//
		//		1. "" - default value; text is same direction as widget
		//		2. "ltr"
		//		3. "rtl"
		//		4. "auto" - contextual the direction of a text defined by first strong letter.
		textDir: "",

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		/*=====
		constructor: function(params, srcNodeRef){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
		},
		=====*/

		_introspect: function(){
			// summary:
			//		Collect metadata about this widget (only once per class, not once per instance):
			//
			//			- list of attributes with custom setters, storing in this.constructor._setterAttrs
			//			- generate this.constructor._onMap, mapping names like "mousedown" to functions like onMouseDown

			var ctor = this.constructor;
			if(!ctor._setterAttrs){
				var proto = ctor.prototype,
					attrs = ctor._setterAttrs = [], // attributes with custom setters
					onMap = (ctor._onMap = {});

				// Items in this.attributeMap are like custom setters.  For back-compat, remove for 2.0.
				for(var name in proto.attributeMap){
					attrs.push(name);
				}

				// Loop over widget properties, collecting properties with custom setters and filling in ctor._onMap.
				for(name in proto){
					if(/^on/.test(name)){
						onMap[name.substring(2).toLowerCase()] = name;
					}

					if(/^_set[A-Z](.*)Attr$/.test(name)){
						name = name.charAt(4).toLowerCase() + name.substr(5, name.length - 9);
						if(!proto.attributeMap || !(name in proto.attributeMap)){
							attrs.push(name);
						}
					}
				}

				// Note: this isn't picking up info on properties like aria-label and role, that don't have custom setters
				// but that set() maps to attributes on this.domNode or this.focusNode
			}
		},

		postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
			// summary:
			//		Kicks off widget instantiation.  See create() for details.
			// tags:
			//		private

			// Note that we skip calling this.inherited(), i.e. dojo/Stateful::postscript(), because 1.x widgets don't
			// expect their custom setters to get called until after buildRendering().  Consider changing for 2.0.

			this.create(params, srcNodeRef);
		},

		create: function(params, srcNodeRef){
			// summary:
			//		Kick off the life-cycle of a widget
			// description:
			//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
			//		etc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html
			//		for a discussion of the widget creation lifecycle.
			//
			//		Of course, adventurous developers could override create entirely, but this should
			//		only be done as a last resort.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
			// tags:
			//		private

			// First time widget is instantiated, scan prototype to figure out info about custom setters etc.
			this._introspect();

			// store pointer to original DOM tree
			this.srcNodeRef = dom.byId(srcNodeRef);

			// No longer used, remove for 2.0.
			this._connects = [];
			this._supportingWidgets = [];

			// this is here for back-compat, remove in 2.0 (but check NodeList-instantiate.html test)
			if(this.srcNodeRef && this.srcNodeRef.id  && (typeof this.srcNodeRef.id == "string")){
				this.id = this.srcNodeRef.id;
			}

			// mix in our passed parameters
			if(params){
				this.params = params;
				lang.mixin(this, params);
			}
			this.postMixInProperties();

			// Generate an id for the widget if one wasn't specified, or it was specified as id: undefined.
			// Do this before buildRendering() because it might expect the id to be there.
			if(!this.id){
				this.id = registry.getUniqueId(this.declaredClass.replace(/\./g, "_"));
				if(this.params){
					// if params contains {id: undefined}, prevent _applyAttributes() from processing it
					delete this.params.id;
				}
			}

			// The document and <body> node this widget is associated with
			this.ownerDocument = this.ownerDocument || (this.srcNodeRef ? this.srcNodeRef.ownerDocument : document);
			this.ownerDocumentBody = win.body(this.ownerDocument);

			registry.add(this);

			this.buildRendering();

			var deleteSrcNodeRef;

			if(this.domNode){
				// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
				// Also calls custom setters for all attributes with custom setters.
				this._applyAttributes();

				// If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
				// For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
				// widget being attached to the DOM since it isn't when a widget is created programmatically like
				// new MyWidget({}).	See #11635.
				var source = this.srcNodeRef;
				if(source && source.parentNode && this.domNode !== source){
					source.parentNode.replaceChild(this.domNode, source);
					deleteSrcNodeRef = true;
				}

				// Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
				// assuming that dojo._scopeName even exists in 2.0
				this.domNode.setAttribute("widgetId", this.id);
			}
			this.postCreate();

			// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
			// I think for back-compatibility it isn't deleting srcNodeRef until after postCreate() has run.
			if(deleteSrcNodeRef){
				delete this.srcNodeRef;
			}

			this._created = true;
		},

		_applyAttributes: function(){
			// summary:
			//		Step during widget creation to copy  widget attributes to the
			//		DOM according to attributeMap and _setXXXAttr objects, and also to call
			//		custom _setXXXAttr() methods.
			//
			//		Skips over blank/false attribute values, unless they were explicitly specified
			//		as parameters to the widget, since those are the default anyway,
			//		and setting tabIndex="" is different than not setting tabIndex at all.
			//
			//		For backwards-compatibility reasons attributeMap overrides _setXXXAttr when
			//		_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.
			// tags:
			//		private

			// Call this.set() for each property that was either specified as parameter to constructor,
			// or is in the list found above.	For correlated properties like value and displayedValue, the one
			// specified as a parameter should take precedence.
			// Particularly important for new DateTextBox({displayedValue: ...}) since DateTextBox's default value is
			// NaN and thus is not ignored like a default value of "".

			// Step 1: Save the current values of the widget properties that were specified as parameters to the constructor.
			// Generally this.foo == this.params.foo, except if postMixInProperties() changed the value of this.foo.
			var params = {};
			for(var key in this.params || {}){
				params[key] = this._get(key);
			}

			// Step 2: Call set() for each property with a non-falsy value that wasn't passed as a parameter to the constructor
			array.forEach(this.constructor._setterAttrs, function(key){
				if(!(key in params)){
					var val = this._get(key);
					if(val){
						this.set(key, val);
					}
				}
			}, this);

			// Step 3: Call set() for each property that was specified as parameter to constructor.
			// Use params hash created above to ignore side effects from step #2 above.
			for(key in params){
				this.set(key, params[key]);
			}
		},

		postMixInProperties: function(){
			// summary:
			//		Called after the parameters to the widget have been read-in,
			//		but before the widget template is instantiated. Especially
			//		useful to set properties that are referenced in the widget
			//		template.
			// tags:
			//		protected
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget, setting this.domNode.
			//		Most widgets will mixin `dijit._TemplatedMixin`, which implements this method.
			// tags:
			//		protected

			if(!this.domNode){
				// Create root node if it wasn't created by _TemplatedMixin
				this.domNode = this.srcNodeRef || this.ownerDocument.createElement("div");
			}

			// baseClass is a single class name or occasionally a space-separated list of names.
			// Add those classes to the DOMNode.  If RTL mode then also add with Rtl suffix.
			// TODO: make baseClass custom setter
			if(this.baseClass){
				var classes = this.baseClass.split(" ");
				if(!this.isLeftToRight()){
					classes = classes.concat(array.map(classes, function(name){
						return name + "Rtl";
					}));
				}
				domClass.add(this.domNode, classes);
			}
		},

		postCreate: function(){
			// summary:
			//		Processing after the DOM fragment is created
			// description:
			//		Called after the DOM fragment has been created, but not necessarily
			//		added to the document.  Do not include any operations which rely on
			//		node dimensions or placement.
			// tags:
			//		protected
		},

		startup: function(){
			// summary:
			//		Processing after the DOM fragment is added to the document
			// description:
			//		Called after a widget and its children have been created and added to the page,
			//		and all related widgets have finished their create() cycle, up through postCreate().
			//
			//		Note that startup() may be called while the widget is still hidden, for example if the widget is
			//		inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
			//		For widgets that need to do layout, it's best to put that layout code inside resize(), and then
			//		extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
			if(this._started){
				return;
			}
			this._started = true;
			array.forEach(this.getChildren(), function(obj){
				if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			});
		},

		//////////// DESTROY FUNCTIONS ////////////////////////////////

		destroyRecursive: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroy this widget and its descendants
			// description:
			//		This is the generic "destructor" function that all widget users
			//		should call to cleanly discard with a widget. Once a widget is
			//		destroyed, it is removed from the manager object.
			// preserveDom:
			//		If true, this method will leave the original DOM structure
			//		alone of descendant Widgets. Note: This will NOT work with
			//		dijit._TemplatedMixin widgets.

			this._beingDestroyed = true;
			this.destroyDescendants(preserveDom);
			this.destroy(preserveDom);
		},

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this widget, but not its descendants.  Descendants means widgets inside of
			//		this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
			//
			//		This method will also destroy internal widgets such as those created from a template,
			//		assuming those widgets exist inside of this.domNode but outside of this.containerNode.
			//
			//		For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
			//		depend on the current ability to destroy a widget without destroying its descendants.   Generally
			//		they should use destroyRecursive() for widgets with children.
			// preserveDom: Boolean
			//		If true, this method will leave the original DOM structure alone.
			//		Note: This will not yet work with _TemplatedMixin widgets

			this._beingDestroyed = true;
			this.uninitialize();

			function destroy(w){
				if(w.destroyRecursive){
					w.destroyRecursive(preserveDom);
				}else if(w.destroy){
					w.destroy(preserveDom);
				}
			}

			// Back-compat, remove for 2.0
			array.forEach(this._connects, lang.hitch(this, "disconnect"));
			array.forEach(this._supportingWidgets, destroy);

			// Destroy supporting widgets, but not child widgets under this.containerNode (for 2.0, destroy child widgets
			// here too).   if() statement is to guard against exception if destroy() called multiple times (see #15815).
			if(this.domNode){
				array.forEach(registry.findWidgets(this.domNode, this.containerNode), destroy);
			}

			this.destroyRendering(preserveDom);
			registry.remove(this.id);
			this._destroyed = true;
		},

		destroyRendering: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroys the DOM nodes associated with this widget.
			// preserveDom:
			//		If true, this method will leave the original DOM structure alone
			//		during tear-down. Note: this will not work with _Templated
			//		widgets yet.
			// tags:
			//		protected

			if(this.bgIframe){
				this.bgIframe.destroy(preserveDom);
				delete this.bgIframe;
			}

			if(this.domNode){
				if(preserveDom){
					domAttr.remove(this.domNode, "widgetId");
				}else{
					domConstruct.destroy(this.domNode);
				}
				delete this.domNode;
			}

			if(this.srcNodeRef){
				if(!preserveDom){
					domConstruct.destroy(this.srcNodeRef);
				}
				delete this.srcNodeRef;
			}
		},

		destroyDescendants: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Recursively destroy the children of this widget and their
			//		descendants.
			// preserveDom:
			//		If true, the preserveDom attribute is passed to all descendant
			//		widget's .destroy() method. Not for use with _Templated
			//		widgets.

			// get all direct descendants and destroy them recursively
			array.forEach(this.getChildren(), function(widget){
				if(widget.destroyRecursive){
					widget.destroyRecursive(preserveDom);
				}
			});
		},

		uninitialize: function(){
			// summary:
			//		Deprecated. Override destroy() instead to implement custom widget tear-down
			//		behavior.
			// tags:
			//		protected
			return false;
		},

		////////////////// GET/SET, CUSTOM SETTERS, ETC. ///////////////////

		_setStyleAttr: function(/*String||Object*/ value){
			// summary:
			//		Sets the style attribute of the widget according to value,
			//		which is either a hash like {height: "5px", width: "3px"}
			//		or a plain string
			// description:
			//		Determines which node to set the style on based on style setting
			//		in attributeMap.
			// tags:
			//		protected

			var mapNode = this.domNode;

			// Note: technically we should revert any style setting made in a previous call
			// to his method, but that's difficult to keep track of.

			if(lang.isObject(value)){
				domStyle.set(mapNode, value);
			}else{
				if(mapNode.style.cssText){
					mapNode.style.cssText += "; " + value;
				}else{
					mapNode.style.cssText = value;
				}
			}

			this._set("style", value);
		},

		_attrToDom: function(/*String*/ attr, /*String*/ value, /*Object?*/ commands){
			// summary:
			//		Reflect a widget attribute (title, tabIndex, duration etc.) to
			//		the widget DOM, as specified by commands parameter.
			//		If commands isn't specified then it's looked up from attributeMap.
			//		Note some attributes like "type"
			//		cannot be processed this way as they are not mutable.
			// attr:
			//		Name of member variable (ex: "focusNode" maps to this.focusNode) pointing
			//		to DOMNode inside the widget, or alternately pointing to a subwidget
			// tags:
			//		private

			commands = arguments.length >= 3 ? commands : this.attributeMap[attr];

			array.forEach(lang.isArray(commands) ? commands : [commands], function(command){

				// Get target node and what we are doing to that node
				var mapNode = this[command.node || command || "domNode"];	// DOM node
				var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute

				switch(type){
					case "attribute":
						if(lang.isFunction(value)){ // functions execute in the context of the widget
							value = lang.hitch(this, value);
						}

						// Get the name of the DOM node attribute; usually it's the same
						// as the name of the attribute in the widget (attr), but can be overridden.
						// Also maps handler names to lowercase, like onSubmit --> onsubmit
						var attrName = command.attribute ? command.attribute :
							(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);

						if(mapNode.tagName){
							// Normal case, mapping to a DOMNode.  Note that modern browsers will have a mapNode.set()
							// method, but for consistency we still call domAttr
							domAttr.set(mapNode, attrName, value);
						}else{
							// mapping to a sub-widget
							mapNode.set(attrName, value);
						}
						break;
					case "innerText":
						// Deprecated, use "textContent" instead.
						mapNode.innerHTML = "";
						mapNode.appendChild(this.ownerDocument.createTextNode(value));
						break;
					case "textContent":
						mapNode.textContent = value;
						break;
					case "innerHTML":
						mapNode.innerHTML = value;
						break;
					case "class":
						domClass.replace(mapNode, value, this[attr]);
						break;
					case "toggleClass":
						domClass.toggle(mapNode, command.className || attr, value);
						break;
				}
			}, this);
		},

		get: function(name){
			// summary:
			//		Get a property from a widget.
			// name:
			//		The property to get.
			// description:
			//		Get a named property from a widget. The property may
			//		potentially be retrieved via a getter method. If no getter is defined, this
			//		just retrieves the object's property.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_getFooAttr()`, calling:
			//		`myWidget.get("foo")` would be equivalent to calling
			//		`widget._getFooAttr()` and `myWidget.get("bar")`
			//		would be equivalent to the expression
			//		`widget.bar2`
			var names = this._getAttrNames(name);
			return this[names.g] ? this[names.g]() : this._get(name);
		},

		set: function(name, value){
			// summary:
			//		Set a property on a widget
			// name:
			//		The property to set.
			// value:
			//		The value to set in the property.
			// description:
			//		Sets named properties on a widget which may potentially be handled by a
			//		setter in the widget.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_setFooAttr()`, calling
			//		`myWidget.set("foo", "Howdy!")` would be equivalent to calling
			//		`widget._setFooAttr("Howdy!")` and `myWidget.set("bar", 3)`
			//		would be equivalent to the statement `widget.bar = 3;`
			//
			//		set() may also be called with a hash of name/value pairs, ex:
			//
			//	|	myWidget.set({
			//	|		foo: "Howdy",
			//	|		bar: 3
			//	|	});
			//
			//	This is equivalent to calling `set(foo, "Howdy")` and `set(bar, 3)`

			if(typeof name === "object"){
				for(var x in name){
					this.set(x, name[x]);
				}
				return this;
			}
			var names = this._getAttrNames(name),
				setter = this[names.s];
			if(lang.isFunction(setter)){
				// use the explicit setter
				var result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
			}else{
				// Mapping from widget attribute to DOMNode/subwidget attribute/value/etc.
				// Map according to:
				//		1. attributeMap setting, if one exists (TODO: attributeMap deprecated, remove in 2.0)
				//		2. _setFooAttr: {...} type attribute in the widget (if one exists)
				//		3. apply to focusNode or domNode if standard attribute name, excluding funcs like onClick.
				// Checks if an attribute is a "standard attribute" by whether the DOMNode JS object has a similar
				// attribute name (ex: accept-charset attribute matches jsObject.acceptCharset).
				// Note also that Tree.focusNode() is a function not a DOMNode, so test for that.
				var defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? "focusNode" : "domNode",
					tag = this[defaultNode] && this[defaultNode].tagName,
					attrsForTag = tag && (tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode]))),
					map = name in this.attributeMap ? this.attributeMap[name] :
						names.s in this ? this[names.s] :
							((attrsForTag && names.l in attrsForTag && typeof value != "function") ||
								/^aria-|^data-|^role$/.test(name)) ? defaultNode : null;
				if(map != null){
					this._attrToDom(name, value, map);
				}
				this._set(name, value);
			}
			return result || this;
		},

		_attrPairNames: {}, // shared between all widgets
		_getAttrNames: function(name){
			// summary:
			//		Helper function for get() and set().
			//		Caches attribute name values so we don't do the string ops every time.
			// tags:
			//		private

			var apn = this._attrPairNames;
			if(apn[name]){
				return apn[name];
			}
			var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function(c){
				return c.charAt(c.length - 1).toUpperCase();
			});
			return (apn[name] = {
				n: name + "Node",
				s: "_set" + uc + "Attr", // converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
				g: "_get" + uc + "Attr",
				l: uc.toLowerCase()        // lowercase name w/out dashes, ex: acceptcharset
			});
		},

		_set: function(/*String*/ name, /*anything*/ value){
			// summary:
			//		Helper function to set new value for specified property, and call handlers
			//		registered with watch() if the value has changed.
			var oldValue = this[name];
			this[name] = value;
			if(this._created && !isEqual(oldValue, value)){
				if(this._watchCallbacks){
					this._watchCallbacks(name, oldValue, value);
				}
				this.emit("attrmodified-" + name, {
					detail: {
						prevValue: oldValue,
						newValue: value
					}
				});
			}
		},

		_get: function(/*String*/ name){
			// summary:
			//		Helper function to get value for specified property stored by this._set(),
			//		i.e. for properties with custom setters.  Used mainly by custom getters.
			//
			//		For example, CheckBox._getValueAttr() calls this._get("value").

			// future: return name in this.props ? this.props[name] : this[name];
			return this[name];
		},

		emit: function(/*String*/ type, /*Object?*/ eventObj, /*Array?*/ callbackArgs){
			// summary:
			//		Used by widgets to signal that a synthetic event occurred, ex:
			//	|	myWidget.emit("attrmodified-selectedChildWidget", {}).
			//
			//		Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
			//		Also calls onType() method, if present, and returns value from that method.
			//		By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
			//		Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
			// tags:
			//		protected

			// Specify fallback values for bubbles, cancelable in case they are not set in eventObj.
			// Also set pointer to widget, although since we can't add a pointer to the widget for native events
			// (see #14729), maybe we shouldn't do it here?
			eventObj = eventObj || {};
			if(eventObj.bubbles === undefined){
				eventObj.bubbles = true;
			}
			if(eventObj.cancelable === undefined){
				eventObj.cancelable = true;
			}
			if(!eventObj.detail){
				eventObj.detail = {};
			}
			eventObj.detail.widget = this;

			var ret, callback = this["on" + type];
			if(callback){
				ret = callback.apply(this, callbackArgs ? callbackArgs : [eventObj]);
			}

			// Emit event, but avoid spurious emit()'s as parent sets properties on child during startup/destroy
			if(this._started && !this._beingDestroyed){
				on.emit(this.domNode, type.toLowerCase(), eventObj);
			}

			return ret;
		},

		on: function(/*String|Function*/ type, /*Function*/ func){
			// summary:
			//		Call specified function when event occurs, ex: myWidget.on("click", function(){ ... }).
			// type:
			//		Name of event (ex: "click") or extension event like touch.press.
			// description:
			//		Call specified function when event `type` occurs, ex: `myWidget.on("click", function(){ ... })`.
			//		Note that the function is not run in any particular scope, so if (for example) you want it to run in the
			//		widget's scope you must do `myWidget.on("click", lang.hitch(myWidget, func))`.

			// For backwards compatibility, if there's an onType() method in the widget then connect to that.
			// Remove in 2.0.
			var widgetMethod = this._onMap(type);
			if(widgetMethod){
				return aspect.after(this, widgetMethod, func, true);
			}

			// Otherwise, just listen for the event on this.domNode.
			return this.own(on(this.domNode, type, func))[0];
		},

		_onMap: function(/*String|Function*/ type){
			// summary:
			//		Maps on() type parameter (ex: "mousemove") to method name (ex: "onMouseMove").
			//		If type is a synthetic event like touch.press then returns undefined.
			var ctor = this.constructor, map = ctor._onMap;
			if(!map){
				map = (ctor._onMap = {});
				for(var attr in ctor.prototype){
					if(/^on/.test(attr)){
						map[attr.replace(/^on/, "").toLowerCase()] = attr;
					}
				}
			}
			return map[typeof type == "string" && type.toLowerCase()];	// String
		},

		toString: function(){
			// summary:
			//		Returns a string that represents the widget.
			// description:
			//		When a widget is cast to a string, this method will be used to generate the
			//		output. Currently, it does not implement any sort of reversible
			//		serialization.
			return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
		},

		getChildren: function(){
			// summary:
			//		Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
			//		is this widget.   Note that it does not return all descendants, but rather just direct children.
			//		Analogous to [Node.childNodes](https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes),
			//		except containing widgets rather than DOMNodes.
			//
			//		The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
			//		outside of this.containerNode.
			//
			//		Note that the array returned is a simple array.  Application code should not assume
			//		existence of methods like forEach().

			return this.containerNode ? registry.findWidgets(this.containerNode) : []; // dijit/_WidgetBase[]
		},

		getParent: function(){
			// summary:
			//		Returns the parent widget of this widget.

			return registry.getEnclosingWidget(this.domNode.parentNode);
		},

		connect: function(/*Object|null*/ obj, /*String|Function*/ event, /*String|Function*/ method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
			//
			//		Connects specified obj/event to specified method of this object
			//		and registers for disconnect() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.connect, except with the
			//		implicit use of this widget as the target object.
			//		Events connected with `this.connect` are disconnected upon
			//		destruction.
			// returns:
			//		A handle that can be passed to `disconnect` in order to disconnect before
			//		the widget is destroyed.
			// example:
			//	|	var btn = new Button();
			//	|	// when foo.bar() is called, call the listener we're going to
			//	|	// provide in the scope of btn
			//	|	btn.connect(foo, "bar", function(){
			//	|		console.debug(this.toString());
			//	|	});
			// tags:
			//		protected

			return this.own(connect.connect(obj, event, this, method))[0];	// handle
		},

		disconnect: function(handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Disconnects handle created by `connect`.
			// tags:
			//		protected

			handle.remove();
		},

		subscribe: function(t, method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
			//
			//		Subscribes to the specified topic and calls the specified method
			//		of this object and registers for unsubscribe() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.subscribe, except with the
			//		implicit use of this widget as the target object.
			// t: String
			//		The topic
			// method: Function
			//		The callback
			// example:
			//	|	var btn = new Button();
			//	|	// when /my/topic is published, this button changes its label to
			//	|	// be the parameter of the topic.
			//	|	btn.subscribe("/my/topic", function(v){
			//	|		this.set("label", v);
			//	|	});
			// tags:
			//		protected
			return this.own(topic.subscribe(t, lang.hitch(this, method)))[0];	// handle
		},

		unsubscribe: function(/*Object*/ handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Unsubscribes handle created by this.subscribe.
			//		Also removes handle from this widget's list of subscriptions
			// tags:
			//		protected

			handle.remove();
		},

		isLeftToRight: function(){
			// summary:
			//		Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
			// tags:
			//		protected
			return this.dir ? (this.dir.toLowerCase() == "ltr") : domGeometry.isBodyLtr(this.ownerDocument); //Boolean
		},

		isFocusable: function(){
			// summary:
			//		Return true if this widget can currently be focused
			//		and false if not
			return this.focus && (domStyle.get(this.domNode, "display") != "none");
		},

		placeAt: function(/*String|DomNode|DocumentFragment|dijit/_WidgetBase*/ reference, /*String|Int?*/ position){
			// summary:
			//		Place this widget somewhere in the DOM based
			//		on standard domConstruct.place() conventions.
			// description:
			//		A convenience function provided in all _Widgets, providing a simple
			//		shorthand mechanism to put an existing (or newly created) Widget
			//		somewhere in the dom, and allow chaining.
			// reference:
			//		Widget, DOMNode, DocumentFragment, or id of widget or DOMNode
			// position:
			//		If reference is a widget (or id of widget), and that widget has an ".addChild" method,
			//		it will be called passing this widget instance into that method, supplying the optional
			//		position index passed.  In this case position (if specified) should be an integer.
			//
			//		If reference is a DOMNode (or id matching a DOMNode but not a widget),
			//		the position argument can be a numeric index or a string
			//		"first", "last", "before", or "after", same as dojo/dom-construct::place().
			// returns: dijit/_WidgetBase
			//		Provides a useful return of the newly created dijit._Widget instance so you
			//		can "chain" this function by instantiating, placing, then saving the return value
			//		to a variable.
			// example:
			//	|	// create a Button with no srcNodeRef, and place it in the body:
			//	|	var button = new Button({ label:"click" }).placeAt(win.body());
			//	|	// now, 'button' is still the widget reference to the newly created button
			//	|	button.on("click", function(e){ console.log('click'); }));
			// example:
			//	|	// create a button out of a node with id="src" and append it to id="wrapper":
			//	|	var button = new Button({},"src").placeAt("wrapper");
			// example:
			//	|	// place a new button as the first element of some div
			//	|	var button = new Button({ label:"click" }).placeAt("wrapper","first");
			// example:
			//	|	// create a contentpane and add it to a TabContainer
			//	|	var tc = dijit.byId("myTabs");
			//	|	new ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

			var refWidget = !reference.tagName && registry.byId(reference);
			if(refWidget && refWidget.addChild && (!position || typeof position === "number")){
				// Adding this to refWidget and can use refWidget.addChild() to handle everything.
				refWidget.addChild(this, position);
			}else{
				// "reference" is a plain DOMNode, or we can't use refWidget.addChild().   Use domConstruct.place() and
				// target refWidget.containerNode for nested placement (position==number, "first", "last", "only"), and
				// refWidget.domNode otherwise ("after"/"before"/"replace").  (But not supported officially, see #14946.)
				var ref = refWidget && ("domNode" in refWidget) ?
					(refWidget.containerNode && !/after|before|replace/.test(position || "") ?
						refWidget.containerNode : refWidget.domNode) : dom.byId(reference, this.ownerDocument);
				domConstruct.place(this.domNode, ref, position);

				// Start this iff it has a parent widget that's already started.
				// TODO: for 2.0 maybe it should also start the widget when this.getParent() returns null??
				if(!this._started && (this.getParent() || {})._started){
					this.startup();
				}
			}
			return this;
		},

		defer: function(fcn, delay){
			// summary:
			//		Wrapper to setTimeout to avoid deferred functions executing
			//		after the originating widget has been destroyed.
			//		Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
			// fcn: Function
			//		Function reference.
			// delay: Number?
			//		Delay, defaults to 0.
			// tags:
			//		protected

			var timer = setTimeout(lang.hitch(this,
				function(){
					if(!timer){
						return;
					}
					timer = null;
					if(!this._destroyed){
						lang.hitch(this, fcn)();
					}
				}),
				delay || 0
			);
			return {
				remove: function(){
					if(timer){
						clearTimeout(timer);
						timer = null;
					}
					return null; // so this works well: handle = handle.remove();
				}
			};
		}
	});

	if(has("dojo-bidi")){
		_WidgetBase.extend(_BidiMixin);
	}

	return _WidgetBase;
});

},
'ibm/tivoli/fwm/mxmap/MapZIndexHandler':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18
 *
 * (C) COPYRIGHT IBM CORP. 2015,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

/*
 * Javascript responsible for handler the z-indexes of dialogs when map's screens
 */
define( [
    "dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/_Base",
    "dijit/Dialog",
    "dijit/popup",
], function ( declare, _Base, Dialog, Popup ) {

    return declare( [_Base], {  
        _map: null, 
        _dojo: null,
        _mapLoadedListener: null,
        _infoWindowFocusedListener: null,
        _dialogOverrideListener: null,
        _dialogChangeZIndexListener: null,
        _dialogShowListener: null,
        _toolHighlightedListener: null,
        _popupShowListener: null,
        _activeToolName: null,
        _highestMapZIndex: 0, // highest z-index on map, disconsidering dialogs and scrollbars
        _fullScreenModeChangeListener: null,
        Z_INDEX_UPDATED_CLASS: 'z-index-updated',
        constructor: function (params) {
            this._map = params.map;

            this._dojo = this.selectDojoVersion();

            this._mapLoadedListener = this._dojo.subscribe(
                "mxmap.mapLoaded",
                this._dojo.hitch(this, this.onMapLoaded)
            );

            this._dialogOverrideListener = this._dojo.subscribe(
                "mapZIndexHandler.onDialogOverride",
                this._dojo.hitch(this, this.updateDialogZIndex)
            );

            this._dialogChangeZIndexListener = this._dojo.subscribe(
                "mapZIndexHandler.onDialogZIndexChange", 
                this._dojo.hitch(this, this.updateDialogZIndex)
            );

            this._toolHighlightedListener = this._dojo.subscribe(
                "_ToolSpatialTemplate.enableHighlightButton",
                this._dojo.hitch(this, this.moveHighlightedToolDialogToTop)
            );

            this._infoWindowFocusedListener = this._dojo.subscribe(
                "infoWindowFocused", 
                this._dojo.hitch(this, this.moveInfoWindowToTop)
            );
                
            this._dialogShowListener = this._dojo.connect(
                Dialog._DialogLevelManager,
                "show", 
                this._dojo.hitch(this, this.updateDialogZIndex)
            );

            this._popupShowListener = this._dojo.connect(
                Popup, 
                'open', 
                this._dojo.hitch(this, this.movePopupToTop)
            );
        },

        postCreate: function () {
            this._fullScreenModeChangeListener = this._dojo.subscribe(
                "mapFullScreenModeChanged_" + this._map.getId(),
                this._dojo.hitch(this, this.onMapFullScreenModeChanged)
            );
        },

        //This function updates the z-index of any open drop-downs that are related to the given dialog.
		updateRelatedDropDownZIndex : function(dialogNode, highestIndex) {
			
			var openDropdowns = this._dojo.query('.dijitComboBoxMenuPopup' + '.' + this.Z_INDEX_UPDATED_CLASS);
					
			openDropdowns.forEach(function(dropdownDialog) {
                //Take the dialog that owns the drop-down
				var parentWidgetId = dropdownDialog.getAttribute('dijitpopupparent');
				var parentDomNode = this._dojo.byId('widget_' + parentWidgetId);
				var parentDialog = parentDomNode.closest('.dijitDialog');
				
                //If the current dialog is the same as the previous, update the Z-index of the drop-down too.
				if(parentDialog === dialogNode) {
					this.updateAndMarkHTMLElement(dropdownDialog, highestIndex);
				}  	
				
			}, this); 
		},

        updateDialogZIndex: function (dialog) {
			if(dialog){
				this.updateDomNodeZIndex(dialog.domNode);
			}
		},

        updateDomNodeZIndex: function (domNode) {
            if (domNode) {
                var highestZIndex = this.configureMapElements();

                if (highestZIndex && domNode) {
                    var underlayDomNode = this._dojo.query('.dijitDialogUnderlayWrapper')[0];

                    // Place underlay under dialog and over all map elements
                    this.updateAndMarkHTMLElement(underlayDomNode, highestZIndex + 1);

                    // Place dialog over all map elements
                   	this.updateAndMarkHTMLElement(domNode, highestZIndex + 2);
					
					this.updateRelatedDropDownZIndex(domNode, highestZIndex + 3);
                }
            }
        },

        onMapLoaded: function(map) {
            if (map) {
                this._dojo.query("body").attr("data-mxmaploaded", "true");
                this.configureMapElements();
            }
        },

        onMapFullScreenModeChanged: function () {
            this.configureMapElements();
        },

        /**
         * Update z-index from map elements.
         * @param {boolean} useCachedHighestMapZIndex
         */
        configureMapElements: function (useCachedHighestMapZIndex) {
            var mapElements = this.getMapElements();
            var openMap = mapElements.openMap;
            var appContent = mapElements.appContent;
            var mapManagerDialog = mapElements.mapManagerDialog;
            var mapToolsDialogs = mapElements.mapToolsDialogs;
            var highestZIndex = this._highestMapZIndex;

            if (!useCachedHighestMapZIndex) {
                this._highestMapZIndex = 0;

                if (appContent) {
                    var nodesInAppContent = this._dojo.query('*', appContent);
                    this._highestMapZIndex = this.getHighestIndex(nodesInAppContent);
                }

                if (openMap) {
                    var nodesInOpenMap = this._dojo.query('*', openMap);
                    this._highestMapZIndex = Math.max(this._highestMapZIndex, this.getHighestIndex(nodesInOpenMap));
                }

                if (mapManagerDialog) {
                    var nodesInMapManager = this._dojo.query('*', mapManagerDialog);
                    this._highestMapZIndex = Math.max(this._highestMapZIndex, this.getHighestIndex(nodesInMapManager));
                }

                highestZIndex = this._highestMapZIndex;
            }

            highestZIndex = this.placeDialogsOverMapElements(mapToolsDialogs, highestZIndex);       

            return highestZIndex;
        },

        getHighestIndex: function (nodes) {
            var highestIndex = 0;

            nodes.forEach(function (node) {
                var zIndex = this._dojo.query(node).style('z-index')[0];
                var display = this._dojo.query(node).style('display')[0];
                if (parseInt(zIndex) > highestIndex && display !== "none") {
                    highestIndex = parseInt(zIndex);
                }
            }, this);
            
            return highestIndex;
        },

        moveInfoWindowToTop: function (popup) {
            if (!popup || this._activeToolName === 'InfoWindow') {
                return;
            }

            this._activeToolName = 'InfoWindow';
            
            var highestIndex = this.configureMapElements();

            this.updateAndMarkHTMLElement(popup, highestIndex + 1);
        },

        moveHighlightedToolDialogToTop: function (toolName) {
            if (this._activeToolName === toolName) {
                return;
            }
            this._activeToolName = toolName;

            // Place highlighted dialog over other map elements
            var highlightedMapToolDialog = this.getMapToolDialog(toolName);
            if (highlightedMapToolDialog) {
                this.updateDomNodeZIndex(highlightedMapToolDialog);
            }
        },

        movePopupToTop: function (popup) {
            if (popup) {
                var popupWrapper = popup.popup._popupWrapper;
                var highestIndex = this.configureMapElements();

                this.updateAndMarkHTMLElement(popupWrapper, highestIndex + 1);                
            }
        },

        markHTMLElement: function (htmlElement) {
            this._dojo.addClass(htmlElement, this.Z_INDEX_UPDATED_CLASS, true);
        },

        unmarkHTMLElement: function(htmlElement) {
            this._dojo.removeClass(htmlElement, this.Z_INDEX_UPDATED_CLASS);
        },

        getMapElements: function () {
            var mapManagerDialog = this._dojo.byId("plussselectmaplocation-dialog_inner");
            var openMap = this._dojo.byId("pluss_open_map-dialog_inner");
            var appContent = this._dojo.byId("SystemNavAppContent-sc_div");
            
            var mapToolsDialogs = this.getZIndexUpdatedElements();
            var infoWindow = this._dojo.query('.esriPopup.esriPopupVisible')[0];
            if (infoWindow) {
                mapToolsDialogs.push(infoWindow);
            }

            return {
                appContent: appContent,
                mapManagerDialog: mapManagerDialog,
                mapToolsDialogs: mapToolsDialogs,
                openMap: openMap,
            };
        },

        getZIndexUpdatedElements: function() {
            return this._dojo.query('.' + this.Z_INDEX_UPDATED_CLASS);
        },

        getMapToolDialog: function(toolName) {
            return this._dojo.byId("dialog" + toolName + "Dialog");
        },

        /**
         * Update HTML element z-index. 
         * 
         * @param {HTMLElement} htmlElement
         * @param {number} zIndex
         * 
         * @returns {number} HTML element z-index value after update
         */
        updateAndMarkHTMLElement: function (htmlElement, zIndex) {
            this._dojo.style(htmlElement, "z-index", zIndex);
            this.markHTMLElement(htmlElement);

            return zIndex;
        },

        /**
         * Return HTML element z-index. If element is empty or does not have z-index, return 0.
         * @param {HTMLElement} htmlElement 
         */
        getHTMLElementZIndex: function (htmlElement) {
            if (!htmlElement) {
                return 0;
            }

            var zIndex = parseInt(this._dojo.style(htmlElement, "z-index"));

            if (isNaN(zIndex)) {
                return 0;
            }

            return zIndex;
        },

        placeDialogsOverMapElements: function (dialogs, highestZIndex) {
            if (!dialogs.length) {
                return highestZIndex;
            }

            var baseZIndex = highestZIndex + 1;

            dialogs.sort(this._dojo.hitch(this, this.sortByZIndex));

            var previousZIndexes = this._dojo.map(dialogs, this._dojo.hitch(this, this.getHTMLElementZIndex));

            dialogs.forEach(this._dojo.hitch(this, function (dialog, index) {
                var previousDialogZIndex = previousZIndexes[index - 1];
                var previousDialogHasSameZIndex = previousDialogZIndex === this.getHTMLElementZIndex(dialog);

                if (previousDialogHasSameZIndex) {
                    this.updateAndMarkHTMLElement(dialog, previousDialogZIndex);
                } else {
                    this.updateAndMarkHTMLElement(dialog, baseZIndex + index);
                }
            }));

            return this.getHTMLElementZIndex(dialogs[dialogs.length - 1]);
        },

        sortByZIndex: function (dialogA, dialogB) {
            var zIndexA = this.getHTMLElementZIndex(dialogA);
            var zIndexB = this.getHTMLElementZIndex(dialogB);

            return zIndexA - zIndexB;
        },

        resetZIndexUpdatedElements: function() {
            var zIndexUpdatedElements = this.getZIndexUpdatedElements();

            zIndexUpdatedElements.forEach(this._dojo.hitch(this, function(dialog) {
                this.unmarkHTMLElement(dialog);
            }));
        },

        destroy: function () {
            this._map = null;

            this._dojo.unsubscribe(this._mapLoadedListener);
            this._dojo.unsubscribe(this._dialogOverrideListener);
            this._dojo.unsubscribe(this._dialogChangeZIndexListener);
            this._dojo.unsubscribe(this._toolHighlightedListener);
            this._dojo.unsubscribe(this._infoWindowFocusedListener);
            this._dojo.unsubscribe(this._fullScreenModeChangeListener);

            this._dojo.disconnect(this._dialogShowListener);
            this._dojo.disconnect(this._popupShowListener);

            this._dojo.query("body").removeAttr("data-mxmaploaded");

            this.resetZIndexUpdatedElements();

            this._activeToolName = null;
            this._highestMapZIndex = 0;
        },

    });
} );

},
'ibm/tivoli/fwm/mxmap/factory':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
define([
	"dojo/main", 
	"dijit/main", 
	"dojox/main",  
	"dojo/io/script",
	"ibm/tivoli/fwm/mxmap/MapGraphite"
], function(
	dojo, 
	dijit, 
	dojox, 
	script,
	MapGraphite
) {
	
	/*
	* Set the mxmap global object
	*/
	if (!ibm.tivoli.fwm.mxmap) {
		ibm.tivoli.fwm.mxmap = {};
	}
	if (!ibm.tivoli.fwm.mxmap.stack) {	
		ibm.tivoli.fwm.mxmap.stack = {};	
	}
	
	/*
	 * factory will be available globally
	 */
	ibm.tivoli.fwm.mxmap.factory =  {
		events: {
			mapImplLoaded: "mxmap.mapImplLoaded"
		},
		dojoToDomId: null,
		esriVersion: "3.42",
		options: null,
		initialized: false,
		readyToCreateMap: false,
		tries: 10,
		/**
		 * In IE we need to first load MXN standard files and only after we can load
		 * the other ones. Otherwise IE will break complaining MXN object is not
		 * defined.
		 */

		/**
		 * Loads the core Mapstraction javascripts
		 */
		init: function()
		{
			// must be loaded first otherwise it breaks the other

			console.log("[Factory] is Ie?", (dojo.isIE != null));

			this.initialized = true;
			this.registry = {};
			console.log("[Factory] Initiated factory");
		},

		/**
		 * This method creates the provider implementation and triggers its
		 * createMap method
		 */
		createMap: function(options)
		{
			console.log("[Factory] Component ID: " + options.compId);
			console.log("[Factory] Is error in Map Configuration? " + options.mapConf.error);
			if (options.mapConf.error && options.mapConf.error == true)
			{
				if (options.mapConf.showErrorObject && options.mapConf.showErrorObject == true) {
					var params = {
							msgKey : options.mapConf.key,
							msgGroup : options.mapConf.group,
							params: options.mapConf.params
					};
					console.log("[Factory] Errors param: ", params);

					sendEvent('showErrorsParamObject', options.compId, JSON.stringify(params));	
				} else {
					console.log("[Factory] Options.mapConf.key: ", options.mapConf.key);
					addCommInput('msgKey', options.mapConf.key);
					addCommInput('msgGroup', options.mapConf.group);
					sendEvent('showErrors', options.compId, options.mapConf.key);
				}

				return;
			}
			if (this.initialized != true)
			{
				this.init();
			}

			if (this.mapExists(options.compId))
			{
				console.log("[Factory]  Map exists, destroying", options.compId);
				this.destroyCurrentMap(options.compId);
			}

			var providerName = options.mapConf.provider;
			var providerImplFactory = "ibm/tivoli/fwm/mxmap/factories/" + providerName;

			this.options = options;

			var me = this;

			if (providerName == "spatial" || providerName == "openmaps") {
				var mapGraphite = this.buildMapGraphite(options);
				this.registry[options.compId] = {
					currentMap: mapGraphite
				};
			} else {
				if (!this.loaded[providerName]) {
					ibm.tivoli.fwm.mxmap.stack[providerName] = [];
					ibm.tivoli.fwm.mxmap.stack[providerName].push(options);
					this.loaded[providerName] = -1;
					require([providerImplFactory], function(factory) {
						factory.init(options);
						console.log("[Factory]  Provider initiated.");
					});
				} else {
					if (this.loaded[providerName] == -1)
					{
						console.log("[Factory] Api is NOT loaded, queueing options");
						ibm.tivoli.fwm.mxmap.stack[providerName].push(options);
					}
					else
					{
						console.log("[Factory] Api is loaded");
						dojo.publish(this.events.mapImplLoaded, [ this.loaded[providerName], providerName ]);
						this._createProviderMap(options, this.loaded[providerName]);
					}
				}
			}
		},

		skipGraphite: function() {
			return window.localStorage.getItem('skipGraphiteMap');
		},

		buildMapGraphite: function(options) {
			var mapGraphite = new MapGraphite(options);

			return mapGraphite;
		},

		/**
		 * 
		 * Set the property map readyToCreateMap
		 * Used when the map creation has to wait for something else to load
		 */
		setReadyToCreateMap: function(isReadyToCreate) {
			this.readyToCreateMap = isReadyToCreate;
		},
		mapExists: function(compId)
		{

			return this.registry[compId] && this.registry[compId].currentMap;
		},
		destroyCurrentMap: function(compId)
		{
			console.log("[Factory] Destroying map", compId, this.registry[compId]);
			try
			{
				if (this.readyToCreateMapHandle) {
					dojo.unsubscribe(this.readyToCreateMapHandle);
				}
				if (this.openMaximoDialogHandler) {
					this.openMaximoDialogHandler.remove();
					this.openMaximoDialogHandler = null;
				}
				if (this.registry[compId] && this.registry[compId].currentMap)
				{
					this.registry[compId].currentMap.destroyRecursive();
				}
			}
			catch (e)
			{
				console.log("[Factory]  Could not destroy", e);
			}
			this.registry[compId] = null;
		},
		loaded: {},
		/**
		 * When the provider api is initializes this method is called.
		 */
		apiInitialized: function(mapImpl, provider)
		{
			console.log("[Factory] Loaded: ", mapImpl, provider);
			this.loaded[provider] = mapImpl;
			dojo.publish(this.events.mapImplLoaded, [ mapImpl, provider ]);
			this.executeStack(mapImpl, provider);
		},
		/**
		 * publish an event from Maximo 
		 * If the provider is Spatial, we need to publish the event from Esri Dojo
		 */
		publishMapEvent: function(compId, eventType, eventParams) {
			if (!this.skipGraphite()) {
				window.mapBus.onServerUpdates(eventType, eventParams);
				return;
			}

			if (this.registry && this.registry[compId]) {
				var mapImpl = this.registry[compId].currentMap;
				if (mapImpl.providerName === 'maximospatial') {
					mapImpl.publishMapEvent(eventType, eventParams);
				} else {
					dojo.publish(eventType, eventParams);
				}
			}
		},
		executeStack: function(mapImpl, provider)
		{
			if (ibm.tivoli.fwm.mxmap.stack[provider])
			{
				var queuedRequest = ibm.tivoli.fwm.mxmap.stack[provider];

				for ( var id = 0; id < queuedRequest.length; id++)
				{
					var options = queuedRequest[id];
					this._createProviderMap(options, mapImpl);
				}
			}
		},
		_createProviderMap: function(options, mapImpl)
		{
			console.log("[Factory] Create: ", mapImpl, options);
			var instance = null;
			eval("this._instance = new " + mapImpl + "();");
			instance = this._instance;
			console.log("[Factory] Instance: ", instance);
			instance.createMap(options);
			this.registry[options.compId] = {
					currentMap: instance
			};
		},
	}
	
	return ibm.tivoli.fwm.mxmap.factory;
});

},
'ibm/tivoli/fwm/mxmap/layers/RouteLayer':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

/**
 * Represents the routes layer. Turning this layer on or off shows or hider the route paths.
 */
define(["dojo/_base/declare", 
	"ibm/tivoli/fwm/mxmap/layers/Layer"], function(declare, Layer) {
	return declare([Layer], {
		/**
		 * Starts the layer as enabled.
		 */
		init: function()
		{
			this.inherited(arguments);
			this.enable();
		},
		/**
		 * Enables this layer
		 */
		enable: function()
		{
			this.inherited(arguments);
			this._map.enableRoutes();
		},
		/**
		 * Disables this layer
		 */
		disable: function()
		{
			this.inherited(arguments);
			this._map.disableRoutes();
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/layers/TrafficLayer':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
/**
 * Represents a traffic layer.
 */

define(["dojo/_base/declare", 
	"ibm/tivoli/fwm/mxmap/layers/Layer"]
, function(declare, Layer) {
	return declare([Layer], {
		/**
		 * Enables this layer and consequently the traffic view.
		 */
		enable: function()
		{
			this.inherited(arguments);
			this._map.enableTraffic();
		},
		/**
		 * Disables this layer
		 */
		disable: function()
		{
			this.inherited(arguments);
			this._map.disableTraffic();
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/symbology/SymbologyManager':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/_Base"], function(declare, _Base) {
	return declare([_Base], {
		_mapSymbologyJson: null,
		_map: null,
		_objectMap: null,
		_defaultSymbologyConfig: null,
		constructor: function(options)
		{
			dojo.mixin(this, options);
			this._map = options.map;
			this._mapSymbologyJson = this._map.mapConf.symbologyConfig;
			this._objectMap = this._buildObjectMap(this._mapSymbologyJson);
			this._defaultSymbologyConfig = options.defaultSymbologyConfig;
		},
		_buildObjectMap: function(symbologyConfig)
		{

			var retval = {};
			if((this._mapSymbologyJson != null) && (this._mapSymbologyJson.layers != null)){
				for (id in this._mapSymbologyJson.layers)
				{
					var layer = this._mapSymbologyJson.layers[id];
					retval[layer.id] = layer;
					if (layer.symbologies && layer.symbologies[0]) 
						this.setActiveSymbologyForLayer(layer, layer.symbologies[0]);
				}
			}
			return retval;
		},
		getDefaultLayerConfigFor:function(_id){
			this._layerIdXlation[_id]="others";
			return this.getLayerConfigById(_id);
		},
		/**
		 * Retrieves the symbology config for the layer (object type) specified by id
		 */
		getLayerConfigById: function(id2)
		{
			var _id = id2.toLowerCase();
			if(this._layerIdXlation[_id]!=null){
				_id=this._layerIdXlation[_id];
			} 
			return this._objectMap[_id];
		},
		/**
		 * Retrieves an array with all the symbologies for a given layer
		 */
		getSymbologyConfigArrayByLayer: function(layerConfig){
			var symbologyArray = {};
			if((layerConfig != null) && (layerConfig.symbologies != null)){
				dojo.forEach(layerConfig.symbologies, function(symbology){
					if(symbology.id != null && symbology.id != ""){
						symbologyArray[symbology.id] = symbology; 
					}
				});
			}
			return symbologyArray;
		},
		/**Retrieves the Linear Symbology Definition for an application (id),
		 * Linear object name, Linear attribute and Linear value
		 * 
		 */
		getLinearSymbologyDefinition: function(mboName, objectName, attributeName, attributeValue){
			var layer = this.getLayerConfigById(mboName);
			var linearSymbologyDef = null;
			var linearSymbologyAttributes = null;
			var linearSymbologyValues = null;
			var linearSymbologyResponse = null;
			if ( layer ) {
				linearSymbologyDef = layer.linearSymbology;
				if ( linearSymbologyDef ) {
					dojo.forEach(linearSymbologyDef, function(symbology){
						if(symbology.objectName != null && symbology.objectName != "" && symbology.objectName == objectName){
							linearSymbologyAttributes = symbology; 
						}
					});
					if (linearSymbologyAttributes) {
						var attributes = linearSymbologyAttributes.attributes;
						dojo.forEach(attributes, function(attribute){
							if(attribute.name != null && attribute.name == attributeName){
								linearSymbologyValues = attribute; 
							}
						});
						if (!linearSymbologyValues) {
							// Defaults values were not found in the Symbology column (Map Manager)
							if (attributeName == "linearDefaultAttribute" &&  attributeValue == "linearDefaultValue") {
								return null;
							}
							return this.getLinearSymbologyDefinition(mboName, objectName, "linearDefaultAttribute", "linearDefaultValue");
						}

						var attributeValues = linearSymbologyValues.values;
						dojo.forEach(attributeValues, function(attrValue){
							if (!linearSymbologyResponse) {
								if(attrValue.value != null && attrValue.value != "" && attrValue.value == attributeValue){
									linearSymbologyResponse = attrValue; 
								} else {
									if (attrValue.value == null || attrValue.value == undefined || attrValue.value == "") {
										var initialValue = attrValue.startValue;
										var finalValue = attrValue.endValue;
										if (initialValue != null && initialValue != undefined && initialValue != "" &&
												finalValue != null && finalValue != undefined && finalValue != "") {
											if (initialValue <= attributeValue && attributeValue <= finalValue) {
												linearSymbologyResponse = attrValue; 
											}
										} else {
											if ((initialValue == null || initialValue == undefined || initialValue == "") &&
													(finalValue == null || finalValue == undefined || finalValue == "")) {
												linearSymbologyResponse = attrValue;
											}
										}
									}								
								}
							}						
						});
						if (!linearSymbologyResponse) {
							// Defaults values were not found in the Symbology column (Map Manager)
							if (attributeName == "linearDefaultAttribute" &&  attributeValue == "linearDefaultValue") {
								return null;
							}
							return this.getLinearSymbologyDefinition(mboName, objectName, "linearDefaultAttribute", "linearDefaultValue");
						}


					}
				}
			}
			return linearSymbologyResponse.symbology;
		},
		/**Retrieves the Pin Point Definition for a layer specified by id
		 * 
		 */
		getPinPointDefinition: function(id){
			var layer = this.getLayerConfigById(id);
			var pinPointDef = null;
			if ( layer ) {
				pinPointDef = layer.pinPointDefinition;
			}
			return pinPointDef;
		},
		/**
		 * Retrieves the Highlight configutation for a given layer
		 */
		getHighlightConfigByLayer: function(layerConfig, id){
			return layerConfig.highlightGeometry;
		},
		/**
		 * Retrieves an array with all the legends for a given symbology
		 */
		getLegendConfigArrayBySymbology: function(symbologyConfig){
			var legendArray = {};
			if((symbologyConfig != null) && (symbologyConfig.legends != null)){
				dojo.forEach(symbologyConfig.legends, function(legend){
					if(legend.id != null && legend.id != ""){
						legendArray[legend.id] = legend; 
					}
				});
			}
			return legendArray;
		},
		_layerIdXlation:{},
		setActiveSymbology: function(layerId, symbology)
		{

			var layer = this.getLayerConfigById(layerId);
			this.setActiveSymbologyForLayer(layer, symbology);
		},
		setActiveSymbologyForLayer: function(layer, symbology)
		{
			layer.activeSymbology = symbology;
		},
		getActiveSymbology: function(layerId)
		{
			var layer = this.getLayerConfigById(layerId);
			var activeSymbology = null;
			if(layer)
			{
				activeSymbology = layer.activeSymbology;
			}
			return activeSymbology;
		},
		getLegendSymbolForObject: function(object, routeColor)
		{
			var layer = this.getLayerConfigById(object.mxdata.mboName);
			return this.getLegendSymbolForObjectAndLayer(layer, object, routeColor);
		},
		fixSymbolUrl: function(symbol)
		{
			if(!symbol.urlFixed)
			{
				symbol.url = dojo.config.fwm.servletBase + symbol.url;
				symbol.urlRTL = dojo.config.fwm.servletBase + symbol.urlRTL;
				symbol.urlFixed = true;
			}
			return symbol;
		},
		/*
		 * Given an object and the currently active symbology, returns the symbol
		 * for the object in the symbology. If a color is given and the selected
		 * symbology is based on resource, the given color is used to find the right
		 * symbol.
		 */
		getLegendSymbolForObjectAndLayer: function(layer, object, routeColor)
		{
			var activeSymbology = layer.activeSymbology;
			if (activeSymbology == null)
			{
				return ibm.tivoli.fwm.mxmap.ImageLibraryManager.getImageLibraryManager().getDefaultMarkerImageInfo();
			}

			// Resource symbology is one of the exceptions to the symbology configuration file.
			// Icon file names are not configurable.
			if (activeSymbology.id == "resource")
			{
				if (object.routedata == null)
				{
					if (object.ownDefaultMarker != null)
					{
						return object.ownDefaultMarker;
					}
					else
					{
						return this._getDefaultSymbol(activeSymbology);
					}
				}
				else
				{
					var rtlDir = "";
					if(document.body.dir == "rtl")
					{
						rtlDir = "/rtl";
					}
					// Symbology type: resource.
					// We use the route color to find the right symbol.
					return {
						"url": ibm.tivoli.fwm.mxmap.ImageLibraryManager.getImageLibraryManager().getResourcesPath() + rtlDir + "/symbology/workorder/map_WO_" + routeColor.replace("#", "").toLowerCase() + ".png",
						"color": "",
						"offsetx": 24,
						"offsety": 36,
						"width": 47,
						"height": 36
					};
				}
			}
			// Labors/Crews retrieved from the dispatcher version of the "Nearby Resources" tool
			// are another exception to the symbology configuration file.
			// Icon file names are not configurable.
			else if( ((layer.id == "labor") || (layer.id == "amcrew")) && (object.routeInfo != undefined) && (object.routeInfo.polyline != undefined))
			{
				var routeColor = object.routeInfo.polyline.color;
				var resourceIconPrefix = (layer.id == "labor") ? "/labor/map_locationLabor_":"/crew/map_locationCrew_";
				var rtlDir = (document.body.dir == "rtl") ? "/rtl":"";
				// Labor/crew marker to be displayed in a dispatch map,
				// use the icon that match the route color
				return {
					"url": ibm.tivoli.fwm.mxmap.ImageLibraryManager.getImageLibraryManager().getResourcesPath() + rtlDir + "/symbology" + resourceIconPrefix + routeColor.replace("#", "").toLowerCase() + ".png",
					"color": "",
					"offsetx": 24,
					"offsety": 36,
					"width": 47,
					"height": 36
				};
			}

			else if (activeSymbology.id == "fwm_default")
			{
				if (object.ownDefaultMarker != null)
				{
					return object.ownDefaultMarker;
				}
				else
				{
					// Symbology type: default
					// We assume there's only one value and return it.
					return this.fixSymbolUrl(activeSymbology.legends[0].symbol);
				}
			}
			else
			{
				if (activeSymbology.type == "numeric")
				{
					return this._getNumericSymbol(object, activeSymbology);
				}
				else if (activeSymbology.type == "domainvalue" || activeSymbology.type == "tablevalue")
				{
					return this._getDomainSymbol(object, activeSymbology);
				}
				// Shouldn't ever happen, but just in case...
				return this._getDefaultSymbol(activeSymbology);
			}
		},
		/*
		 * Returns the default symbol for the given symbology.
		 */
		_getDefaultSymbol: function(symbology)
		{
			var defaultSymbols = dojo.filter(symbology.legends, function(legend)
					{
				return legend.isDefault == true;
					});
			return defaultSymbols.length > 0 ? this.fixSymbolUrl(defaultSymbols[0].symbol) : null;
		},
		/*
		 * Returns the right symbol for the given object in the given symbology,
		 * based on the relevant attribute's value and the configured ranges.
		 */
		_getNumericSymbol: function(object, symbology)
		{
			// Symbology type: numeric
			// We try to convert the value to a number and find a range that
			// contains that number. If either fails we return the default symbol.
			var val = object.mxdata.attributes[symbology.id];
			if (val == "")
			{
				val = "null";
				var symbols = dojo.filter(symbology.legends, function(legend)
						{
					return (legend.id == val);
						});
				return (symbols.length > 0 ? this.fixSymbolUrl(symbols[0].symbol) : this._getDefaultSymbol(symbology));
			}
			else if (!val)
			{
				return this._getDefaultSymbol(symbology);
			}
			else
			{
				var attrVal = parseInt(val);
				var symbols = dojo.filter(symbology.legends, function(legend)
						{
					return (attrVal >= parseInt(legend.minValue) && attrVal <= parseInt(legend.maxValue));
						});
				return (symbols.length > 0 ? this.fixSymbolUrl(symbols[0].symbol) : this._getDefaultSymbol(symbology));
			}
		},
		/*
		 * Returns the right symbol for the given object in the given symbology,
		 * based on the relevant attribute's value and the configured value/symbol
		 * pairs.
		 */
		_getDomainSymbol: function(object, symbology)
		{
			var attrVal = String(object.mxdata.attributes[symbology.id]).toLowerCase();
			if (attrVal == "")
				attrVal = "null";
			var symbols = dojo.filter(symbology.legends, function(legend)
					{
				return (legend.id == attrVal);
					});
			return (symbols.length > 0 ? this.fixSymbolUrl(symbols[0].symbol) : this._getDefaultSymbol(symbology));
		},
		/*
		 * Returns the default symbology for the layer
		 * The default symbology is a configuration in the presentation.
		 */
		getDefaultSymbologyForLayer: function(layer)
		{
			var defaultSymbology = null;
			if(this._defaultSymbologyConfig != null)
			{
				var layerSymbologyPair = null;
				layerSymbologyPair = dojo.filter(this._defaultSymbologyConfig, function(pair)
						{
					return (pair.layer == layer);
						});
				if(layerSymbologyPair.length > 0)
				{
					defaultSymbology = layerSymbologyPair[0].symbology;
				}
			}
			return defaultSymbology;
		}

	});
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/ToggleComboButton':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/_base/declare", "dojo/main", "dijit/main",
	"dijit/form/ComboButton", "dijit/form/ToggleButton" ], 
	function(declare, dojo, dijit, ComboButton, ToggleButton) {
	var dojox = dojo.dojox;
	/**
	 * Combo button that has the toggle (pushed) effect
	 */
	return declare([ComboButton, ToggleButton], {
		
	});
	
});

},
'ibm/tivoli/fwm/mxmap/geolocation/LocationMonitor':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dojox/timing/_base,ibm/tivoli/fwm/mxmap/_Base,ibm/tivoli/fwm/mxmap/geolocation/MyCurrentLocation"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.geolocation.LocationMonitor");
dojo.require("dojox.timing._base");
dojo.require("ibm.tivoli.fwm.mxmap._Base");
dojo.require("ibm.tivoli.fwm.mxmap.geolocation.MyCurrentLocation");

/**
 * Monitors the user's current location and send it to Maximo so that the data
 * can be stored in the LBSLOCATION table
 */
ibm.tivoli.fwm.mxmap.geolocation.LocationMonitor._instance = null;

dojo.declare("ibm.tivoli.fwm.mxmap.geolocation.LocationMonitor", ibm.tivoli.fwm.mxmap._Base, {
	interval: 0, // seconds
	_timer: null,
	compId: null,
	_myCurrentLocation: null,
	resetTimer: true,
	constructor: function(options)
	{
		dojo.mixin(this, options);

		// Get the instance of MyCurrentLocation
		this._myCurrentLocation = ibm.tivoli.fwm.mxmap.geolocation.MyCurrentLocation.getMyCurrentLocationInstance();

	},
	/**
	 * Starts the timer to monitor the current location
	 */
	start: function()
	{
		if (this._timer == null)
		{
			if (this.interval > 0)
			{
				console.log("[LocationMonitor] Starting timer with interval " + this.interval);
				this._doStart();
			}
			else
			{
				console.log("[LocationMonitor] Interval must be greater than zero -- Start ignored.");
			}
		}
		else
		{
			console.log("[LocationMonitor] Timer already started. Ignoring start");
		}
	},
	/**
	 * Stops the timer
	 */
	stop: function()
	{
		if (this._timer == null)
		{
			console.log("[LocationMonitor] Timer not started. Ignoring stop");
		}
		else
		{
			console.log("[LocationMonitor] Stopping timer");
			this._timer.stop();
			this._timer = null;
		}
	},
	/**
	 * Returns true if the timer is active
	 */
	started: function()
	{
		return (this._timer != null);
	},
	/**
	 * Creates the instance of dojox.timing.Timer and changes the onTick,
	 * onStart and onStop functions Calls myCurrentLocation.getUserLocation on
	 * onTick
	 */
	_doStart: function()
	{
		this._myCurrentLocation.getUserLocation(dojo.hitch(this, this._updateMaximoRecord), dojo.hitch(this, this._failedToGetCurrentLocation));
		this._timer = new dojox.timing.Timer(this.interval * 1000);
		this._timer.onTick = dojo.hitch(this, function()
		{
			if (this._myCurrentLocation)
			{
				this._myCurrentLocation.getUserLocation(dojo.hitch(this, this._updateMaximoRecord), dojo.hitch(this, this._failedToGetCurrentLocation));
			}
		});
		this._timer.onStart = dojo.hitch(this, function()
		{

			console.log("[LocationMonitor] Started timer to update current location");

		});
		this._timer.onStop = dojo.hitch(this, function()
		{

			console.log("[LocationMonitor] Stopped timer to update current location");

		});
		this._timer.start();
	},
	/**
	 * Sends the LBS location data to the server
	 */
	_updateMaximoRecord: function(position)
	{

		if (position && position.coords)
		{
			var positionData = position.coords;

			var myEvent = new Event("loadLaborLBS", this.compId, {
				lat: positionData.latitude,
				lng: positionData.longitude,
				locationAccuracy: positionData.accuracy,
				altitudeAccuracy: positionData.altitudeAccuracy,
				altitude: positionData.altitude,
				heading: positionData.heading,
				speed: positionData.speed
			}, REQUESTTYPE_HIGHASYNC);

			queueManager.queueEvent(myEvent, "text/html", "text", dojo.hitch(this, this._messageSuccessfullySentToMaximo), dojo.hitch(this, this._failedToSendMessageToMaximo));
			
			/*
			 * Need to call this method to keep the session running as updates are being sent to LOCATIONLBS table even though there is 
			 * no activity happening on the UI. This also prevents the session timeout warning dialog from popping up all the time.	This 
			 * will only be done if the system property mxe.map.everyplacetimeout is set to true		
			 */			
			if (this.resetTimer == true)
			{
				startLogoutTimer();
			}	
		}
	},
	/**
	 * Handles the 4 possible errors when trying to retrieve LBS location data.
	 * If the errors are either PERMISSION_DENIED or GEOLOCATION_NOT_SUPPORTED,
	 * the server logs the error and the LBS data collection stops. If the
	 * errors are either TIMEOUT or POSITION_UNAVAILABLE, just log in the
	 * browser console.
	 */
	_failedToGetCurrentLocation: function()
	{
		if (this._myCurrentLocation)
		{
			switch (this._myCurrentLocation.getStatus())
			{
				case ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.PERMISSION_DENIED:
					this.stop();

					console.warn("[LocationMonitor] Could not retrieve current location (PERMISSION_DENIED). LBS data collection stopped.");

					this._logPermissionDenied();
					break;
				case ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.GEOLOCATION_NOT_SUPPORTED:
					this.stop();

					console.warn("[LocationMonitor] Could not retrieve current location (GEOLOCATION_NOT_SUPPORTED). LBS data collection stopped.");

					this._logNotSupported();
					break;
				case ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.TIMEOUT:
					console.warn("[LocationMonitor] Could not retrieve current location (TIMEOUT).");
					break;
				case ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.POSITION_UNAVAILABLE:
					console.warn("[LocationMonitor] Could not retrieve current location (POSITION_UNAVAILABLE).");
					break;
				default:
					break;
			}
			;
		}
	},
	_failedToSendMessageToMaximo: function()
	{
		console.error("[LocationMonitor] Failed to send current location to Maximo");
	},
	_messageSuccessfullySentToMaximo: function()
	{
	},
	/**
	 * Send a message to the server so that it can log the PERMISSION_DENIED
	 * error.
	 */
	_logPermissionDenied: function()
	{
		sendEvent('logLBSCollectionPermissionDenied', this.compId, '');
	},
	/**
	 * Send a message to the server so that it can log the
	 * GEOLOCATION_NOT_SUPPORTED error.
	 */
	_logNotSupported: function()
	{
		sendEvent('logLBSCollectionNotSupported', this.compId, '');
	},
	destroyRecursive: function()
	{
		this.stop();
		this.inherited(arguments);
	}
});

/**
 * Retrieves the LocationMonitor singleton instance
 */
ibm.tivoli.fwm.mxmap.geolocation.LocationMonitor.getLocationMonitorInstance = function(params)
{
	if (!ibm.tivoli.fwm.mxmap.geolocation.LocationMonitor._instance)
	{
		ibm.tivoli.fwm.mxmap.geolocation.LocationMonitor._instance = new ibm.tivoli.fwm.mxmap.geolocation.LocationMonitor(params);
	}
	return ibm.tivoli.fwm.mxmap.geolocation.LocationMonitor._instance;
};

});

},
'ibm/tivoli/fwm/mxmap/routing/impl/bingmaps':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Base,ibm/tivoli/fwm/mxmap/routing/Router,ibm/tivoli/fwm/mxmap/routing/Route"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.routing.impl.bingmaps");
dojo.require("ibm.tivoli.fwm.mxmap._Base");
dojo.require("ibm.tivoli.fwm.mxmap.routing.Router");
dojo.require("ibm.tivoli.fwm.mxmap.routing.Route");

/**
 * Bing maps routing implementation.
 */
ibm.tivoli.fwm.mxmap.routing.impl.bcc = 0;
ibm.tivoli.fwm.mxmap.routing.impl.bingmapsId = function()
{
	return ibm.tivoli.fwm.mxmap.routing.impl.bcc++;
};

//This variable is always increased so that there can be multiple parallel requests
//to dojo.io.script.get without overwriting the callback function 
ibm.tivoli.fwm.mxmap.routing.impl.routeCallbackId = 0;
ibm.tivoli.fwm.mxmap.routing.impl.getRouteCallbackId = function()
{
	return ibm.tivoli.fwm.mxmap.routing.impl.routeCallbackId++;
};

dojo.declare("ibm.tivoli.fwm.mxmap.routing.impl.bingmaps", [ ibm.tivoli.fwm.mxmap.routing.Router, ibm.tivoli.fwm.mxmap._Base ], {
	directionsService: null,
	map: null,
	conf: null,
	_isLoaded: false,
	_routeQueue: [],
	_msHandlers: [],
	_routeLimits: 10,
	_routeBaseURL: null,
	/**
	 * Bing maps needs to load the Direction module
	 * 
	 */
	c: 0,
	_allowParallelRouteCreation: true,
	constructor: function(params)
	{
		console.log("router bingmaps", params);
		this.id = ibm.tivoli.fwm.mxmap.routing.impl.bingmapsId();
		this._msHandlers = [];
		this._routeQueueParalel = [];
		this._isLoaded = false;
		dojo.mixin(this, params);
		this.c = 0;
		this._routeBaseURL = params.routeUrl;
		
// TODO: Remove this commented code (old bing javascript api method)
//		var loadedFct = dojo.hitch(this, this._loaded);
//		if (Microsoft.Maps.Directions)
//		{
//			console.log("MsDirections loaded");
//			this.directionsService = new Microsoft.Maps.Directions.DirectionsManager(this.map.getProviderMap());
//
//			this._isLoaded = true;
//		}
//		else
//		{
//			Microsoft.Maps.loadModule('Microsoft.Maps.Directions', {
//				callback: loadedFct
//			});
//		}
	},
	/**
	 * Until the bing directions module is not loaded we cannot perform any
	 * routing. After it loads we trigger the _executeQueue to execute any
	 * queued routing requests.
	 */
// TODO: Remove this commented code (old bing javascript api method)
//	_loaded: function()
//	{
//		console.log("loaded module Microsoft.Maps.Directions");
//		this.directionsService = new Microsoft.Maps.Directions.DirectionsManager(this.map.getProviderMap());
//
//		this._isLoaded = true;
//
//		this._executeQueue();
//	},

	/**
	 * Handles final route callback when it's complete
	 * 
	 * @param arg
	 * @param callback
	 */
	_routedOk: function(routeSummary, callback)
	{
		console.log("routed ok", this.id, this.routecolor, routeSummary);
		
		routeSummary.totalDistance = routeSummary.distance;
		routeSummary.totalDuration = routeSummary.time;
		routeSummary.map = this.map;
		var itinerary = new ibm.tivoli.fwm.mxmap.routing.itinerary.Itinerary();
		var initialStops = routeSummary.inputInfo.stops;
		if((routeSummary.itineraryLegInfo != null) && (routeSummary.itineraryLegInfo != undefined))
		{
			if (routeSummary.itineraryLegInfo.length > 0)
			{
				itinerary.setInitialLocation(routeSummary.itineraryLegInfo[0].startAddress, routeSummary.itineraryLegInfo[0].startLoc, null, null, true);
			}
			itinerary.addAllLegs(routeSummary.itineraryLegInfo);

			//check if last stop was calculated we must force geocode
			if(initialStops[initialStops.length-1].calculatedStop==true){
				itinerary.legs[itinerary.legs.length-1].needsToGeocode=true;
			}
		}
		
		routeSummary.itinerary = itinerary;
		routeSummary.distanceUnit = this.getCurrentDistanceUnit();

		if (callback)
		{
			var routeInfo = new ibm.tivoli.fwm.mxmap.routing.Route(routeSummary);
			callback(routeInfo);
		}
		this.isExecuting = false;
		if(this._allowParallelRouteCreation == false)
		{
			this.executeQueuedParalel();
		}

	},
	/**
	 * Handles routing error callback
	 * http://msdn.microsoft.com/en-us/library/hh312807.aspx
	 * 
	 * @param error
	 * @param erroCb
	 */
	_routeError: function(status, errCb)
	{
		console.error("route failed", status, errCb);
		if (errCb)
		{
			switch (status.responseCode)
			{
				case 2:
				case 3:
				case 4:
				case 5:
				case 8:
				case 15:
					errCb(ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.ZERO_RESULTS, status);
					break;
				case 13:
				case 16:
				case 18:
				case 17:
					errCb(ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.REQUEST_DENIED, status);
					break;
				case 11:
					errCb(ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.TIMEOUT, status);
					break;
				default:
					errCb(ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.UNKNOWN_ERROR, status);
					break;

			}
		}
		if(this._allowParallelRouteCreation == false)
		{
			this.executeQueuedParalel();
		}
	},
	/**
	 * Executes all queued routing requests
	 */
// TODO: Remove this commented code (old bing javascript api method)
//	_executeQueue: function()
//	{
//		console.log("executing queued ", this._routeQueue.length);
//		for ( var i = 0; i < this._routeQueue.length; i++)
//		{
//			console.log("fct ", this._routeQueue[i]);
//			var obj = this._routeQueue[i];
//			this.showRoute(obj.stops, obj.callback, obj.errCb, null, obj.instanceConf);
//
//		}
//	},
	executeQueuedParalel: function()
	{
		console.log("executing queued paralele", this._routeQueueParalel.length);
		if (this._routeQueueParalel.length > 0)
		{
			var obj = this._routeQueueParalel.pop();
			this.showRoute(obj.stops, obj.callback, obj.errCb, null, obj.instanceConf);
		}
		console.log("sent");
	},
	/**
	 * Get route data, route polyline, stop locations and last stop.
	 * 
	 * @param resp
	 * @param map
	 * @returns {lastWayPoint:lastWayPoint,locations:locations,polylineVertices:polylineVertices}
	 */
// TODO: Remove this commented code (old bing javascript api method)
//	_extractItinerarySteps: function(itineraryItems)
//	{
//		var steps = [];
//		var lastDistance = 0.0;
//		for ( var id in itineraryItems)
//		{
//			var item = itineraryItems[id];
//			var loc = this.map.latLng(item.coordinate.latitude,item.coordinate.longitude);
//			var step = {
//				distance: lastDistance,
//				duration: item.durationInSeconds,
//				info: item.formattedText,
//				location:loc
//			};
//			steps.push(step);
//			lastDistance = item.distance;
//
//		}
//		return steps;
//	},
	_extractItineraryStepsFromItineraryItems: function(itineraryItems)
	{
		var steps = [];
		var lastDistance = 0.0;
		for (var id = 0; id < itineraryItems.length; id++)
		{
			var item = itineraryItems[id];
			var loc = this.map.latLng();
			loc.fromProprietary(item.maneuverPoint);
			var step = {
				distance: lastDistance,
				duration: item.travelDuration,
				info: item.instruction.text,
				location: loc
			};
			steps.push(step);
			lastDistance = item.travelDistance;

		}
		return steps;
	},
// TODO: Remove this commented code (old bing javascript api method)
//	_extractRouteInfo: function(resp, map)
//	{
//		var lastWayPoint = null;
//		var locations = [];
//		var polylineVertices = [];
//		var itineraryLegInfo = [];
//
//		for ( var j in resp.route)
//		{
//			var routeLegs = resp.route[j];
//			for ( var k in routeLegs)
//			{
//				var leg = routeLegs[k];
//				
//				for ( var l in leg)
//				{
//					var st = leg[l];
//				
//					if (!st)
//					{
//						continue;
//					}
//					// st.startWaypointLocation
//					var startpt = this.map.latLng();
//					startpt.fromProprietary(st.startWaypointLocation);
//
//					locations.push(startpt);
//
//					var legEnd = this.map.latLng();
//					legEnd.fromProprietary(st.endWaypointLocation);
//					var legInfo = {
//						location: legEnd,
//						startLoc: startpt,
//						distanceToLeg: st.summary.distance,
//						durationToLeg: Math.round(st.summary.time / 6) / 10,
//						info: null,
//						startAddress: null,
//						marker: null,
//						steps: null,
//						onclick: null
//					};
//					console.log(l, st.subLegs);
//					for ( var m in st.subLegs)
//					{
//						var sleg = st.subLegs[m];
//
//						if (legInfo.startAddress == null)
//						{
//
//							legInfo.startAddress = sleg.startDescription;
//						}
//						polylineVertices = polylineVertices.concat(this._getPolylineVertices(sleg, map));
//						legInfo.info = sleg.endDescription;
//					}
//
//					legInfo.steps = this._extractItinerarySteps(st.itineraryItems);
//					itineraryLegInfo.push(legInfo);
//					lastWayPoint = this.map.latLng();
//					lastWayPoint.fromProprietary(st.endWaypointLocation);
//
//				}
//			}
//		}
//		return {
//			lastWayPoint: lastWayPoint,
//			locations: locations,
//			itineraryInfo: itineraryLegInfo,
//			polylineVertices: polylineVertices
//		};
//	},
	_extractRouteInfoFromRestResponse: function(resp)
	{
		var lastWayPoint = null;
		var locations = [];
		var polylineVertices = [];
		var itineraryLegInfo = [];

		for (var j = 0; j < resp.resources.length; j++)
		{
			var routeLegs = resp.resources[j].routeLegs;
			for (var k = 0; k < routeLegs.length; k++)
			{
				var leg = routeLegs[k];
				
				if (!leg)
				{
					continue;
				}
				// st.startWaypointLocation
				var startpt = this.map.latLng();
				startpt.fromProprietary(leg.actualStart);

				locations.push(startpt);

				var legEnd = this.map.latLng();
				legEnd.fromProprietary(leg.actualEnd);
				var legInfo = {
					location: legEnd,
					startLoc: startpt,
					distanceToLeg: leg.travelDistance,
					durationToLeg: Math.round(leg.travelDuration / 6) / 10,
					info: null,
					startAddress: null,
					marker: null,
					steps: null,
					onclick: null,
					needsToGeocode: true
				};
				legInfo.steps = this._extractItineraryStepsFromItineraryItems(leg.itineraryItems);
				itineraryLegInfo.push(legInfo);
				lastWayPoint = this.map.latLng();
				lastWayPoint.fromProprietary(leg.actualEnd);

			}
			var routePath = resp.resources[j].routePath;
			polylineVertices = polylineVertices.concat(this._getPolylineVerticesFromRoutePath(routePath));
		}
		return {
			lastWayPoint: lastWayPoint,
			locations: locations,
			itineraryInfo: itineraryLegInfo,
			polylineVertices: polylineVertices
		};
	},
	/*
	 * iterate over a subleg and returns the vertices of the polyline
	 */
// TODO: Remove this commented code (old bing javascript api method)
//	_getPolylineVertices: function(subLeg)
//	{
//		var lineVertices = [];
//		if (subLeg && subLeg.routePath)
//		{
//			var rpath = subLeg.routePath;
//
//			for ( var i in rpath.decodedLatitudes)
//			{
//				var lat = rpath.decodedLatitudes[i];
//				var lng = rpath.decodedLongitudes[i];
//				// lineVertices.push(new Microsoft.Maps.Location(lat, lng));
//				lineVertices.push(this.map.latLng(lat, lng));
//			}
//
//		}
//		return lineVertices;
//	},
	_getPolylineVerticesFromRoutePath: function(routePath)
	{
		var lineVertices = [];
		if (routePath && routePath.line && routePath.line.coordinates)
		{
			var coords = routePath.line.coordinates;

			for (var i = 0; i < coords.length; i++)
			{
				var lat = coords[i][0];
				var lng = coords[i][1];
				lineVertices.push(this.map.latLng(lat, lng));
			}

		}
		return lineVertices;
	},
	/**
	 * Executes the routing on bing maps provider.
	 * 
	 * @see Router.js#showRoute
	 */
	_routeQueueParalel: null,
	showRoute: function(stops, callback, errCb, a, instanceConf)
	{

		if(this._allowParallelRouteCreation == false)
		{
			if (this.isExecuting == true)
			{
				console.warn("there's a execution going on");
				this._routeQueueParalel.push({
					stops: stops,
					callback: callback,
					errCb: errCb,
					instanceConf: instanceConf
				});
				return;
			}
		}

// TODO: Remove this commented code (old bing javascript api method)
//		if (this._isLoaded == true)
//		{
			this.isExecuting = true;
			var failFct = function(error)
			{
				this.isExecuting = false;
				this._routeError(error, errCb);
			};
			var map = this.map.getProviderMap();

			var routeSummary = {
				distance: 0,
				time: 0
			};
			if (instanceConf != null && instanceConf.routecolor)
			{
				this.routecolor = instanceConf.routecolor;
			}
			var offset = 0;
			var vertices = [];
			var waypointsLocations = [];
			var itineraryInfo = [];
			var th = this._startTimer();
//			var complFct = function(response)
//			{
//				
//				var responseCloned = dojo.clone(response)
//
//				for ( var j in response.routeSummary)
//				{
//					routeSummary.distance += response.routeSummary[j].distance;
//					routeSummary.time += response.routeSummary[j].time;
//					console.log(j, "summary", response.routeSummary[j]);
//				}
//				var routeInfo = this._extractRouteInfo(response, map);
//
//				vertices = vertices.concat(routeInfo.polylineVertices);
//				itineraryInfo = itineraryInfo.concat(routeInfo.itineraryInfo);
//				waypointsLocations = waypointsLocations.concat(routeInfo.locations);
//				this._stopTimer(th, waypointsLocations.length);
//				var lastStop = routeInfo.lastWayPoint;
//
//				if (offset < stops.length)
//				{
//
//					var start = offset;
//					offset += this._routeLimits;
//
//					if (offset >= stops.length)
//					{
//						offset = stops.length;
//					}
//
//					if (start > 0)
//					{
//						start = start - 1;
//					}
//					th = this._startTimer();
//					this._calculateRoute(stops.slice(start, offset), dojo.hitch(this, complFct), errCb);
//				}
//				else
//				{
//					// adding last stop
//					waypointsLocations.push(lastStop);
//					// reset bing maps direction service otherwise it throws an
//					// exception if we request more than the max route stops
//					// limit
//					this.directionsService.resetDirections();
//					this._renderRoute(waypointsLocations, vertices, routeSummary, map, callback, errCb, itineraryInfo, stops, this.routecolor);
//
//				}
//
//			};
			var responseFromBingRestApi = function(response)
			{
				// TODO: Investigate if it is possible to have more
				// than one resourceSet and more than one resource
				if(response.resourceSets.length > 0)
				{
					var routeContent = response.resourceSets[0];
					
					routeSummary.distance = routeContent.travelDistance;
					routeSummary.time = routeContent.travelDuration;
					
					var routeInfo = this._extractRouteInfoFromRestResponse(routeContent);

					vertices = vertices.concat(routeInfo.polylineVertices);
					itineraryInfo = itineraryInfo.concat(routeInfo.itineraryInfo);
					waypointsLocations = waypointsLocations.concat(routeInfo.locations);
					this._stopTimer(th, waypointsLocations.length);
					var lastStop = routeInfo.lastWayPoint;

					if (offset < stops.length)
					{

						var start = offset;
						offset += this._routeLimits;

						if (offset >= stops.length)
						{
							offset = stops.length;
						}

						if (start > 0)
						{
							start = start - 1;
						}
						th = this._startTimer();
						this._calculateRouteUsingRestApi(stops.slice(start, offset), dojo.hitch(this, responseFromBingRestApi), dojo.hitch(this, failFct));
					}
					else
					{
						// adding last stop
						waypointsLocations.push(lastStop);
						this._renderRoute(waypointsLocations, vertices, routeSummary, map, callback, errCb, itineraryInfo, stops, instanceConf);

					}
				}
				else
				{
					if(response.hasOwnProperty("errorDetails"))
					{
						// Check whether the markers should be drawn even when the provider fails to generate a route
						if(this.map.getShowMarkersOnRouteError() == true)
						{
							this._renderRoute(null, [], routeSummary, map, callback, errCb, null, stops, instanceConf);
						}
						else
						{
							var errorStr = "";
							for(var k = 0; k < response.errorDetails.length; k++)
							{
								errorStr = errorStr + response.errorDetails[k] + " ";
							}
							errCb(ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.UNKNOWN,errorStr);
						}
					}
				}

			};
			if (offset < stops.length)
			{

				var start = offset;
				offset += this._routeLimits;

				if (offset >= stops.length)
				{
					offset = stops.length;
				}

				if (start > 0)
				{
					start = start - 1;
				}
				console.log("offset", start, offset, stops.slice(start, offset).length, " m ", this.map.getId());
				// console.trace();
// TODO: Remove this commented code (old bing javascript api method)
//				this._calculateRoute(stops.slice(start, offset), dojo.hitch(this, complFct), dojo.hitch(this, failFct));
				this._calculateRouteUsingRestApi(stops.slice(start, offset), dojo.hitch(this, responseFromBingRestApi), dojo.hitch(this, failFct));

			}

			return;

// TODO: Remove this commented code (old bing javascript api method)
//		}
//		else
//		{
//			// queueing a request until route module was not loaded
//			console.warn("wait");
//			this._routeQueue.push({
//				stops: stops,
//				callback: callback,
//				errCb: errCb,
//				instanceConf: instanceConf
//			});
//		}
	},
	/*
	 * Draw a list of stop locations,draw a polygon based on its vertices and
	 * execute the callback function with the route summary param.
	 */
	_renderRoute: function(waypointsLocations, vertices, routeSummary, map, callback, errCb, itineraryInfo, initialStops, instanceConf)
	{
		var color = instanceConf.routecolor;
		var lineWidth = this.routeLineWidth;
		var opacity = this.routeOpacity;
		var polylineParams = 
		{
			points: vertices,
			color: color,
			opacity: opacity,
			width: lineWidth
		};
		var poly = this.map.polyline(polylineParams);
				
		// If the waypointsLocations (provider points) array is null
		// use the initialStops so that at least the markers can be drawn.
		if((waypointsLocations == null))
		{	
			var points = [];
			for ( var i = 0; i < initialStops.length; i++)
			{
				points.push(this._convertMboToPoint(initialStops[i]));
			}
			routeSummary.stops = points;
		}
		else
		{
			routeSummary.stops = waypointsLocations;
		}
		
		routeSummary.polyline = poly;
		console.log("rendering routes");
		
		if (color.indexOf("#") != 0)
		{
			color = "#" + color;
		}
		var msColor = Microsoft.Maps.Color.fromHex(color);
		var wp = 
		{
			waypointPushpinOptions: {
				draggable: false
			},
			drivingPolylineOptions: {
				strokeColor: new Microsoft.Maps.Color(opacity*255, msColor.r, msColor.g, msColor.b),
				strokeThickness: lineWidth
			},

			autoUpdateMapView: false
		}
// TODO: Remove this commented code (old bing javascript api method)
//		var wp = this.directionsService.getRenderOptions().waypointPushpinOptions;
		wp.draggable = false;

		var customFct = function(opts)
		{
			this.wp = opts;
			this._counter = 0;
			this.getNext = function()
			{
				this.wp.text = this._generateMarkerText();
				return this.wp;
			};
			this._generateMarkerText = function()
			{

				var offset = (this._counter % 26);

				var dis = parseInt(this._counter / 26);
				var digit = String.fromCharCode(65 + offset);
				this._counter++;
				if (dis > 0)
				{
					digit += dis;
				}
				return digit;
			};
		};

		routeSummary.customMarkerOptions = new customFct(wp);

		routeSummary.itineraryLegInfo = itineraryInfo;
		console.log(itineraryInfo);
		this._stopTimer(null, routeSummary.stops.length);
		routeSummary.inputInfo = {
			stops: initialStops,
			successCb: callback,
			errorCb: errCb
		};
		routeSummary.originalRouter = this;
		routeSummary.instanceConf = instanceConf;
		this._routedOk(routeSummary, callback);
	},
	_convertMboToMSLocation: function(mboInfo)
	{
		var latLng = this._convertMboToPoint(mboInfo);
		var msPoint = new Microsoft.Maps.Location(latLng.lat, latLng.lng);
		return msPoint;

	},
	_convertMboToPoint: function(mboInfo)
	{
		var latLng;
		// Using the MXRecord wrapper to handle mboInfo's properties
		var mxRec = new ibm.tivoli.fwm.mxmap.MXRecord({
			mboInfo: mboInfo,
			map: this.map
		});

		if (mxRec.hasGISData())
		{
			// The first thing is to check if LBS data needs to be used
			// otherwise, go with the existing autolocate fall through logic
			if(mxRec.useLBSData())
			{
				if(mxRec.hasPointInCurrentSR())
				{
					latLng = mxRec.getPointInCurrentSR();
				}
				else
				{
					latLng = mxRec.getLBSCoordinates();
				}
			}
			else if (mxRec.hasGISCoordinates())
			{
				latLng = mxRec.getGISPoint();
			}
			else if (mxRec.hasAutolocateGISCoordinates())
			{
				latLng = mxRec.getAutolocateGISPoint();
			}
			else if (mxRec.hasOwnLatLngProperties())
			{
				latLng = mxRec.getOwnLatLng();
			}
			else
			{
				console.warn("Stop doesn't have gis coords", mboInfo);
			}
		}
		else
		{
			latLng = this.map.latLng(mboInfo.lat, mboInfo.lng);
		}
		return latLng;

	},
	/*
	 * Execute one route request against bing maps.
	 */
//	_calculateRoute: function(stops, callback, errCb)
//	{
//		var successHandler = null;
//		var errorHandler = null;
//		var success = function(arg)
//		{
//			if (successHandler)
//			{
//				Microsoft.Maps.Events.removeHandler(successHandler);
//			}
//			if (callback)
//			{
//				callback(arg);
//			}
//
//		};
//		var errorFct = function(error)
//		{
//			if (errorHandler)
//			{
//				Microsoft.Maps.Events.removeHandler(errorHandler);
//			}
//			if (errCb)
//			{
//				errCb(error);
//			}
//		};
//		errorHandler = Microsoft.Maps.Events.addHandler(this.directionsService, 'directionsError', dojo.hitch(this, errorFct));
//
//		successHandler = Microsoft.Maps.Events.addHandler(this.directionsService, 'directionsUpdated', dojo.hitch(this, success));
//		console.warn("resetDirections in _calculateRoute", this.c++);
//		this.directionsService.resetDirections();
//
//		
//		var reqOpts = {
//			routeMode: Microsoft.Maps.Directions.RouteMode.driving,
//			distanceUnit: Microsoft.Maps.Directions.DistanceUnit.kilometers,// requests
//																			// are
//																			// always
//																			// in
//																			// km
//
//			routeDraggable: false
//		};
//		if (this.getAvoidHighways() == true && this.getAvoidTolls() == true)
//		{
//			reqOpts.routeAvoidance = 12;
//		}
//		else if (this.getAvoidTolls() == true)
//		{
//			reqOpts.routeAvoidance = 8;
//		}
//		else if (this.getAvoidHighways() == true)
//		{
//			reqOpts.routeAvoidance = 4;
//		}
//		else
//		{
//			reqOpts.routeAvoidance = 0;
//		}
//		if (reqOpts.routeAvoidance && reqOpts.routeAvoidance == 0 && this.isOptimizeRoute())
//		{
//			reqOpts.routeOptimization = Microsoft.Maps.Directions.RouteOptimization.shortestDistance;
//		}
//		this.directionsService.setRequestOptions(reqOpts);
//		console.log("request options", reqOpts);
//		
//		var locArray = [];
//		for ( var i = 0; i < stops.length; i++)
//		{
//			var stop = stops[i];
//			// if(stop.hasOwnProperty("gisdata")){
//			// stop=stop.gisdata;
//			// }
//			var loc = this._convertMboToMSLocation(stop);// new
//															// Microsoft.Maps.Location(stop.lat,
//															// stop.lng);
//			var waypoint = new Microsoft.Maps.Directions.Waypoint({
//				location: loc
//			});
//			locArray.push(loc);
//			this.directionsService.addWaypoint(waypoint);
//		}
//		
//		var color = this.routecolor;
//		var lineWidth = this.routeLineWidth;
//		var opacity = this.routeOpacity;
//		
//		if (color.indexOf("#") != 0)
//		{
//			color = "#" + color;
//		}
//		
//		var msColor = Microsoft.Maps.Color.fromHex(color);
//				
//		this.directionsService.setRenderOptions({
//			waypointPushpinOptions: {
//				draggable: false
//			},
//			drivingPolylineOptions: {
//				strokeColor: new Microsoft.Maps.Color(opacity*255, msColor.r, msColor.g, msColor.b),
//				strokeThickness: lineWidth
//			},
//
//			autoUpdateMapView: false
//		});
//
//		this.directionsService.calculateDirections();
//		
//		
//		
//	},
	
	/*
	 * Execute one route request against bing maps.
	 */
	_calculateRouteUsingRestApi: function(stops, successCb, errCb)
	{
		var urlPrefix = this._routeBaseURL + '?';
		
		var wayPointsStr = "";
		for ( var i = 0; i < stops.length; i++)
		{
			if(i > 0)
			{
				wayPointsStr += "&"
			}
			var pt = this._convertMboToPoint(stops[i]);
			if((pt != null) && (pt != undefined))
			{
				wayPointsStr += "wp." + i + "=" + pt.lat + "," + pt.lng;
			}
		}
		
		var travelModeStr = "&travelMode=Driving";
		
		var distanceUnitStr = "&distanceUnit=km"; 
		
		var routePathStr = "&routePathOutput=Points";
		
		var avoidStr = "";
		if (this.getAvoidHighways() == true || this.getAvoidTolls() == true)
		{
			avoidStr = "&avoid=highways,tolls";
		}
		else if (this.getAvoidTolls() == true)
		{
			avoidStr = "&avoid=tolls";
		}
		else if (this.getAvoidHighways() == true)
		{
			avoidStr = "&avoid=highways";
		}
		
		var optimizeStr = "";
		if (avoidStr == "" && this.isOptimizeRoute())
		{
			optimizeStr = "&optmz=distance";
		}
		
		var keyStr = "&key=" + this.map.mapConf.key;
		
		var callbackFctName = "bingRouteCallback" + ibm.tivoli.fwm.mxmap.routing.impl.getRouteCallbackId();
		var callbackStr = "&jsonp=" + callbackFctName;
		
		window[callbackFctName] = function(response)
		{
			successCb(response);
			window[callbackFctName] = null;
		};
		
		var requestURL = urlPrefix + 
			wayPointsStr +
			travelModeStr +
			distanceUnitStr +
			routePathStr +
			avoidStr +
			optimizeStr +
			callbackStr + 
			keyStr;
		
		var xhrArgs = {
				url: requestURL,
				error: function(e) {
					errCb(ibm.tivoli.fwm.mxmap.routing.RoutingErrorCodes.UNKNOWN, e);
				}
			};

		dojo.io.script.get(xhrArgs);
		
	},

	/**
	 * remove MS handlers
	 */
	destroyRecursive: function()
	{
		this.inherited(arguments);// similar to
		// super.destroyRecursive().
		// arguments is mandatory
		// var
		for (var hid in this._msHandlers)
		{
			var handler = this._msHandlers[hid];
			if (!handler)
				continue;
			Microsoft.Maps.Events.removeHandler(handler);
		}
// TODO: Remove this commented code (old bing javascript api method)
//		this.directionsService.dispose();
	}

});



});

},
'dijit/Toolbar':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"require",
	"dojo/_base/declare", // declare
	"dojo/has",
	"dojo/keys", // keys.LEFT_ARROW keys.RIGHT_ARROW
	"dojo/ready",
	"./_Widget",
	"./_KeyNavContainer",
	"./_TemplatedMixin"
], function(require, declare, has, keys, ready, _Widget, _KeyNavContainer, _TemplatedMixin){

	// module:
	//		dijit/Toolbar


	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/ToolbarSeparator"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.Toolbar", [_Widget, _TemplatedMixin, _KeyNavContainer], {
		// summary:
		//		A Toolbar widget, used to hold things like `dijit/Editor` buttons

		templateString:
			'<div class="dijit" role="toolbar" tabIndex="${tabIndex}" data-dojo-attach-point="containerNode">' +
			'</div>',

		baseClass: "dijitToolbar",

		_onLeftArrow: function(){
			this.focusPrev();
		},

		_onRightArrow: function(){
			this.focusNext();
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/impl/geocoder/GmapsGeocoder':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Geocoder"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

dojo.require("ibm.tivoli.fwm.mxmap._Geocoder");
dojo.provide("ibm.tivoli.fwm.mxmap.impl.geocoder.GmapsGeocoder");

/**
 * GmapsGeocoder
 */
dojo.declare("ibm.tivoli.fwm.mxmap.impl.geocoder.GmapsGeocoder", ibm.tivoli.fwm.mxmap._Geocoder, {
	
	_init : function() {
		this.geocoder = new google.maps.Geocoder();
	},

	geocode : function(address)
	{
		var me = this;

		if (!address.hasOwnProperty('address') || address.address === null || address.address === '') {
			address.address = [ address.street, address.locality, address.region, address.country ].join(', ');
		}
		
		if (address.hasOwnProperty('lat') && (address.hasOwnProperty('lon') || address.hasOwnProperty('lng'))) {
			// command from mxn default implementation
			var lng = (address.lng) ? address.lng : address.lon;
			var lat = address.lat;
			var latlon = new google.maps.LatLng(lat,lng);
			
			this.geocoder.geocode( {
								'latLng': latlon
							}, function(results, status)
							{
								me.geocode_callback(results, status);
							});
		} else {
			
			var params= {
					'address' : address.address						
			};
			
			if(me.optParams.map && me.optParams.map.getBounds()){
				var ne = me.optParams.map.getBounds().getNorthEast();
				var sw = me.optParams.map.getBounds().getSouthWest();
				
				var bounds = new google.maps.LatLngBounds(sw.toProprietary(),ne.toProprietary());
				params.bounds=bounds;
				
			}
			
			this.geocoder.geocode(params, function(results, status) {
				me.geocode_callback(results, status);
			});
		}
	},

	geocode_callback : function(results, status) {
		var isBestMatch = function(candidate){
			var result = false;
			if(candidate.geometry && candidate.geometry.location_type){
				var locationType = candidate.geometry.location_type;				
				result = (locationType == google.maps.GeocoderLocationType.ROOFTOP);
			}
			return result;
		};
		
		// this is Maximo team update:
		var all_locations = [];
		if (status != google.maps.GeocoderStatus.OK) {
			this.error_callback(status);
		} else {
			for ( var rid in results) {
				var place = results[rid];
				var streetparts = [];
				var return_location = {
					street : '',
					locality : '',
					postcode : '',
					region : '',
					country : '',
					formatted_address : ''
				};
				return_location.formattedAddress = place.formatted_address;
				for ( var i = 0; i < place.address_components.length; i++) {
					var addressComponent = place.address_components[i];

					for ( var j = 0; j < addressComponent.types.length; j++) {
						var componentType = addressComponent.types[j];
						switch (componentType) {
						case 'country':
							return_location.country = addressComponent.long_name;
							break;
						case 'administrative_area_level_1':
							return_location.region = addressComponent.long_name;
							break;
						case 'locality':
							return_location.locality = addressComponent.long_name;
							break;
						case 'street_address':
							return_location.street = addressComponent.long_name;
							break;
						case 'postal_code':
							return_location.postcode = addressComponent.long_name;
							break;
						case 'street_number':
							streetparts.unshift(addressComponent.long_name);
							break;
						case 'route':
							streetparts.push(addressComponent.long_name);
							break;
						}
					}
				}

				if (return_location.street === '' && streetparts.length > 0) {
					return_location.street = streetparts.join(' ');
				}

				return_location.point = this.optParams.map.latLng(place.geometry.location.lat(), place.geometry.location.lng());

				if(isBestMatch(place) == true)
				{
					this.callback([return_location]);
					return;
				}					
				all_locations.push(return_location);					
			}			
			this.callback(all_locations);				
		}
	}
});

});

},
'ibm/tivoli/fwm/mxmap/routing/itinerary/Itinerary':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Base"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.routing.itinerary.Itinerary");
dojo.require("ibm.tivoli.fwm.mxmap._Base");

/**
 * Represents an intinerary among route stops.
 * 
 */
dojo.declare("ibm.tivoli.fwm.mxmap.routing.itinerary.Itinerary", ibm.tivoli.fwm.mxmap._Base, {
	initialLocation: null,
	legs: null,
	constructor: function(params)
	{
		dojo.mixin(this, params);
		this.legs = [];
		this.initialLocation = {};
	},
	setInitialLocation: function(info, location, locationMarker, clickCallback,needsToGeocode)
	{
		this.initialLocation = {
			location: location,
			info: info,
			needsToGeocode:needsToGeocode,
			marker: locationMarker,
			onclick: clickCallback
		};
	},
	addAllLegs: function(legs)
	{
		this.legs = this.legs.concat(legs);
	},
	addLeg: function(/* latLng */location, /*string with the stop info*/info,/*distance in km or miles*/ distanceToLeg,/*duration in minutes*/ durationToLeg, locationMarker, steps, clickCallback, pos)
	{
		var leg = {
			location: location,
			distanceToLeg: distanceToLeg,
			durationToLeg: durationToLeg,
			info: info,
			needsToGeocode:false,
			marker: locationMarker,
			steps: steps,
			onclick: clickCallback
		};
		if (!pos)
		{
			this.legs.push(leg);
			return this.legs.length-1;
		}
		else
		{
			this.legs[pos] = leg;
			return pos;
		}
		
	},
	getInitialLocation: function()
	{
		return this.initialLocation;
	},
	clearAll: function()
	{
		this.legs = [];
		this.initialLocation = {};
	}
});

});

},
'dijit/DropDownMenu':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/keys", // keys
	"dojo/text!./templates/Menu.html",
	"./_MenuBase"
], function(declare, keys, template, _MenuBase){

	// module:
	//		dijit/DropDownMenu

	return declare("dijit.DropDownMenu", _MenuBase, {
		// summary:
		//		A menu, without features for context menu (Meaning, drop down menu)

		templateString: template,

		baseClass: "dijitMenu",

		// Arrow key navigation
		_onUpArrow: function(){
			this.focusPrev();
		},
		_onDownArrow: function(){
			this.focusNext();
		},
		_onRightArrow: function(/*Event*/ evt){
			this._moveToPopup(evt);
			evt.stopPropagation();
			evt.preventDefault();
		},
		_onLeftArrow: function(/*Event*/ evt){
			if(this.parentMenu){
				if(this.parentMenu._isMenuBar){
					this.parentMenu.focusPrev();
				}else{
					this.onCancel(false);
				}
			}else{
				evt.stopPropagation();
				evt.preventDefault();
			}
		}
	});
});

},
'dijit/_AttachMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"require",
	"dojo/_base/array", // array.forEach
	"dojo/_base/connect",	// remove for 2.0
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.getObject
	"dojo/mouse",
	"dojo/on",
	"dojo/touch",
	"./_WidgetBase"
], function(require, array, connect, declare, lang, mouse, on, touch, _WidgetBase){

	// module:
	//		dijit/_AttachMixin

	// Map from string name like "mouseenter" to synthetic event like mouse.enter
	var synthEvents = lang.delegate(touch, {
		"mouseenter": mouse.enter,
		"mouseleave": mouse.leave,
		"keypress": connect._keypress	// remove for 2.0
	});

	// To be lightweight, _AttachMixin doesn't require() dijit/a11yclick.
	// If the subclass has a template using "ondijitclick", it must load dijit/a11yclick itself.
	// In that case, the a11yclick variable below will get set to point to that synthetic event.
	var a11yclick;

	var _AttachMixin = declare("dijit._AttachMixin", null, {
		// summary:
		//		Mixin for widgets to attach to dom nodes and setup events via
		//		convenient data-dojo-attach-point and data-dojo-attach-event DOM attributes.
		//
		//		Superclass of _TemplatedMixin, and can also be used standalone when templates are pre-rendered on the
		//		server.
		//
		//		Does not [yet] handle widgets like ContentPane with this.containerNode set.   It should skip
		//		scanning for data-dojo-attach-point and data-dojo-attach-event inside this.containerNode, but it
		//		doesn't.

/*=====
		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with data-dojo-attach-point=... in the
		//		template, ex: ["containerNode", "labelNode"]
		_attachPoints: [],

		// _attachEvents: [private] Handle[]
		//		List of connections associated with data-dojo-attach-event=... in the
		//		template
		_attachEvents: [],

		// attachScope: [public] Object
		//		Object to which attach points and events will be scoped.  Defaults
		//		to 'this'.
		attachScope: undefined,

		// searchContainerNode: [protected] Boolean
		//		Search descendants of this.containerNode for data-dojo-attach-point and data-dojo-attach-event.
		//		Should generally be left false (the default value) both for performance and to avoid failures when
		//		this.containerNode holds other _AttachMixin instances with their own attach points and events.
 		searchContainerNode: false,
 =====*/

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.

			this._attachPoints = [];
			this._attachEvents = [];
		},


		buildRendering: function(){
			// summary:
			//		Attach to DOM nodes marked with special attributes.
			// tags:
			//		protected

			this.inherited(arguments);

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(this.domNode);

			this._beforeFillContent();		// hook for _WidgetsInTemplateMixin
		},

		_beforeFillContent: function(){
		},

		_attachTemplateNodes: function(rootNode){
			// summary:
			//		Iterate through the dom nodes and attach functions and nodes accordingly.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//
			//		- dojoAttachPoint/data-dojo-attach-point
			//		- dojoAttachEvent/data-dojo-attach-event
			// rootNode: DomNode
			//		The node to search for properties. All descendants will be searched.
			// tags:
			//		private

			// DFS to process all nodes except those inside of this.containerNode
			var node = rootNode;
			while(true){
				if(node.nodeType == 1 && (this._processTemplateNode(node, function(n,p){ return n.getAttribute(p); },
						this._attach) || this.searchContainerNode) && node.firstChild){
					node = node.firstChild;
				}else{
					if(node == rootNode){ return; }
					while(!node.nextSibling){
						node = node.parentNode;
						if(node == rootNode){ return; }
					}
					node = node.nextSibling;
				}
			}
		},

		_processTemplateNode: function(/*DOMNode|Widget*/ baseNode, getAttrFunc, attachFunc){
			// summary:
			//		Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.
			//		Returns true if caller should process baseNode's children too.

			var ret = true;

			// Process data-dojo-attach-point
			var _attachScope = this.attachScope || this,
				attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
			if(attachPoint){
				var point, points = attachPoint.split(/\s*,\s*/);
				while((point = points.shift())){
					if(lang.isArray(_attachScope[point])){
						_attachScope[point].push(baseNode);
					}else{
						_attachScope[point] = baseNode;
					}
					ret = (point != "containerNode");
					this._attachPoints.push(point);
				}
			}

			// Process data-dojo-attach-event
			var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");
			if(attachEvent){
				// NOTE: we want to support attributes that have the form
				// "domEvent: nativeEvent, ..."
				var event, events = attachEvent.split(/\s*,\s*/);
				var trim = lang.trim;
				while((event = events.shift())){
					if(event){
						var thisFunc = null;
						if(event.indexOf(":") != -1){
							// oh, if only JS had tuple assignment
							var funcNameArr = event.split(":");
							event = trim(funcNameArr[0]);
							thisFunc = trim(funcNameArr[1]);
						}else{
							event = trim(event);
						}
						if(!thisFunc){
							thisFunc = event;
						}

						this._attachEvents.push(attachFunc(baseNode, event, lang.hitch(_attachScope, thisFunc)));
					}
				}
			}

			return ret;
		},

		_attach: function(node, type, func){
			// summary:
			//		Roughly corresponding to dojo/on, this is the default function for processing a
			//		data-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.
			// node: DOMNode
			//		The node to setup a listener on.
			// type: String
			//		Event name like "click".
			// getAttrFunc: Function
			//		Function to get the specified property for a given DomNode/Widget.
			// attachFunc: Function?
			//		Attaches an event handler from the specified node/widget to specified function.

			// Map special type names like "mouseenter" to synthetic events.
			// Subclasses are responsible to require() dijit/a11yclick if they want to use it.
			type = type.replace(/^on/, "").toLowerCase();
			if(type == "dijitclick"){
				type = a11yclick || (a11yclick = require("./a11yclick"));
			}else{
				type = synthEvents[type] || type;
			}

			return on(node, type, func);
		},

		_detachTemplateNodes: function() {
			// summary:
			//		Detach and clean up the attachments made in _attachtempalteNodes.

			// Delete all attach points to prevent IE6 memory leaks.
			var _attachScope = this.attachScope || this;
			array.forEach(this._attachPoints, function(point){
				delete _attachScope[point];
			});
			this._attachPoints = [];

			// And same for event handlers
			array.forEach(this._attachEvents, function(handle){ handle.remove(); });
			this._attachEvents = [];
		},

		destroyRendering: function(){
			this._detachTemplateNodes();
			this.inherited(arguments);
		}
	});

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.).
	// Remove for 2.0.   Also, hide from API doc parser.
	lang.extend(_WidgetBase, /*===== {} || =====*/ {
		dojoAttachEvent: "",
		dojoAttachPoint: ""
	});
	
	return _AttachMixin;
});

},
'dijit/form/_FormMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.every array.filter array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch lang.isArray
	"dojo/on",
	"dojo/window" // winUtils.scrollIntoView
], function(array, declare, kernel, lang, on, winUtils){

	// module:
	//		dijit/form/_FormMixin

	return declare("dijit.form._FormMixin", null, {
		// summary:
		//		Mixin for containers of form widgets (i.e. widgets that represent a single value
		//		and can be children of a `<form>` node or `dijit/form/Form` widget)
		// description:
		//		Can extract all the form widgets
		//		values and combine them into a single javascript object, or alternately
		//		take such an object and set the values for all the contained
		//		form widgets

	/*=====
		// value: Object
		//		Name/value hash for each child widget with a name and value.
		//		Child widgets without names are not part of the hash.
		//
		//		If there are multiple child widgets w/the same name, value is an array,
		//		unless they are radio buttons in which case value is a scalar (since only
		//		one radio button can be checked at a time).
		//
		//		If a child widget's name is a dot separated list (like a.b.c.d), it's a nested structure.
		//
		//		Example:
		//	|	{ name: "John Smith", interests: ["sports", "movies"] }
	=====*/

		// state: [readonly] String
		//		Will be "Error" if one or more of the child widgets has an invalid value,
		//		"Incomplete" if not all of the required child widgets are filled in.  Otherwise, "",
		//		which indicates that the form is ready to be submitted.
		state: "",

		// TODO:
		//	* Repeater
		//	* better handling for arrays.  Often form elements have names with [] like
		//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])


		_getDescendantFormWidgets: function(/*dijit/_WidgetBase[]?*/ children){
			// summary:
			//		Returns all form widget descendants, searching through non-form child widgets like BorderContainer
			var res = [];
			array.forEach(children || this.getChildren(), function(child){
				if("value" in child){
					res.push(child);
				}else{
					res = res.concat(this._getDescendantFormWidgets(child.getChildren()));
				}
			}, this);
			return res;
		},

		reset: function(){
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(widget.reset){
					widget.reset();
				}
			});
		},

		validate: function(){
			// summary:
			//		returns if the form is valid - same as isValid - but
			//		provides a few additional (ui-specific) features:
			//
			//		1. it will highlight any sub-widgets that are not valid
			//		2. it will call focus() on the first invalid sub-widget
			var didFocus = false;
			return array.every(array.map(this._getDescendantFormWidgets(), function(widget){
				// Need to set this so that "required" widgets get their
				// state set.
				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if(!valid && !didFocus){
					// Set focus of the first non-valid widget
					winUtils.scrollIntoView(widget.containerNode || widget.domNode);
					widget.focus();
					didFocus = true;
				}
				return valid;
			}), function(item){ return item; });
		},

		setValues: function(val){
			kernel.deprecated(this.declaredClass+"::setValues() is deprecated. Use set('value', val) instead.", "", "2.0");
			return this.set('value', val);
		},
		_setValueAttr: function(/*Object*/ obj){
			// summary:
			//		Fill in form values from according to an Object (in the format returned by get('value'))

			// generate map from name --> [list of widgets with that name]
			var map = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(!widget.name){ return; }
				var entry = map[widget.name] || (map[widget.name] = [] );
				entry.push(widget);
			});

			for(var name in map){
				if(!map.hasOwnProperty(name)){
					continue;
				}
				var widgets = map[name],						// array of widgets w/this name
					values = lang.getObject(name, false, obj);	// list of values for those widgets

				if(values === undefined){
					continue;
				}
				values = [].concat(values);
				if(typeof widgets[0].checked == 'boolean'){
					// for checkbox/radio, values is a list of which widgets should be checked
					array.forEach(widgets, function(w){
						w.set('value', array.indexOf(values, w._get('value')) != -1);
					});
				}else if(widgets[0].multiple){
					// it takes an array (e.g. multi-select)
					widgets[0].set('value', values);
				}else{
					// otherwise, values is a list of values to be assigned sequentially to each widget
					array.forEach(widgets, function(w, i){
						w.set('value', values[i]);
					});
				}
			}

			/***
			 *	TODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)

			array.forEach(this.containerNode.elements, function(element){
				if(element.name == ''){return};	// like "continue"
				var namePath = element.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var p=namePath[j - 1];
					// repeater support block
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if

						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
						myObj=myObj[nameA[0]][nameIndex];
						continue;
					} // repeater support ends

					if(typeof(myObj[p]) == "undefined"){
						myObj=undefined;
						break;
					};
					myObj=myObj[p];
				}

				if(typeof(myObj) == "undefined"){
					return;		// like "continue"
				}
				if(typeof(myObj[name]) == "undefined" && this.ignoreNullValues){
					return;		// like "continue"
				}

				// TODO: widget values (just call set('value', ...) on the widget)

				// TODO: maybe should call dojo.getNodeProp() instead
				switch(element.type){
					case "checkbox":
						element.checked = (name in myObj) &&
							array.some(myObj[name], function(val){ return val == element.value; });
						break;
					case "radio":
						element.checked = (name in myObj) && myObj[name] == element.value;
						break;
					case "select-multiple":
						element.selectedIndex=-1;
						array.forEach(element.options, function(option){
							option.selected = array.some(myObj[name], function(val){ return option.value == val; });
						});
						break;
					case "select-one":
						element.selectedIndex="0";
						array.forEach(element.options, function(option){
							option.selected = option.value == myObj[name];
						});
						break;
					case "hidden":
					case "text":
					case "textarea":
					case "password":
						element.value = myObj[name] || "";
						break;
				}
			});
			*/

			// Note: no need to call this._set("value", ...) as the child updates will trigger onChange events
			// which I am monitoring.
		},

		getValues: function(){
			kernel.deprecated(this.declaredClass+"::getValues() is deprecated. Use get('value') instead.", "", "2.0");
			return this.get('value');
		},
		_getValueAttr: function(){
			// summary:
			//		Returns Object representing form values.   See description of `value` for details.
			// description:

			// The value is updated into this.value every time a child has an onChange event,
			// so in the common case this function could just return this.value.   However,
			// that wouldn't work when:
			//
			// 1. User presses return key to submit a form.  That doesn't fire an onchange event,
			// and even if it did it would come too late due to the defer(...) in _handleOnChange()
			//
			// 2. app for some reason calls this.get("value") while the user is typing into a
			// form field.   Not sure if that case needs to be supported or not.

			// get widget values
			var obj = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				var name = widget.name;
				if(!name || widget.disabled){ return; }

				// Single value widget (checkbox, radio, or plain <input> type widget)
				var value = widget.get('value');

				// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays
				if(typeof widget.checked == 'boolean'){
					if(/Radio/.test(widget.declaredClass)){
						// radio button
						if(value !== false){
							lang.setObject(name, value, obj);
						}else{
							// give radio widgets a default of null
							value = lang.getObject(name, false, obj);
							if(value === undefined){
								lang.setObject(name, null, obj);
							}
						}
					}else{
						// checkbox/toggle button
						var ary=lang.getObject(name, false, obj);
						if(!ary){
							ary=[];
							lang.setObject(name, ary, obj);
						}
						if(value !== false){
							ary.push(value);
						}
					}
				}else{
					var prev=lang.getObject(name, false, obj);
					if(typeof prev != "undefined"){
						if(lang.isArray(prev)){
							prev.push(value);
						}else{
							lang.setObject(name, [prev, value], obj);
						}
					}else{
						// unique name
						lang.setObject(name, value, obj);
					}
				}
			});

			/***
			 * code for plain input boxes (see also domForm.formToObject, can we use that instead of this code?
			 * but it doesn't understand [] notation, presumably)
			var obj = { };
			array.forEach(this.containerNode.elements, function(elm){
				if(!elm.name)	{
					return;		// like "continue"
				}
				var namePath = elm.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var nameIndex = null;
					var p=namePath[j - 1];
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if
						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
					}else if(typeof(myObj[nameA[0]]) == "undefined"){
						myObj[nameA[0]] = { }
					} // if

					if(nameA.length == 1){
						myObj=myObj[nameA[0]];
					}else{
						myObj=myObj[nameA[0]][nameIndex];
					} // if
				} // for

				if((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type == "radio" && elm.checked)){
					if(name == name.split("[")[0]){
						myObj[name]=elm.value;
					}else{
						// can not set value when there is no name
					}
				}else if(elm.type == "checkbox" && elm.checked){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					myObj[name].push(elm.value);
				}else if(elm.type == "select-multiple"){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					for(var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){
						if(elm.options[jdx].selected){
							myObj[name].push(elm.options[jdx].value);
						}
					}
				} // if
				name=undefined;
			}); // forEach
			***/
			return obj;
		},

		isValid: function(){
			// summary:
			//		Returns true if all of the widgets are valid.
			//		Deprecated, will be removed in 2.0.  Use get("state") instead.

			return this.state == "";
		},

		onValidStateChange: function(/*Boolean*/ /*===== isValid =====*/){
			// summary:
			//		Stub function to connect to if you want to do something
			//		(like disable/enable a submit button) when the valid
			//		state changes on the form as a whole.
			//
			//		Deprecated.  Will be removed in 2.0.  Use watch("state", ...) instead.
		},

		_getState: function(){
			// summary:
			//		Compute what this.state should be based on state of children
			var states = array.map(this._descendants, function(w){
				return w.get("state") || "";
			});

			return array.indexOf(states, "Error") >= 0 ? "Error" :
				array.indexOf(states, "Incomplete") >= 0 ? "Incomplete" : "";
		},

		disconnectChildren: function(){
			// summary:
			//		Deprecated method.   Applications no longer need to call this.   Remove for 2.0.
		},

		connectChildren: function(/*Boolean*/ inStartup){
			// summary:
			//		You can call this function directly, ex. in the event that you
			//		programmatically add a widget to the form *after* the form has been
			//		initialized.

			// TODO: rename for 2.0

			this._descendants = this._getDescendantFormWidgets();

			// To get notifications from children they need to be started.   Children didn't used to need to be started,
			// so for back-compat, start them here
			array.forEach(this._descendants, function(child){
				if(!child._started){ child.startup(); }
			});

			if(!inStartup){
				this._onChildChange();
			}
		},

		_onChildChange: function(/*String*/ attr){
			// summary:
			//		Called when child's value or disabled state changes

			// The unit tests expect state update to be synchronous, so update it immediately.
			if(!attr || attr == "state" || attr == "disabled"){
				this._set("state", this._getState());
			}

			// Use defer() to collapse value changes in multiple children into a single
			// update to my value.   Multiple updates will occur on:
			//	1. Form.set()
			//	2. Form.reset()
			//	3. user selecting a radio button (which will de-select another radio button,
			//		 causing two onChange events)
			if(!attr || attr == "value" || attr == "disabled" || attr == "checked"){
				if(this._onChangeDelayTimer){
					this._onChangeDelayTimer.remove();
				}
				this._onChangeDelayTimer = this.defer(function(){
					delete this._onChangeDelayTimer;
					this._set("value", this.get("value"));
				}, 10);
			}
		},

		startup: function(){
			this.inherited(arguments);

			// Set initial this.value and this.state.   Don't emit watch() notifications.
			this._descendants = this._getDescendantFormWidgets();
			this.value = this.get("value");
			this.state = this._getState();

			// Initialize value and valid/invalid state tracking.
			var self = this;
			this.own(
				on(
					this.containerNode,
					"attrmodified-state, attrmodified-disabled, attrmodified-value, attrmodified-checked",
					function(evt){
						if(evt.target == self.domNode){
							return;	// ignore events that I fire on myself because my children changed
						}
						self._onChildChange(evt.type.replace("attrmodified-", ""));
					}
				)
			);

			// Make state change call onValidStateChange(), will be removed in 2.0
			this.watch("state", function(attr, oldVal, newVal){ this.onValidStateChange(newVal == ""); });
		},

		destroy: function(){
			this.inherited(arguments);
		}

	});
});

},
'dijit/Menu':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"require",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId dom.isDescendant
	"dojo/dom-attr", // domAttr.get domAttr.set domAttr.has domAttr.remove
	"dojo/dom-geometry", // domStyle.getComputedStyle domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/keys", // keys.F10
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie"), has("quirks")
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.get
	"./popup",
	"./DropDownMenu",
	"dojo/ready"
], function(require, array, declare, dom, domAttr, domGeometry, domStyle, keys, lang, on, has, win, winUtils, pm, DropDownMenu, ready){

	// module:
	//		dijit/Menu

	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/MenuItem", "dijit/PopupMenuItem", "dijit/CheckedMenuItem", "dijit/MenuSeparator"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.Menu", DropDownMenu, {
		// summary:
		//		A context menu you can assign to multiple elements

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- replace srcNodeRef with my generated DOM tree

			this._bindings = [];
		},

		// targetNodeIds: [const] String[]
		//		Array of dom node ids of nodes to attach to.
		//		Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
		targetNodeIds: [],

		// selector: String?
		//		CSS expression to apply this Menu to descendants of targetNodeIds, rather than to
		//		the nodes specified by targetNodeIds themselves.  Useful for applying a Menu to
		//		a range of rows in a table, tree, etc.
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		selector: "",

		// TODO: in 2.0 remove support for multiple targetNodeIds.   selector gives the same effect.
		// So, change targetNodeIds to a targetNodeId: "", remove bindDomNode()/unBindDomNode(), etc.

		/*=====
		// currentTarget: [readonly] DOMNode
		//		For context menus, set to the current node that the Menu is being displayed for.
		//		Useful so that the menu actions can be tailored according to the node
		currentTarget: null,
		=====*/

		// contextMenuForWindow: [const] Boolean
		//		If true, right clicking anywhere on the window will cause this context menu to open.
		//		If false, must specify targetNodeIds.
		contextMenuForWindow: false,

		// leftClickToOpen: [const] Boolean
		//		If true, menu will open on left click instead of right click, similar to a file menu.
		leftClickToOpen: false,
		// TODO: remove in 2.0, we have better ways of opening a menu with a left click, by extending _HasDropDown.

		// refocus: Boolean
		//		When this menu closes, re-focus the element which had focus before it was opened.
		refocus: true,

		postCreate: function(){
			if(this.contextMenuForWindow){
				this.bindDomNode(this.ownerDocumentBody);
			}else{
				array.forEach(this.targetNodeIds, this.bindDomNode, this);
			}
			this.inherited(arguments);
		},

		// thanks burstlib!
		_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){
			// summary:
			//		Returns the window reference of the passed iframe
			// tags:
			//		private
			return winUtils.get(this._iframeContentDocument(iframe_el)) ||
				// Moz. TODO: is this available when defaultView isn't?
				this._iframeContentDocument(iframe_el)['__parent__'] ||
				(iframe_el.name && document.frames[iframe_el.name]) || null;	//	Window
		},

		_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){
			// summary:
			//		Returns a reference to the document object inside iframe_el
			// tags:
			//		protected
			return iframe_el.contentDocument // W3
				|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE
				|| (iframe_el.name && document.frames[iframe_el.name] && document.frames[iframe_el.name].document)
				|| null;	//	HTMLDocument
		},

		bindDomNode: function(/*String|DomNode*/ node){
			// summary:
			//		Attach menu to given node
			node = dom.byId(node, this.ownerDocument);

			var cn;	// Connect node

			// Support context menus on iframes.  Rather than binding to the iframe itself we need
			// to bind to the <body> node inside the iframe.
			if(node.tagName.toLowerCase() == "iframe"){
				var iframe = node,
					window = this._iframeContentWindow(iframe);
				cn = win.body(window.document);
			}else{
				// To capture these events at the top level, attach to <html>, not <body>.
				// Otherwise right-click context menu just doesn't work.
				cn = (node == win.body(this.ownerDocument) ? this.ownerDocument.documentElement : node);
			}


			// "binding" is the object to track our connection to the node (ie, the parameter to bindDomNode())
			var binding = {
				node: node,
				iframe: iframe
			};

			// Save info about binding in _bindings[], and make node itself record index(+1) into
			// _bindings[] array.  Prefix w/_dijitMenu to avoid setting an attribute that may
			// start with a number, which fails on FF/safari.
			domAttr.set(node, "_dijitMenu" + this.id, this._bindings.push(binding));

			// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished
			// loading yet, in which case we need to wait for the onload event first, and then connect
			// On linux Shift-F10 produces the oncontextmenu event, but on Windows it doesn't, so
			// we need to monitor keyboard events in addition to the oncontextmenu event.
			var doConnects = lang.hitch(this, function(cn){
				var selector = this.selector,
					delegatedEvent = selector ?
						function(eventType){
							return on.selector(selector, eventType);
						} :
						function(eventType){
							return eventType;
						},
					self = this;
				return [
					on(cn, delegatedEvent(this.leftClickToOpen ? "click" : "contextmenu"), function(evt){
						evt.stopPropagation();
						evt.preventDefault();

						if((new Date()).getTime() < self._lastKeyDown + 500){
							// Ignore contextmenu/click events that were already processed in keydown handler below.
							// But still call preventDefault() (above) so system context menu doesn't appear.
							return;
						}

						// Schedule context menu to be opened.
						// Note that this won't work will if the click was generated by the keyboard, while
						// focused on a <button> etc.   In that case evt.pageX and evt.pageY are either (0,0) or
						// wherever the mouse cursor is.  See keydown handler below.
						self._scheduleOpen(this, iframe, {x: evt.pageX, y: evt.pageY}, evt.target);
					}),
					on(cn, delegatedEvent("keydown"), function(evt){
						if(evt.keyCode == 93 ||									// context menu key
							(evt.shiftKey && evt.keyCode == keys.F10) ||		// shift-F10
							(self.leftClickToOpen && evt.keyCode == keys.SPACE)	// space key
						){
							evt.stopPropagation();
							evt.preventDefault();

							// Open the menu around evt.target.  Note that "this" and evt.target
							// are likely different, especially for global context menu, where "this" is <body>.
							self._scheduleOpen(this, iframe, null, evt.target);	// no coords - open near evt.target

							self._lastKeyDown = (new Date()).getTime();
						}
					})
				];
			});
			binding.connects = cn ? doConnects(cn) : [];

			if(iframe){
				// Setup handler to [re]bind to the iframe when the contents are initially loaded,
				// and every time the contents change.
				// Need to do this b/c we are actually binding to the iframe's <body> node.
				// Note: can't use connect.connect(), see #9609.

				binding.onloadHandler = lang.hitch(this, function(){
					// want to remove old connections, but IE throws exceptions when trying to
					// access the <body> node because it's already gone, or at least in a state of limbo

					var window = this._iframeContentWindow(iframe),
						cn = win.body(window.document);
					binding.connects = doConnects(cn);
				});
				if(iframe.addEventListener){
					iframe.addEventListener("load", binding.onloadHandler, false);
				}else{
					iframe.attachEvent("onload", binding.onloadHandler);
				}
			}
		},

		unBindDomNode: function(/*String|DomNode*/ nodeName){
			// summary:
			//		Detach menu from given node

			var node;
			try{
				node = dom.byId(nodeName, this.ownerDocument);
			}catch(e){
				// On IE the dom.byId() call will get an exception if the attach point was
				// the <body> node of an <iframe> that has since been reloaded (and thus the
				// <body> node is in a limbo state of destruction.
				return;
			}

			// node["_dijitMenu" + this.id] contains index(+1) into my _bindings[] array
			var attrName = "_dijitMenu" + this.id;
			if(node && domAttr.has(node, attrName)){
				var bid = domAttr.get(node, attrName) - 1, b = this._bindings[bid], h;
				while((h = b.connects.pop())){
					h.remove();
				}

				// Remove listener for iframe onload events
				var iframe = b.iframe;
				if(iframe){
					if(iframe.removeEventListener){
						iframe.removeEventListener("load", b.onloadHandler, false);
					}else{
						iframe.detachEvent("onload", b.onloadHandler);
					}
				}

				domAttr.remove(node, attrName);
				delete this._bindings[bid];
			}
		},

		_scheduleOpen: function(delegatedTarget, iframe, coords, target){
			// summary:
			//		Set timer to display myself.  Using a timer rather than displaying immediately solves
			//		IE problem: without the delay, focus work in "open" causes the system
			//		context menu to appear in spite of evt.preventDefault().
			// delegatedTarget: Element
			//		The node specified in targetNodeIds or matching selector that the menu is being opened for.
			// iframe: HTMLIframeElement?
			//		Set if target is inside the specified iframe.
			// coords: Object
			//		x/y position to center the menu around.  Undefined if menu was opened via keyboard.
			// target: Element
			//		The actual clicked node, either delegatedTarget or a descendant.

			if(!this._openTimer){
				this._openTimer = this.defer(function(){
					delete this._openTimer;
					this._openMyself({
						target: target,
						delegatedTarget: delegatedTarget,
						iframe: iframe,
						coords: coords
					});
				}, 1);
			}
		},

		_openMyself: function(args){
			// summary:
			//		Internal function for opening myself when the user does a right-click or something similar.
			// args:
			//		This is an Object containing:
			//
			//		- target: The node that is being clicked.
			//		- delegatedTarget: The node from this.targetNodeIds or matching this.selector,
			//		  either the same as target or an ancestor of target.
			//		- iframe: If an `<iframe>` is being clicked, iframe points to that iframe
			//		- coords: Mouse cursor x/y coordinates.  Null when opened via keyboard.
			//		  Put menu at specified position in iframe (if iframe specified) or otherwise in viewport.
			//
			//		_openMyself() formerly took the event object, and since various code references
			//		evt.target (after connecting to _openMyself()), using an Object for parameters
			//		(so that old code still works).

			var target = args.target,
				iframe = args.iframe,
				coords = args.coords,
				byKeyboard = !coords;

			// To be used by MenuItem event handlers to tell which node the menu was opened on
			this.currentTarget = args.delegatedTarget;

			// Get coordinates to open menu, either at specified (mouse) position or (if triggered via keyboard)
			// then near the node the menu is assigned to.
			if(coords){
				if(iframe){
					// Specified coordinates are on <body> node of an <iframe>, convert to match main document
					var ifc = domGeometry.position(iframe, true),
						window = this._iframeContentWindow(iframe),
						scroll = domGeometry.docScroll(window.document);

					var cs = domStyle.getComputedStyle(iframe),
						tp = domStyle.toPixelValue,
						left = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingLeft)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderLeftWidth) : 0),
						top = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingTop)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderTopWidth) : 0);

					coords.x += ifc.x + left - scroll.x;
					coords.y += ifc.y + top - scroll.y;
				}
			}else{
				coords = domGeometry.position(target, true);
				coords.x += 10;
				coords.y += 10;
			}

			var self = this;
			var prevFocusNode = this._focusManager.get("prevNode");
			var curFocusNode = this._focusManager.get("curNode");
			var savedFocusNode = !curFocusNode || (dom.isDescendant(curFocusNode, this.domNode)) ? prevFocusNode : curFocusNode;

			function closeAndRestoreFocus(){
				// user has clicked on a menu or popup
				if(self.refocus && savedFocusNode){
					savedFocusNode.focus();
				}
				pm.close(self);
			}

			pm.open({
				popup: this,
				x: coords.x,
				y: coords.y,
				onExecute: closeAndRestoreFocus,
				onCancel: closeAndRestoreFocus,
				orient: this.isLeftToRight() ? 'L' : 'R'
			});

			// Focus the menu even when opened by mouse, so that a click on blank area of screen will close it
			this.focus();
			if(!byKeyboard){
				// But then (when opened by mouse), mark Menu as passive, so that the first item isn't highlighted.
				// On IE9+ this needs to be on a delay because the focus is asynchronous.
				this.defer(function(){
					this._cleanUp(true);
				});
			}

			this._onBlur = function(){
				this.inherited('_onBlur', arguments);
				// Usually the parent closes the child widget but if this is a context
				// menu then there is no parent
				pm.close(this);
				// don't try to restore focus; user has clicked another part of the screen
				// and set focus there
			};
		},

		destroy: function(){
			array.forEach(this._bindings, function(b){
				if(b){
					this.unBindDomNode(b.node);
				}
			}, this);
			this.inherited(arguments);
		}
	});
});

},
'dijit/form/_CheckBoxMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/dom-attr" // domAttr.set
], function(declare, domAttr){

	// module:
	//		dijit/form/_CheckBoxMixin

	return declare("dijit.form._CheckBoxMixin", null, {
		// summary:
		//		Mixin to provide widget functionality corresponding to an HTML checkbox
		//
		// description:
		//		User interacts with real html inputs.
		//		On onclick (which occurs by mouse click, space-bar, or
		//		using the arrow keys to switch the selected radio button),
		//		we update the state of the checkbox/radio.
		//

		// type: [private] String
		//		type attribute on `<input>` node.
		//		Overrides `dijit/form/Button.type`.  Users should not change this value.
		type: "checkbox",

		// value: String
		//		As an initialization parameter, equivalent to value field on normal checkbox
		//		(if checked, the value is passed as the value when form is submitted).
		value: "on",

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,

		// aria-pressed for toggle buttons, and aria-checked for checkboxes
		_aria_attr: "aria-checked",

		_setReadOnlyAttr: function(/*Boolean*/ value){
			this._set("readOnly", value);
			domAttr.set(this.focusNode, 'readOnly', value);
		},

		// Override dijit/form/Button._setLabelAttr() since we don't even have a containerNode.
		// Normally users won't try to set label, except when CheckBox or RadioButton is the child of a dojox/layout/TabContainer
		_setLabelAttr: undefined,

		_getSubmitValue: function(/*String*/ value){
			return (value == null || value === "") ? "on" : value;
		},

		_setValueAttr: function(newValue){
			newValue = this._getSubmitValue(newValue);	// "on" to match browser native behavior when value unspecified
			this._set("value", newValue);
			domAttr.set(this.focusNode, "value", newValue);
		},

		reset: function(){
			this.inherited(arguments);
			// Handle unlikely event that the <input type=checkbox> value attribute has changed
			this._set("value", this._getSubmitValue(this.params.value));
			domAttr.set(this.focusNode, 'value', this.value);
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to handle click actions - need to check
			//		readOnly, since button no longer does that check.
			if(this.readOnly){
				e.stopPropagation();
				e.preventDefault();
				return false;
			}
			return this.inherited(arguments);
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/QueryWeatherAlerts':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/toolbar/ext/_ToggleTool,dijit/form/Button"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.toolbar.ext.QueryWeatherAlerts");

dojo.require("ibm.tivoli.fwm.mxmap.toolbar.ext._ToggleTool");
dojo.require("dijit.form.Button");

/**
 * Query nearby resources tool
 */
dojo.declare("ibm.tivoli.fwm.mxmap.toolbar.ext.QueryWeatherAlerts", ibm.tivoli.fwm.mxmap.toolbar.ext._ToggleTool, {
	label: "Weather Alerts",
	iconClass: "basicMapToolbarBtn weatherAlertsMapToolbarBtn",
	map: null,
	constructor: function(params)
	{
		dojo.mixin(this, params);
		var _label = ibm.tivoli.fwm.i18n.getMaxMsg("map", "weatheralertstool");
		this.label = _label || this.label;

		this.addSubscription("onMapRefresh_" + this.map.getId(), dojo.hitch(this, this._onMapRefresh));
	},
	updateLayers: function(weatherAlertsData, refreshOptions)
	{
		var isAutomaticRefresh = refreshOptions && refreshOptions.automatic;
		var avoidLayerEnabled = false;
		if (refreshOptions) // if this parameter exists, it's a refresh and we don't enable the layers
		{
			avoidLayerEnabled = true;
		}
		if (weatherAlertsData && weatherAlertsData.length > 0)
		{
			this._sendEventToLayer(this.label, weatherAlertsData, avoidLayerEnabled);
		}
		else
		{
			this._sendEventToRemoveLayer(this.label);
		}
		if (isAutomaticRefresh != true && weatherAlertsData.length == 0)
		{
			this.setActive(false);
			this.map.getMaximo().showMessage("mapserver", "noweatheralertsinarea");
		}
	},
	disable: function()
	{

	},
	destroy: function()
	{
		this.destroyRecursive();
	},
	// util method - gets an array of lbs data to send to spatial for conversion
	// returns null if records is null or any record in records does not have lbsdata.
	_getLBSData: function(records)
	{
		var array = [];
		if (records)
		{
			for (var index in records)
			{
				if (records[index].lbsdata)
				{
					array.push(records[index].lbsdata);
				}
				else
				{
					console.warn("[QueryWeatherAlerts] Records has a record without lbsdata.", records);
					return null;
				}
			}
		}
		else
		{
			console.warn("[QueryWeatherAlerts] Records has a record without lbsdata.", records);
			return null;
		}
		return array;
	},

	// util function to add the records in the new layer.
	_sendEventToLayer: function(layerName, layerData, avoidLayerEnabled)
	{
		dojo.publish("addRecordsToLayer_" + this.map.getId(), [ layerName, layerData, true, null, null, avoidLayerEnabled ]);
	},
	_sendEventToRemoveLayer: function(layerName)
	{
		dojo.publish("removeLayer_" + this.map.getId(), [ layerName ]);
	},
	// Enables the Weather Alerts tool
	executeOn: function(params)
	{
		var fct = function(data)
		{
			if (data.status == "TOOMANYRECORDS")
			{
				this.setActive(false);
				this.map.getMaximo().showMessage(data.error.group, data.error.key, [data.error.params]);
				return;
			}
			var weatherAlertsData = data.weatherAlerts;

			/*
			 * just a small perf improvement to cache all the LBS points
			 * conversion to current coordsystem at once
			 */
			var toProject = [];
			if (weatherAlertsData != null)
				toProject.join(this._getLBSData(weatherAlertsData));
			if (toProject.length > 0)
			{
				this.map.getAllPointsFromWGS84(toProject, dojo.hitch(this, function()
				{
					/*
					 * do not update the weather alerts data. Map is aware these
					 * are WGS84 if we convert it here, it will get converted
					 * again later in the code, so we need to keep it in wgs84
					 */
					this.updateLayers(weatherAlertsData, params.refreshOptions);
				}), dojo.hitch(this, function(error)
				{
					if (error && error.msgkey)
					{
						this.map.getMaximo().showMessage(error.msggroup, error.msgkey);
					}
				}));
			}
			else
			{
				this.updateLayers(weatherAlertsData, params.refreshOptions);
			}
		};

		var fctErr = function(data)
		{
			console.warn("[QueryWeatherAlerts] Error querying nearby resources", data);
		};

		var bounds = this.map.getBounds();
		var auxFct = function(ps)
		{
			var xlatedBounds = this.map.getBoundingBoxFromPoints(ps);
			var queryOption = (params.menuItem != undefined) ? params.menuItem.id : "all";
			var queryParams = {"bounds": xlatedBounds, "filterOption": queryOption};
			this.map.getMaximo().getWeatherAlertsByQueryParams(dojo.hitch(this, fct), dojo.hitch(this, fctErr), queryParams);
		};
		// resources always use LBS that is in wgs84 so we need to convert the
		// boundaries to this coordinate system
		this.map.getAllPointsInWGS84([ bounds.sw, bounds.ne ], dojo.hitch(this, auxFct));
	},
	// Disables the Nearby Resources tool (hides nearby resources)
	executeOff: function()
	{
		this._sendEventToRemoveLayer(this.label);
	},
	_onMapRefresh: function(refreshOpts)
	{
		if (this.isActive() == true)
		{
			this.executeOff();
			this.executeOn({refreshOptions: refreshOpts});
		}
	}
});

});

},
'dijit/layout/ContentPane':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.mixin lang.delegate lang.hitch lang.isFunction lang.isObject
	"../_Widget",
	"../_Container",
	"./_ContentPaneResizeMixin",
	"dojo/string", // string.substitute
	"dojo/html", // html._ContentSetter
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred", // Deferred
	"dojo/dom", // dom.byId
	"dojo/dom-attr", // domAttr.attr
	"dojo/dom-construct", // empty()
	"dojo/_base/xhr", // xhr.get
	"dojo/i18n", // i18n.getLocalization
	"dojo/when",
	"dojo/i18n!../nls/loading"
], function(kernel, lang, _Widget, _Container, _ContentPaneResizeMixin, string, html, array, declare,
			Deferred, dom, domAttr, domConstruct, xhr, i18n, when){

	// module:
	//		dijit/layout/ContentPane

	return declare("dijit.layout.ContentPane", [_Widget, _Container, _ContentPaneResizeMixin], {
		// summary:
		//		A widget containing an HTML fragment, specified inline
		//		or by uri.  Fragment may include widgets.
		//
		// description:
		//		This widget embeds a document fragment in the page, specified
		//		either by uri, javascript generated markup or DOM reference.
		//		Any widgets within this content are instantiated and managed,
		//		but laid out according to the HTML structure.  Unlike IFRAME,
		//		ContentPane embeds a document fragment as would be found
		//		inside the BODY tag of a full HTML document.  It should not
		//		contain the HTML, HEAD, or BODY tags.
		//		For more advanced functionality with scripts and
		//		stylesheets, see dojox/layout/ContentPane.  This widget may be
		//		used stand alone or as a base class for other widgets.
		//		ContentPane is useful as a child of other layout containers
		//		such as BorderContainer or TabContainer, but note that those
		//		widgets can contain any widget as a child.
		//
		// example:
		//		Some quick samples:
		//		To change the innerHTML:
		// |		cp.set('content', '<b>new content</b>')`
		//		Or you can send it a NodeList:
		// |		cp.set('content', dojo.query('div [class=selected]', userSelection))
		//		To do an ajax update:
		// |		cp.set('href', url)

		// href: String
		//		The href of the content that displays now.
		//		Set this at construction if you want to load data externally when the
		//		pane is shown.  (Set preload=true to load it immediately.)
		//		Changing href after creation doesn't have any effect; Use set('href', ...);
		href: "",

		// content: String|DomNode|NodeList|dijit/_Widget
		//		The innerHTML of the ContentPane.
		//		Note that the initialization parameter / argument to set("content", ...)
		//		can be a String, DomNode, Nodelist, or _Widget.
		content: "",

		// extractContent: Boolean
		//		Extract visible content from inside of `<body> .... </body>`.
		//		I.e., strip `<html>` and `<head>` (and it's contents) from the href
		extractContent: false,

		// parseOnLoad: Boolean
		//		Parse content and create the widgets, if any.
		parseOnLoad: true,

		// parserScope: String
		//		Flag passed to parser.  Root for attribute names to search for.   If scopeName is dojo,
		//		will search for data-dojo-type (or dojoType).  For backwards compatibility
		//		reasons defaults to dojo._scopeName (which is "dojo" except when
		//		multi-version support is used, when it will be something like dojo16, dojo20, etc.)
		parserScope: kernel._scopeName,

		// preventCache: Boolean
		//		Prevent caching of data from href's by appending a timestamp to the href.
		preventCache: false,

		// preload: Boolean
		//		Force load of data on initialization even if pane is hidden.
		preload: false,

		// refreshOnShow: Boolean
		//		Refresh (re-download) content when pane goes from hidden to shown
		refreshOnShow: false,

		// loadingMessage: String
		//		Message that shows while downloading
		loadingMessage: "<span class='dijitContentPaneLoading'><span class='dijitInline dijitIconLoading'></span>${loadingState}</span>",

		// errorMessage: String
		//		Message that shows if an error occurs
		errorMessage: "<span class='dijitContentPaneError'><span class='dijitInline dijitIconError'></span>${errorState}</span>",

		// isLoaded: [readonly] Boolean
		//		True if the ContentPane has data in it, either specified
		//		during initialization (via href or inline content), or set
		//		via set('content', ...) / set('href', ...)
		//
		//		False if it doesn't have any content, or if ContentPane is
		//		still in the process of downloading href.
		isLoaded: false,

		baseClass: "dijitContentPane",

		/*======
		 // ioMethod: dojo/_base/xhr.get|dojo._base/xhr.post
		 //		Function that should grab the content specified via href.
		 ioMethod: dojo.xhrGet,
		 ======*/

		// ioArgs: Object
		//		Parameters to pass to xhrGet() request, for example:
		// |	<div data-dojo-type="dijit/layout/ContentPane" data-dojo-props="href: './bar', ioArgs: {timeout: 500}">
		ioArgs: {},

		// onLoadDeferred: [readonly] dojo.Deferred
		//		This is the `dojo.Deferred` returned by set('href', ...) and refresh().
		//		Calling onLoadDeferred.then() registers your
		//		callback to be called only once, when the prior set('href', ...) call or
		//		the initial href parameter to the constructor finishes loading.
		//
		//		This is different than an onLoad() handler which gets called any time any href
		//		or content is loaded.
		onLoadDeferred: null,

		// Cancel _WidgetBase's _setTitleAttr because we don't want the title attribute (used to specify
		// tab labels) to be copied to ContentPane.domNode... otherwise a tooltip shows up over the
		// entire pane.
		_setTitleAttr: null,

		// Flag to parser that I'll parse my contents, so it shouldn't.
		stopParser: true,

		// template: [private] Boolean
		//		Flag from the parser that this ContentPane is inside a template
		//		so the contents are pre-parsed.
		// TODO: this declaration can be commented out in 2.0
		template: false,

		markupFactory: function(params, node, ctor){
			var self = new ctor(params, node);

			// If a parse has started but is waiting for modules to load, then return a Promise for when the parser
			// finishes.  Don't return a promise though for the case when content hasn't started loading because the
			// ContentPane is hidden and it has an href (ex: hidden pane of a TabContainer).   In that case we consider
			// that initialization has already finished.
			return !self.href && self._contentSetter && self._contentSetter.parseDeferred && !self._contentSetter.parseDeferred.isFulfilled() ?
				self._contentSetter.parseDeferred.then(function(){
					return self;
				}) : self;
		},

		create: function(params, srcNodeRef){
			// Convert a srcNodeRef argument into a content parameter, so that the original contents are
			// processed in the same way as contents set via set("content", ...), calling the parser etc.
			// Avoid modifying original params object since that breaks NodeList instantiation, see #11906.
			if((!params || !params.template) && srcNodeRef && !("href" in params) && !("content" in params)){
				srcNodeRef = dom.byId(srcNodeRef);
				var df = srcNodeRef.ownerDocument.createDocumentFragment();
				while(srcNodeRef.firstChild){
					df.appendChild(srcNodeRef.firstChild);
				}
				params = lang.delegate(params, {content: df});
			}
			this.inherited(arguments, [params, srcNodeRef]);
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			var messages = i18n.getLocalization("dijit", "loading", this.lang);
			this.loadingMessage = string.substitute(this.loadingMessage, messages);
			this.errorMessage = string.substitute(this.errorMessage, messages);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// Since we have no template we need to set this.containerNode ourselves, to make getChildren() work.
			// For subclasses of ContentPane that do have a template, does nothing.
			if(!this.containerNode){
				this.containerNode = this.domNode;
			}

			// remove the title attribute so it doesn't show up when hovering
			// over a node  (TODO: remove in 2.0, no longer needed after #11490)
			this.domNode.removeAttribute("title");
		},

		startup: function(){
			// summary:
			//		Call startup() on all children including non _Widget ones like dojo/dnd/Source objects

			// This starts all the widgets
			this.inherited(arguments);

			// And this catches stuff like dojo/dnd/Source
			if(this._contentSetter){
				array.forEach(this._contentSetter.parseResults, function(obj){
					if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
						obj.startup();
						obj._started = true;
					}
				}, this);
			}
		},

		_startChildren: function(){
			// summary:
			//		Called when content is loaded.   Calls startup on each child widget.   Similar to ContentPane.startup()
			//		itself, but avoids marking the ContentPane itself as "restarted" (see #15581).

			// This starts all the widgets
			array.forEach(this.getChildren(), function(obj){
				if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			});

			// And this catches stuff like dojo/dnd/Source
			if(this._contentSetter){
				array.forEach(this._contentSetter.parseResults, function(obj){
					if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
						obj.startup();
						obj._started = true;
					}
				}, this);
			}
		},

		setHref: function(/*String|Uri*/ href){
			// summary:
			//		Deprecated.   Use set('href', ...) instead.
			kernel.deprecated("dijit.layout.ContentPane.setHref() is deprecated. Use set('href', ...) instead.", "", "2.0");
			return this.set("href", href);
		},
		_setHrefAttr: function(/*String|Uri*/ href){
			// summary:
			//		Hook so set("href", ...) works.
			// description:
			//		Reset the (external defined) content of this pane and replace with new url
			//		Note: It delays the download until widget is shown if preload is false.
			// href:
			//		url to the page you want to get, must be within the same domain as your mainpage

			// Cancel any in-flight requests (a set('href', ...) will cancel any in-flight set('href', ...))
			this.cancel();

			this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
			this.onLoadDeferred.then(lang.hitch(this, "onLoad"));

			this._set("href", href);

			// _setHrefAttr() is called during creation and by the user, after creation.
			// Assuming preload == false, only in the second case do we actually load the URL;
			// otherwise it's done in startup(), and only if this widget is shown.
			if(this.preload || (this._created && this._isShown())){
				this._load();
			}else{
				// Set flag to indicate that href needs to be loaded the next time the
				// ContentPane is made visible
				this._hrefChanged = true;
			}

			return this.onLoadDeferred;		// Deferred
		},

		setContent: function(/*String|DomNode|Nodelist*/data){
			// summary:
			//		Deprecated.   Use set('content', ...) instead.
			kernel.deprecated("dijit.layout.ContentPane.setContent() is deprecated.  Use set('content', ...) instead.", "", "2.0");
			this.set("content", data);
		},
		_setContentAttr: function(/*String|DomNode|Nodelist*/data){
			// summary:
			//		Hook to make set("content", ...) work.
			//		Replaces old content with data content, include style classes from old content
			// data:
			//		the new Content may be String, DomNode or NodeList
			//
			//		if data is a NodeList (or an array of nodes) nodes are copied
			//		so you can import nodes from another document implicitly

			// clear href so we can't run refresh and clear content
			// refresh should only work if we downloaded the content
			this._set("href", "");

			// Cancel any in-flight requests (a set('content', ...) will cancel any in-flight set('href', ...))
			this.cancel();

			// Even though user is just setting content directly, still need to define an onLoadDeferred
			// because the _onLoadHandler() handler is still getting called from setContent()
			this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
			if(this._created){
				// For back-compat reasons, call onLoad() for set('content', ...)
				// calls but not for content specified in srcNodeRef (ie: <div data-dojo-type=ContentPane>...</div>)
				// or as initialization parameter (ie: new ContentPane({content: ...})
				this.onLoadDeferred.then(lang.hitch(this, "onLoad"));
			}

			this._setContent(data || "");

			this._isDownloaded = false; // mark that content is from a set('content') not a set('href')

			return this.onLoadDeferred;	// Deferred
		},
		_getContentAttr: function(){
			// summary:
			//		Hook to make get("content") work
			return this.containerNode.innerHTML;
		},

		cancel: function(){
			// summary:
			//		Cancels an in-flight download of content
			if(this._xhrDfd && (this._xhrDfd.fired == -1)){
				this._xhrDfd.cancel();
			}
			delete this._xhrDfd; // garbage collect

			this.onLoadDeferred = null;
		},

		destroy: function(){
			this.cancel();
			this.inherited(arguments);
		},

		destroyRecursive: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy the ContentPane and its contents

			// if we have multiple controllers destroying us, bail after the first
			if(this._beingDestroyed){
				return;
			}
			this.inherited(arguments);
		},

		_onShow: function(){
			// summary:
			//		Called when the ContentPane is made visible
			// description:
			//		For a plain ContentPane, this is called on initialization, from startup().
			//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
			//		called whenever the pane is made visible.
			//
			//		Does necessary processing, including href download and layout/resize of
			//		child widget(s)

			this.inherited(arguments);

			if(this.href){
				if(!this._xhrDfd && // if there's an href that isn't already being loaded
					(!this.isLoaded || this._hrefChanged || this.refreshOnShow)
					){
					return this.refresh();	// If child has an href, promise that fires when the load is complete
				}
			}
		},

		refresh: function(){
			// summary:
			//		[Re]download contents of href and display
			// description:
			//		1. cancels any currently in-flight requests
			//		2. posts "loading..." message
			//		3. sends XHR to download new data

			// Cancel possible prior in-flight request
			this.cancel();

			this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
			this.onLoadDeferred.then(lang.hitch(this, "onLoad"));
			this._load();
			return this.onLoadDeferred;		// If child has an href, promise that fires when refresh is complete
		},

		_load: function(){
			// summary:
			//		Load/reload the href specified in this.href

			// display loading message
			this._setContent(this.onDownloadStart(), true);

			var self = this;
			var getArgs = {
				preventCache: (this.preventCache || this.refreshOnShow),
				url: this.href,
				handleAs: "text"
			};
			if(lang.isObject(this.ioArgs)){
				lang.mixin(getArgs, this.ioArgs);
			}

			var hand = (this._xhrDfd = (this.ioMethod || xhr.get)(getArgs)),
				returnedHtml;

			hand.then(
				function(html){
					returnedHtml = html;
					try{
						self._isDownloaded = true;
						return self._setContent(html, false);
					}catch(err){
						self._onError('Content', err); // onContentError
					}
				},
				function(err){
					if(!hand.canceled){
						// show error message in the pane
						self._onError('Download', err); // onDownloadError
					}
					delete self._xhrDfd;
					return err;
				}
			).then(function(){
					self.onDownloadEnd();
					delete self._xhrDfd;
					return returnedHtml;
				});

			// Remove flag saying that a load is needed
			delete this._hrefChanged;
		},

		_onLoadHandler: function(data){
			// summary:
			//		This is called whenever new content is being loaded
			this._set("isLoaded", true);
			try{
				this.onLoadDeferred.resolve(data);
			}catch(e){
				console.error('Error ' + (this.widgetId || this.id) + ' running custom onLoad code: ' + e.message);
			}
		},

		_onUnloadHandler: function(){
			// summary:
			//		This is called whenever the content is being unloaded
			this._set("isLoaded", false);
			try{
				this.onUnload();
			}catch(e){
				console.error('Error ' + this.widgetId + ' running custom onUnload code: ' + e.message);
			}
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy all the widgets inside the ContentPane and empty containerNode

			// Make sure we call onUnload (but only when the ContentPane has real content)
			if(this.isLoaded){
				this._onUnloadHandler();
			}

			// Even if this.isLoaded == false there might still be a "Loading..." message
			// to erase, so continue...

			// For historical reasons we need to delete all widgets under this.containerNode,
			// even ones that the user has created manually.
			var setter = this._contentSetter;
			array.forEach(this.getChildren(), function(widget){
				if(widget.destroyRecursive){
					// All widgets will hit this branch
					widget.destroyRecursive(preserveDom);
				}else if(widget.destroy){
					// Things like dojo/dnd/Source have destroy(), not destroyRecursive()
					widget.destroy(preserveDom);
				}
				widget._destroyed = true;
			});
			if(setter){
				// Most of the widgets in setter.parseResults have already been destroyed, but
				// things like Menu that have been moved to <body> haven't yet
				array.forEach(setter.parseResults, function(widget){
					if(!widget._destroyed){
						if(widget.destroyRecursive){
							// All widgets will hit this branch
							widget.destroyRecursive(preserveDom);
						}else if(widget.destroy){
							// Things like dojo/dnd/Source have destroy(), not destroyRecursive()
							widget.destroy(preserveDom);
						}
						widget._destroyed = true;
					}
				});
				delete setter.parseResults;
			}

			// And then clear away all the DOM nodes
			if(!preserveDom){
				domConstruct.empty(this.containerNode);
			}

			// Delete any state information we have about current contents
			delete this._singleChild;
		},

		_setContent: function(/*String|DocumentFragment*/ cont, /*Boolean*/ isFakeContent){
			// summary:
			//		Insert the content into the container node
			// returns:
			//		Returns a Deferred promise that is resolved when the content is parsed.

			cont = this.preprocessContent(cont);
			// first get rid of child widgets
			this.destroyDescendants();

			// html.set will take care of the rest of the details
			// we provide an override for the error handling to ensure the widget gets the errors
			// configure the setter instance with only the relevant widget instance properties
			// NOTE: unless we hook into attr, or provide property setters for each property,
			// we need to re-configure the ContentSetter with each use
			var setter = this._contentSetter;
			if(!(setter && setter instanceof html._ContentSetter)){
				setter = this._contentSetter = new html._ContentSetter({
					node: this.containerNode,
					_onError: lang.hitch(this, this._onError),
					onContentError: lang.hitch(this, function(e){
						// fires if a domfault occurs when we are appending this.errorMessage
						// like for instance if domNode is a UL and we try append a DIV
						var errMess = this.onContentError(e);
						try{
							this.containerNode.innerHTML = errMess;
						}catch(e){
							console.error('Fatal ' + this.id + ' could not change content due to ' + e.message, e);
						}
					})/*,
					 _onError */
				});
			}

			var setterParams = lang.mixin({
				cleanContent: this.cleanContent,
				extractContent: this.extractContent,
				parseContent: !cont.domNode && this.parseOnLoad,
				parserScope: this.parserScope,
				startup: false,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir
			}, this._contentSetterParams || {});

			var p = setter.set((lang.isObject(cont) && cont.domNode) ? cont.domNode : cont, setterParams);

			// dojox/layout/html/_base::_ContentSetter.set() returns a Promise that indicates when everything is completed.
			// dojo/html::_ContentSetter.set() currently returns the DOMNode, but that will be changed for 2.0.
			// So, if set() returns a promise then use it, otherwise fallback to waiting on setter.parseDeferred
			var self = this;
			return when(p && p.then ? p : setter.parseDeferred, function(){
				// setter params must be pulled afresh from the ContentPane each time
				delete self._contentSetterParams;

				if(!isFakeContent){
					if(self._started){
						// Startup each top level child widget (and they will start their children, recursively)
						self._startChildren();

						// Call resize() on each of my child layout widgets,
						// or resize() on my single child layout widget...
						// either now (if I'm currently visible) or when I become visible
						self._scheduleLayout();
					}
					self._onLoadHandler(cont);
				}
			});
		},

		preprocessContent: function(/*String|DocumentFragment*/ content){
			// summary:
			//		Hook, called after content has loaded, before being processed.
			// description:
			//		A subclass should preprocess the content and return the preprocessed content.
			//		See https://bugs.dojotoolkit.org/ticket/9622
			// returns:
			//		Returns preprocessed content, either a String or DocumentFragment
			return content;
		},

		_onError: function(type, err, consoleText){
			this.onLoadDeferred.reject(err);

			// shows user the string that is returned by on[type]Error
			// override on[type]Error and return your own string to customize
			var errText = this['on' + type + 'Error'].call(this, err);
			if(consoleText){
				console.error(consoleText, err);
			}else if(errText){// a empty string won't change current content
				this._setContent(errText, true);
			}
		},

		// EVENT's, should be overide-able
		onLoad: function(/*===== data =====*/){
			// summary:
			//		Event hook, is called after everything is loaded and widgetified
			// tags:
			//		callback
		},

		onUnload: function(){
			// summary:
			//		Event hook, is called before old content is cleared
			// tags:
			//		callback
		},

		onDownloadStart: function(){
			// summary:
			//		Called before download starts.
			// description:
			//		The string returned by this function will be the html
			//		that tells the user we are loading something.
			//		Override with your own function if you want to change text.
			// tags:
			//		extension
			return this.loadingMessage;
		},

		onContentError: function(/*Error*/ /*===== error =====*/){
			// summary:
			//		Called on DOM faults, require faults etc. in content.
			//
			//		In order to display an error message in the pane, return
			//		the error message from this method, as an HTML string.
			//
			//		By default (if this method is not overriden), it returns
			//		nothing, so the error message is just printed to the console.
			// tags:
			//		extension
		},

		onDownloadError: function(/*Error*/ /*===== error =====*/){
			// summary:
			//		Called when download error occurs.
			//
			//		In order to display an error message in the pane, return
			//		the error message from this method, as an HTML string.
			//
			//		Default behavior (if this method is not overriden) is to display
			//		the error message inside the pane.
			// tags:
			//		extension
			return this.errorMessage;
		},

		onDownloadEnd: function(){
			// summary:
			//		Called when download is finished.
			// tags:
			//		callback
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/impl/geocoder/BingGeocoder':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Geocoder"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

dojo.require("ibm.tivoli.fwm.mxmap._Geocoder");
dojo.provide("ibm.tivoli.fwm.mxmap.impl.geocoder.BingGeocoder");

//This variable is always increased so that there can be multiple parallel requests
//to dojo.io.script.get without overwriting the callback function 
ibm.tivoli.fwm.mxmap.impl.geocoder.geocoderCallbackId = 0;
ibm.tivoli.fwm.mxmap.impl.geocoder.getGeocoderCallbackId = function()
{
	return ibm.tivoli.fwm.mxmap.impl.geocoder.geocoderCallbackId++;
};

/**
 * BingGeocoder
 */
dojo.declare("ibm.tivoli.fwm.mxmap.impl.geocoder.BingGeocoder", ibm.tivoli.fwm.mxmap._Geocoder, {
	callbackFctName: null,
	geocodeURL: null,
	_init : function() {
		var me = this;		
		//  There's no native bing location api, just a REST interface. That's why we
		//  set an empty object into the this.geocoder.
		this.geocoder = {};
	
		this.callbackFctName = "bingGeocodeCallback" + ibm.tivoli.fwm.mxmap.impl.geocoder.getGeocoderCallbackId();
		
		this.geocodeURL = this.optParams.customParams.url;
		
		window[this.callbackFctName] = function(args)
		{
			me.geocode_callback(args);
			// Defect 79410: For some mysterious reason, after a "Set Record Location" or after
			// moving the marker, the "map dragging reference point" is lost if we set this
			// callback function to null
			if(!dojo.isIE)
			{
				window[this.callbackFctName] = null;
			}
		};
	},

	geocode : function(address)
	{
		var me = this;			
		if (!address.hasOwnProperty('address') || address.address === null || address.address === '') {
			// we can use this strucuted info to improve the search in the
			// future:
			// http://msdn.microsoft.com/en-us/library/ff701714.aspx
			address.address = [ address.street, address.locality, address.region, address.country ].join(', ');
		}

		if (address.hasOwnProperty('lat') && (address.hasOwnProperty('lon') || address.hasOwnProperty('lng'))) {
			var lat = address.lat;
			var lng = address.lng;
			if (!lng) {
				lng = address.lon;
			}
			
			var geocodeRequest = this.geocodeURL + "/" + lat + "," + lng + "?output=json&jsonp=" + this.callbackFctName + "&key=" + me.optParams.key;
			dojo.io.script.get({
				url : geocodeRequest,
				timeout : 13000,
				error : function(error) {
					console.error('Failed to access bing maps geocoding api',error);
					alert('Failed to access bing maps geocoding api');
				}
			});
		} else {
			var mapView="";
			
			if(me.optParams.map && me.optParams.map.getBounds()){
				
				var ne = me.optParams.map.getBounds().getNorthEast();
				var sw = me.optParams.map.getBounds().getSouthWest();
				
				mapView = "mapView="+sw.lat+","+sw.lng+","+ne.lat+","+ne.lng;
			}
			var geocodeRequest = this.geocodeURL + "/" + address.address + "?output=json&jsonp=" + this.callbackFctName + "&key=" + me.optParams.key+"&"+mapView;
			
			dojo.io.script.get({
				url : geocodeRequest,
				timeout : 13000,
				error : function(error) {
					console.error('Failed to access bing maps geocoding api',error);
					alert('Failed to access bing maps geocoding api');
				}
			});

		}
	},

	geocode_callback : function(response) {
		var me = this;			

		var isBestMatch = function(candidate){
			var confidence = candidate.confidence || "";
			var matchCodes = candidate.matchCodes[0] || "";				
			var calculationMethod = "";
			if(candidate.geocodePoints){
				calculationMethod = candidate.geocodePoints[0].calculationMethod || ""; 
			}
			return (confidence == "High" && matchCodes == "Good" && calculationMethod == "Rooftop"); 				
		};
		var convertBingToMapstraction = function(bingResult) {
			var _location = {};
			_location.formattedAddress = bingResult.address.formattedAddress;
			_location.street = bingResult.address.street;
			_location.locality = bingResult.address.locality;
			_location.region = bingResult.address.adminDistrict;
			_location.country = bingResult.address.countryRegion;
			
			_location.point = me.optParams.map.latLng(bingResult.point.coordinates[0], bingResult.point.coordinates[1]);
			return _location;
		};
		var all_locations = [];
		if (response.authenticationResultCode != "ValidCredentials") {
			// throw "Invalid credentials. Check if the Bing Maps geocode
			// api key is valid.";
			this.error_callback(response.authenticationResultCode);
			return;
		}
		if (response.statusCode == 200) {
			var results = response.resourceSets;
			for (var setId in results) {
				var set = results[setId];
				if (set.estimatedTotal == 0) {
					this.error_callback("ZERO_RESULTS");
					return;
				}
				for (var rid in set.resources) {
					var result = set.resources[rid];						
					if(isBestMatch(result) == true)
					{
						this.callback([convertBingToMapstraction(result)]);
						return;
					}
					all_locations.push(convertBingToMapstraction(result));
				}
			}
		} else {
			this.error_callback(response.statusDescription);
			return;
		}

		this.callback(all_locations);
	}
});

});

},
'dijit/_KeyNavContainer':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys", // keys.END keys.HOME
	"dojo/_base/lang", // lang.hitch
	"./registry",
	"./_Container",
	"./_FocusMixin",
	"./_KeyNavMixin"
], function(array, declare, domAttr, kernel, keys, lang, registry, _Container, _FocusMixin, _KeyNavMixin){


	// module:
	//		dijit/_KeyNavContainer

	return declare("dijit._KeyNavContainer", [_FocusMixin, _KeyNavMixin, _Container], {
		// summary:
		//		A _Container with keyboard navigation of its children.
		// description:
		//		Provides normalized keyboard and focusing code for Container widgets.
		//		To use this mixin, call connectKeyNavHandlers() in postCreate().
		//		Also, child widgets must implement a focus() method.

		connectKeyNavHandlers: function(/*keys[]*/ prevKeyCodes, /*keys[]*/ nextKeyCodes){
			// summary:
			//		Deprecated.  You can call this in postCreate() to attach the keyboard handlers to the container,
			//		but the preferred method is to override _onLeftArrow() and _onRightArrow(), or
			//		_onUpArrow() and _onDownArrow(), to call focusPrev() and focusNext().
			// prevKeyCodes: keys[]
			//		Key codes for navigating to the previous child.
			// nextKeyCodes: keys[]
			//		Key codes for navigating to the next child.
			// tags:
			//		protected

			// TODO: remove for 2.0, and make subclasses override _onLeftArrow, _onRightArrow etc. instead.

			var keyCodes = (this._keyNavCodes = {});
			var prev = lang.hitch(this, "focusPrev");
			var next = lang.hitch(this, "focusNext");
			array.forEach(prevKeyCodes, function(code){
				keyCodes[code] = prev;
			});
			array.forEach(nextKeyCodes, function(code){
				keyCodes[code] = next;
			});
			keyCodes[keys.HOME] = lang.hitch(this, "focusFirstChild");
			keyCodes[keys.END] = lang.hitch(this, "focusLastChild");
		},

		startupKeyNavChildren: function(){
			kernel.deprecated("startupKeyNavChildren() call no longer needed", "", "2.0");
		},

		startup: function(){
			this.inherited(arguments);
			array.forEach(this.getChildren(), lang.hitch(this, "_startupChild"));
		},

		addChild: function(/*dijit/_WidgetBase*/ widget, /*int?*/ insertIndex){
			this.inherited(arguments);
			this._startupChild(widget);
		},

		_startupChild: function(/*dijit/_WidgetBase*/ widget){
			// summary:
			//		Setup for each child widget.
			// description:
			//		Sets tabIndex=-1 on each child, so that the tab key will
			//		leave the container rather than visiting each child.
			//
			//		Note: if you add children by a different method than addChild(), then need to call this manually
			//		or at least make sure the child's tabIndex is -1.
			//
			//		Note: see also _LayoutWidget.setupChild(), which is also called for each child widget.
			// tags:
			//		private

			widget.set("tabIndex", "-1");
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child.
			// tags:
			//		abstract extension
			var children = this.getChildren();
			return children.length ? children[0] : null;
		},

		_getLast: function(){
			// summary:
			//		Returns the last descendant.
			// tags:
			//		abstract extension
			var children = this.getChildren();
			return children.length ? children[children.length - 1] : null;
		},

		focusNext: function(){
			// summary:
			//		Focus the next widget
			// tags:
			//		protected
			this.focusChild(this._getNextFocusableChild(this.focusedChild, 1));
		},

		focusPrev: function(){
			// summary:
			//		Focus the last focusable node in the previous widget
			//		(ex: go to the ComboButton icon section rather than button section)
			// tags:
			//		protected
			this.focusChild(this._getNextFocusableChild(this.focusedChild, -1), true);
		},

		childSelector: function(/*DOMNode*/ node){
			// Implement _KeyNavMixin.childSelector, to identify focusable child nodes.
			// If we allowed a dojo/query dependency from this module this could more simply be a string "> *"
			// instead of this function.

			var node = registry.byNode(node);
			return node && node.getParent() == this;
		}
	});
});

},
'dijit/layout/utils':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.filter array.forEach
	"dojo/dom-class", // domClass.add domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/lang" // lang.mixin, lang.setObject
], function(array, domClass, domGeometry, domStyle, lang){

	// module:
	//		dijit/layout/utils

	function capitalize(word){
		return word.substring(0,1).toUpperCase() + word.substring(1);
	}

	function size(widget, dim){
		// size the child
		var newSize = widget.resize ? widget.resize(dim) : domGeometry.setMarginBox(widget.domNode, dim);

		// record child's size
		if(newSize){
			// if the child returned it's new size then use that
			lang.mixin(widget, newSize);
		}else{
			// otherwise, call getMarginBox(), but favor our own numbers when we have them.
			// the browser lies sometimes
			lang.mixin(widget, domGeometry.getMarginBox(widget.domNode));
			lang.mixin(widget, dim);
		}
	}

	var utils = {
		// summary:
		//		Utility functions for doing layout

		marginBox2contentBox: function(/*DomNode*/ node, /*Object*/ mb){
			// summary:
			//		Given the margin-box size of a node, return its content box size.
			//		Functions like domGeometry.contentBox() but is more reliable since it doesn't have
			//		to wait for the browser to compute sizes.
			var cs = domStyle.getComputedStyle(node);
			var me = domGeometry.getMarginExtents(node, cs);
			var pb = domGeometry.getPadBorderExtents(node, cs);
			return {
				l: domStyle.toPixelValue(node, cs.paddingLeft),
				t: domStyle.toPixelValue(node, cs.paddingTop),
				w: mb.w - (me.w + pb.w),
				h: mb.h - (me.h + pb.h)
			};
		},


		layoutChildren: function(/*DomNode*/ container, /*Object*/ dim, /*Widget[]*/ children,
				/*String?*/ changedRegionId, /*Number?*/ changedRegionSize){
			// summary:
			//		Layout a bunch of child dom nodes within a parent dom node
			// container:
			//		parent node
			// dim:
			//		{l, t, w, h} object specifying dimensions of container into which to place children
			// children:
			//		An array of Widgets or at least objects containing:
			//
			//		- domNode: pointer to DOM node to position
			//		- region or layoutAlign: position to place DOM node
			//		- resize(): (optional) method to set size of node
			//		- id: (optional) Id of widgets, referenced from resize object, below.
			//
			//		The widgets in this array should be ordered according to how they should be laid out
			//		(each element will be processed in order, and take up as much remaining space as needed),
			//		with the center widget last.
			// changedRegionId:
			//		If specified, the slider for the region with the specified id has been dragged, and thus
			//		the region's height or width should be adjusted according to changedRegionSize
			// changedRegionSize:
			//		See changedRegionId.

			// copy dim because we are going to modify it
			dim = lang.mixin({}, dim);

			domClass.add(container, "dijitLayoutContainer");

			// Move "client" elements to the end of the array for layout.  a11y dictates that the author
			// needs to be able to put them in the document in tab-order, but this algorithm requires that
			// client be last.    TODO: remove for 2.0, all dijit client code already sends children as last item.
			children = array.filter(children, function(item){ return item.region != "center" && item.layoutAlign != "client"; })
				.concat(array.filter(children, function(item){ return item.region == "center" || item.layoutAlign == "client"; }));

			// set positions/sizes
			array.forEach(children, function(child){
				var elm = child.domNode,
					pos = (child.region || child.layoutAlign);
				if(!pos){
					throw new Error("No region setting for " + child.id)
				}

				// set elem to upper left corner of unused space; may move it later
				var elmStyle = elm.style;
				elmStyle.left = dim.l+"px";
				elmStyle.top = dim.t+"px";
				elmStyle.position = "absolute";

				domClass.add(elm, "dijitAlign" + capitalize(pos));

				// Size adjustments to make to this child widget
				var sizeSetting = {};

				// Check for optional size adjustment due to splitter drag (height adjustment for top/bottom align
				// panes and width adjustment for left/right align panes.
				if(changedRegionId && changedRegionId == child.id){
					sizeSetting[child.region == "top" || child.region == "bottom" ? "h" : "w"] = changedRegionSize;
				}

				if(pos == "leading"){
					pos = child.isLeftToRight() ? "left" : "right";
				}
				if(pos == "trailing"){
					pos = child.isLeftToRight() ? "right" : "left";
				}

				// set size && adjust record of remaining space.
				// note that setting the width of a <div> may affect its height.
				if(pos == "top" || pos == "bottom"){
					sizeSetting.w = dim.w;
					size(child, sizeSetting);
					dim.h -= child.h;
					if(pos == "top"){
						dim.t += child.h;
					}else{
						elmStyle.top = dim.t + dim.h + "px";
					}
				}else if(pos == "left" || pos == "right"){
					sizeSetting.h = dim.h;
					size(child, sizeSetting);
					dim.w -= child.w;
					if(pos == "left"){
						dim.l += child.w;
					}else{
						elmStyle.left = dim.l + dim.w + "px";
					}
				}else if(pos == "client" || pos == "center"){
					size(child, dim);
				}
			});
		}
	};

	lang.setObject("dijit.layout.utils", utils);	// remove for 2.0

	return utils;
});

},
'dijit/_Contained':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"./registry"	// registry.getEnclosingWidget(), registry.byNode()
], function(declare, registry){

	// module:
	//		dijit/_Contained

	return declare("dijit._Contained", null, {
		// summary:
		//		Mixin for widgets that are children of a container widget
		// example:
		//	|	// make a basic custom widget that knows about its parents
		//	|	declare("my.customClass",[dijit._WidgetBase, dijit._Contained],{});

		_getSibling: function(/*String*/ which){
			// summary:
			//		Returns next or previous sibling
			// which:
			//		Either "next" or "previous"
			// tags:
			//		private
			var p = this.getParent();
			return (p && p._getSiblingOfChild && p._getSiblingOfChild(this, which == "previous" ? -1 : 1)) || null;	// dijit/_WidgetBase
		},

		getPreviousSibling: function(){
			// summary:
			//		Returns null if this is the first child of the parent,
			//		otherwise returns the next element sibling to the "left".

			return this._getSibling("previous"); // dijit/_WidgetBase
		},

		getNextSibling: function(){
			// summary:
			//		Returns null if this is the last child of the parent,
			//		otherwise returns the next element sibling to the "right".

			return this._getSibling("next"); // dijit/_WidgetBase
		},

		getIndexInParent: function(){
			// summary:
			//		Returns the index of this widget within its container parent.
			//		It returns -1 if the parent does not exist, or if the parent
			//		is not a dijit/_Container

			var p = this.getParent();
			if(!p || !p.getIndexOfChild){
				return -1; // int
			}
			return p.getIndexOfChild(this); // int
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/MaximoIntegration':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */


define(["dojo/main", "dijit/main", "dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/_Base"],
	function(dojo, dijit, declare, _Base) {
		/**
		 * Implements Maximo <-> Map JS framework communication. Currently using sendEvent
		 */
		return declare([_Base], {
			compId: null,
			constructor: function(params) {
				dojo.mixin(this, params);
				this.addSubscription("mxmap_onServerData_" + this.compId, dojo.hitch(this, function(data) {
					this.handleServer(data);
				}));
			},
			resetMaximoTimeout: function(fromServer) {
				try {
					console.log("timer from server:", fromServer);
					if (!fromServer) {
						fromServer = false;
					}
					resetLogoutTimer(fromServer);
					// reset timer
				} catch (e) {

				}
			},
			maximoRecordChanged: function(actionCurrentMbo) {
				var differentRecord = false;
				if (actionCurrentMbo) {
					var actionMboInfo = actionCurrentMbo.mxdata.mboInfo;
					var currentMboInfo = this.mapConf.currentMbo.mxdata.mboInfo;
					for (var key in actionMboInfo) {
						if (!actionMboInfo.hasOwnProperty(key))
							continue;
						var actionMboInfoValue = actionMboInfo[key];
						var currentMboInfoValue = currentMboInfo[key];
						if (currentMboInfoValue == null || currentMboInfoValue !== actionMboInfoValue) {
							differentRecord = true;
						}
					}
				}
				return differentRecord;
			},
			/**
			 * Handles actions from server
			 */
			handleServer: function(actions) {
				console.log("[Maximo Integration] Actions Received: ", actions);

				var action = null;
				try {
					this.resetMaximoTimeout(true);
					if (actions) {
						for (var id in actions) {
							action = actions[id];
							console.log("[Maximo Integration] Processing action: ", action);
							switch (action.action) {
								case "updatedCurrentRecordLocation":
									console.log("onCurrentRecordUpdate_" + this.compId);
									dojo.publish("onCurrentRecordUpdate_" + this.compId, [
										action.data.currentMbo
									]);
									break;
								case "updatedRecordSetLocation":
									if (action.data.currentMbo) {
										dojo.publish("onCurrentRecordUpdate_" + this.compId, [
											action.data.currentMbo
										]);
										if (this.mapConf.provider == "spatial") {
											if (this.maximoRecordChanged(action.data.currentMbo)) {
												dojo.publish("refreshMapListener", [
													action.data.currentMbo
												]);
											}
											dojo.publish("onSketchMboChange", [
												action.data.currentMbo
											]);
										}
										console.log("event was updatedRecordSetLocation");
									}
									dojo.publish("onCurrentRecordSetUpdated_" + this.compId, [
										action.data.records
									]);
									break;
								case "addRecordsToLayer":
									console.log('received records to add to layer', action);
									dojo.publish("addRecordsToLayer_" + this.compId, [
										action.layerName, action.data.records, action.cleanBeforeAdd
									]);
									break;
								case "removeRecordsFromLayer":
									console.log('received records to remove from layer', action);
									dojo.publish("removeRecordsFromLayer_" + this.compId, [
										action.layerName, action.data.records
									]);
									break;
								case "exception":
									dojo.publish("onServerException_" + this.compId, [
										action.data.failedAction
									]);
									console.warn("An exception was thrown from server", action.data);
									break;
								case "refreshroute":
									console.warn("refreshroute", action);
									dojo.publish("refreshroute_" + this.compId, [
										action.data
									]);

									break;
								case "refreshdatasource":
									console.warn("refreshdatasource", action);
									this.refreshDatasource(dojo.hitch(this, function(response) {
										this.handleServer(response);
									}), function() {
									});

									break;
								case "noop":
									sendEvent("NOOP", this.compId, '');

									break;

								default:

									dojo.publish(action.action + "_" + this.compId, [
										action.data
									]);
									break;
							}
						}
					}
				} catch (e) {
					if (action) {
						console.error("Failed executing server action: ", action, e);
					} else {
						console.error("Failed executing server actions: ", actions, e);
					}
				}
			},
			storeUserLocation: function(locationInfo) {
				var myEvent = new Event("storeUserLocation", this.compId, dojo.toJson(locationInfo),
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", function() {
				}, function() {
					console.error("failed to save user context.");
				});
			},
			getRouteStops: function(callback, erroCb, forceRefresh, serverCallback) {
				if (forceRefresh == null) {
					forceRefresh = false;
				}
				var normalReturn = function(data) {

					if (data.error) {
						erroCb(data);

					} else {
						if (data.forceUIRefresh == true) {
							data.hasRoute = false;// the NOOP would force the route to
							// be drawn again.
							console
								.info("the results bean is going to change and then will send another UI Refresh.");
							sendEvent("NOOP", this.compId, '');
						}
						callback(data);

					}

				};
				if (!serverCallback) {
					serverCallback = false;
				}
				var myEvent = new Event("getRouteStops", this.compId + "_router", {
					forceRefresh: forceRefresh,
					serverCallback: serverCallback
				}, REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", dojo.hitch(this, normalReturn),
					erroCb);
			},

			loadMapTipTemplate: function(mxdata, mapTipOverrides, successCallback, errorCallback) {
				var myEvent = new Event("loadMapTipTemplate", this.compId, {
					objectName: mxdata.mboName,
					objectId: mxdata.uid.value,
					mapTipOverrides: mapTipOverrides
				}, REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "text/html", "text", successCallback, errorCallback);
			},

			loadMapTipSummaryTemplate: function(mxdata, mapTipOverrides, successCallback, errorCallback) {
				var myEvent = new Event("loadMapTipSummaryTemplate", this.compId, {
					objectName: mxdata.mboName,
					objectId: mxdata.uid.value,
					mapTipOverrides: mapTipOverrides
				}, REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "text/html", "text", successCallback, errorCallback);
			},

			loadLinearLayerObjectAttributes: function(objectName, relationship, attributes, successCallback,
				errorCallback) {
				var myEvent = new Event("loadLinearLayerObjectAttributes", this.compId, {
					objectName: objectName,
					relationship: relationship,
					attributes: attributes
				}, REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", successCallback, errorCallback);
			},

			loadAttributesFromLinearAttributeTemplate: function(template, objectName, successCallback,
				errorCallback) {
				var myEvent = new Event("loadAttributesFromLinearAttributeTemplate", this.compId, {
					template: template,
					objectName: objectName,
				}, REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", successCallback, errorCallback);
			},

			loadMapTipItems: function(successCallback, errorCallback) {
				var myEvent = new Event("loadMenuItems", this.compId, "", REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", successCallback, errorCallback);

			},

			getLinearGraphicsbyWhereClause: function(whereClause, objectName, successCallback, errorCallback) {
				var params = {
					whereClause: whereClause,
					objectName: objectName
				};
				var myEvent = new Event("getLinearGraphicsbyWhereClause", this.compId, params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", successCallback, errorCallback);
			},
			/**
			 * Send the set current location on server record.
			 */
			setCurrentRecordLocation: function (location, status) {
				var params = {
					lat: location.lat,
					lng: location.lng,
					formattedaddress: location.address,
					status: status,
					sr: location.sr
				};
				console.log("Calling Maximo event with data: ", location);

				var myEvent = new Event("setCurrentSALocation", this.compId, params, REQUESTTYPE_SYNC);
				queueManager.queueEvent(myEvent, "text/xml", "xml", processXHR, function (err) {
					console.log("error", err);
				});
			},

			invokeAction: function(params, onSuccess, onError) {
				var event = new Event(
					"invokeAction", 
					"spatialmapdispatcher", 
					params, 
					REQUESTTYPE_HIGHASYNC
				);

				queueManager.queueEvent(
					event,
					"application/json",
					"json",
					onSuccess,
					onError
				);
			},

			unlinkFeature: function(feature, mapServiceUrl, functionSuccess) {
				var params = {
					"attributes": (feature.attributesFieldsName) ? feature.attributesFieldsName
						: feature.attributes,
					"mapServiceUrl": mapServiceUrl
				};

				var myEvent = new Event("unlinkFeature", "spatialmapdispatcher", params, REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", functionSuccess,
					function(err) {
						console.error("error", err);

					});
			},
			getArcGISQueryAttributesFromListTabLinkedMbos: function(functionSuccess) {
				var params = {};
				var myEvent = new Event("getArcGISQueryAttributesFromListTabLinkedMbos",
					"spatialmapdispatcher", params, REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", functionSuccess,
					function(err) {
						console.error("error", err);

					});
			},
			updateFieldValue: function(maximoReturnAttribute, maximoObjectFeature, functionSuccess) {
				var params = {
					maximoReturnAttribute: maximoReturnAttribute,
					maximoObjectFeatureAttributes: maximoObjectFeatureAttributes
				};

				sendEvent("updateFieldValue", "spatialmapdispatcher", JSON.stringify(params));
			},
			updateApplicationList: function(maximoFieldName, maximoFieldValues, functionSuccess) {
				var params = {
					maximoFieldName: maximoFieldName,
					maximoFieldValues: maximoFieldValues
				};

				sendEvent("updateApplicationList", "spatialmapdispatcher", JSON.stringify(params));
			},
			loadLinearSegments: function(linearLayers, functionSuccess) {
				var params = {
					linearLayers: []
				};
				for (var key in linearLayers) {
					// skip loop if the property is from prototype
					if (!linearLayers.hasOwnProperty(key))
						continue;

					var obj = linearLayers[key];
					console.log(obj);
					params.linearLayers.push({
						"linearLayer": obj
					});
				}

				var myEvent = new Event("loadLinearSegments", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", functionSuccess,
					function(err) {
						console.error("error", err);
					});
			},
			updateApplicationListFromListView: function(maximoReturnAttribute, featuresAttributes,
				functionSuccess) {
				var params = {
					maximoReturnAttribute: maximoReturnAttribute,
					featuresAttributes: featuresAttributes
				};

				sendEvent("updateApplicationListFromListView", "spatialmapdispatcher", JSON.stringify(params));
			},
			updateCurrentMaximoRecord: function(feature, linkConfiguration) {
				var params = {
					"attributes": (feature.attributesFieldsName) ? feature.attributesFieldsName
						: feature.attributes,
					"linkConfiguration": linkConfiguration
				};

				sendEvent("updateCurrentMaximoRecord", "spatialmapdispatcher", JSON.stringify(params));
			},
			renderPage: function() {
				sendEvent("renderPage", "spatialmapdispatcher", null);
			},
			setAppToUpdateCurrentMaximoRecord: function(info) {
				sendEvent("setAppToUpdateCurrentMaximoRecord", "spatialmapdispatcher", JSON.stringify(info));
			},
			isFeatureLinkedToMultipleRecords: function(feature, currMbo, functionSuccess) {

				var params = {
					features: []
				};
				
				var attributes = currMbo.mxdata.attributes;
				feature.attributes.layerMapServerUrl = currMbo.layerInfoData[0].url;
				feature.attributes.layerName = attributes.layerName;
				feature.attributes.layerId = attributes.layerId;
				feature.attributes.layerGroup = attributes.layerGroup;

				if (feature.isLinearGraphic == undefined || feature.isLinearGraphic == null
					|| feature.isLinearGraphic == false) {
					params.features
						.push({
							"attributes": feature.attributes
						});
				}

				var myEvent = new Event("isFeatureLinkedToMultipleRecords", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", functionSuccess,
					function(err) {
						console.error("error", err);

					});
			},
			updateGeometryData: function( esriGeometryJSON, functionSuccess){
				var params = {
					esriGeometryJSON: esriGeometryJSON,
				};
				var myEvent = new Event("updateGeometryData", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", functionSuccess,
					function(err) {
						console.error("error", err);
					});
			},
			isFeatureLinked: function(featureArray, functionSuccess) {

				var params = {
					features: []
				};
				for (var i = 0; i < featureArray.length; i++) {
					var featureElement = featureArray[i];
					if (featureElement.isLinearGraphic == undefined || featureElement.isLinearGraphic == null
						|| featureElement.isLinearGraphic == false) {
						params.features
							.push({
								"attributes": (featureElement.attributesFieldsName) ? featureElement.attributesFieldsName
									: featureElement.attributes
							});
					}

				}

				var myEvent = new Event("isFeatureLinked", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", functionSuccess,
					function(err) {
						console.error("error", err);

					});
			},
			getWhereClause: function(feature, functionSuccess, functionError) {
				var params = {
					attributes: (feature.attributesFieldsName) ? feature.attributesFieldsName
						: feature.attributes
				};
				var myEvent = new Event("getWhereClause", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", functionSuccess, functionError);
			},
			checkFeatureToMaximo: function(feature, functionSuccess, functionError) {
				var params = {
					attributes: (feature.attributesFieldsName) ? feature.attributesFieldsName
						: feature.attributes
				};
				var myEvent = new Event("checkFeatureToLink", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", functionSuccess, functionError);
			},
			updateMaximoObject: function(updatedfeature, originalFeature, functionSuccess) {
				var params = {
					updatedAttributes: (updatedfeature.attributesFieldsName) ? updatedfeature.attributesFieldsName
						: updatedfeature.attributes,
					originalAttributes: (originalFeature.attributesFieldsName) ? originalFeature.attributesFieldsName
						: originalFeature.attributes,
				};
				var myEvent = new Event("updateMaximoObject", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", functionSuccess,
					function(err) {
						console.error("error", err);

					});
			},
			linkFeatureToMaximo: function(feature, esriGeometryJSON, unlinkFirstParam, currentFeatureClass,
				currentSystemRecord, currentWhereClauses, functionSuccess) {
				var params = {
					esriGeometryJSON: esriGeometryJSON,
					attributes: (feature.attributesFieldsName) ? feature.attributesFieldsName
						: feature.attributes,
					unlinkFirst: unlinkFirstParam,
					currentFeatureClass: currentFeatureClass,
					currentSystemRecord: currentSystemRecord,
					currentWhereClauses: currentWhereClauses
				};
				var myEvent = new Event("linkfeatureToMaximo", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", functionSuccess,
					function(err) {
						console.error("error", err);

					});
			},
			createNewSDEMbo: function(layerName, layerId, layerGroup, editingObjectGeometryData,
				editingObjectGeometryInfo, geometryService, successFunction) {
				var params = {
					layerName: layerName,
					layerId: layerId,
					layerGroup: layerGroup,
					editingObjectGeometryData: editingObjectGeometryData,
					editingObjectGeometryInfo: editingObjectGeometryInfo,
					geometryService: geometryService
				};
				var myEvent = new Event("createNewSDEMbo", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", successFunction,
					function(err) {
						console.error("error", err);

					});
			},
			updateSDEMbo: function(layerName, layerId, layerGroup, objectId, updateArray, successFunction) {
				var params = {
					layerName: layerName,
					layerId: layerId,
					layerGroup: layerGroup,
					objectId: objectId,
					updateArray: updateArray
				};
				var myEvent = new Event("updateSDEMbo", "spatialmapdispatcher", params, REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", successFunction,
					function(err) {
						console.error("error", err);

					});
			},
			deleteGISFeature: function(featureClass, idFieldName, idFieldValue, successFunction) {
				var params = {
					featureClass: featureClass,
					idFieldName: idFieldName,
					idFieldValue: idFieldValue
				};
				var myEvent = new Event("deleteGISFeature", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", successFunction,
					function(err) {
						console.error("error", err);
					});
			},
			deleteLinearLayerSegmentObjects: function(objectName, relationship, attributes, successCallback,
				errorCallback) {
				var myEvent = new Event("deleteLinearLayerSegmentObjects", this.compId, {
					objectName: objectName,
					relationship: relationship,
					attributes: attributes
				}, REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", successCallback, errorCallback);
			},
			/**
			 * Save sketchs to maximo
			 */
			saveSketchToMaximo: function(graphicsArray, extent, functionSuccess) {

				var params = {
					arrayToBeSaved: graphicsArray,
					extent: extent
				};

				var myEvent = new Event("saveSketchToMaximo", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", functionSuccess,
					function(err) {
						console.error(
							"Problem with Sketch Tool Function's save Graphics. queue Manager error.",
							err);
					});
			},

			/**
			 * Delete Sketch From Maximo
			 */
			deleteSketchFromMaximo: function(sketchID, functionSuccess) {

				var params = {
					sketchToBeDeleted: sketchID
				};

				var myEvent = new Event("deleteSketchFromMaximo", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", functionSuccess,
					function(err) {
						console.error(
							"Problem with Sketch Tool Function's delete Sketchs. queue Manager error.",
							err);
					});
			},

			/**
			 * Load sketchs to maximo
			 */
			loadSketchFromMaximo: function(functionSuccess) {
				var params = {
					h: 1
				};

				var myEvent = new Event("loadSketchFromMaximo", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", functionSuccess,
					function(err) {
						console.error(
							"Problem with Sketch Tool Function's load Graphics. queue Manager error.",
							err);
					});
			},

			/**
			 * Save the Tools Configuration, such as dialog position (x,y), dimension (width, height), open or
			 * not, and specific configuration for each tool.
			 */
			saveToolsConfiguration: function(toolsJson, functionSuccess) {
				var params = {
					toolsJson: toolsJson
				};

				var myEvent = new Event("saveToolsConfiguration", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager
					.queueEvent(
						myEvent,
						"application/json",
						"json",
						functionSuccess,
						function(err) {
							console
								.error(
									"Problem with saveToolsConfiguration Function. queue Manager error.",
									err);
						});
			},

			/**
			 * Load the Tools Configuration, such as dialog position (x,y), dimension (width, height), open or
			 * not, and specific configuration for each tool.
			 */
			loadToolsConfiguration: function(functionSuccess) {
				var myEvent = new Event("loadToolsConfiguration", "spatialmapdispatcher", {},
					REQUESTTYPE_HIGHASYNC);
				queueManager
					.queueEvent(
						myEvent,
						"application/json",
						"json",
						functionSuccess,
						function(err) {
							console
								.error(
									"Problem with loadToolsConfiguration Function. queue Manager error.",
									err);
						});
			},

			/**
			 * Send Maximo event to display a Maxmsg.
			 * 
			 * @param msgGroup
			 * @param msgKey
			 * @param params
			 *            string[]
			 */
			showMessage: function(msgGroup, msgKey, params) {

				var myEvent = new Event("showMaxMessage", this.compId, {
					msgKey: msgKey,
					msgGroup: msgGroup,
					params: params
				}, REQUESTTYPE_SYNC);
				queueManager.queueEvent(myEvent, "text/xml", "xml", processXHR, function(err) {
					console.log("error", err);
				});
			},
			showMaximoDialog: function(dialogId, objectname, objectid, relationship) {
				addCommInput('dialogid', dialogId);
				if (objectname && objectid) {
					addCommInput('objectname', objectname);
					addCommInput('objectid', objectid);

				}
				if (relationship) {
					addCommInput('relationship', relationship);
				}
				dojo.publish("onDialogRequested_" + this.compId, []);
				sendEvent('showDialog', this.compId, '');
			},
			showQueryUnassignedWorkDialog: function(bounds) {
				//before showing Maximo Dialog, return the dojo mapping to Maximo Dojo
				if (this.mapConf.provider === "spatial") {
					document.__dojoToDomId = ibm.tivoli.fwm.mxmap.factory._dojoToDomId;
					require({ map: { "*": { dojo: "dojo", dijit: "dijit", dojox: "dojox" } } }, ["require"]);
				}
				if (bounds) {
					addCommInput('mapbounds_sw_latitudey', bounds.sw.lat);
					addCommInput('mapbounds_sw_longitudex', bounds.sw.lon);
					addCommInput('mapbounds_ne_latitudey', bounds.ne.lat);
					addCommInput('mapbounds_ne_longitudex', bounds.ne.lon);
				} else {
					console.warn("No bounds specified for query unassigned work");
				}
				this.showMaximoDialog('map_wo_query_unassigned_work', null, null);
			},
			showAuditLBSLocationDialog: function() {
				this.showMaximoDialog('map_labor_crew_query_location_history', null, null);
			},
			queryUnassignedWorkDispatcher: function(queryData, callback, errorCb) {
				if (queryData) {
					var myEvent = new Event("queryUnassignedWorkDispatcher", this.compId, queryData,
						REQUESTTYPE_HIGHASYNC);
					queueManager.queueEvent(myEvent, "application/json", "json", callback, errorCb);
				} else {
					console.warn("No queryData specified for query unassigned work");
				}
			},
			refreshQueryUnassignedWork: function(bounds, queryData, callback, errorCb) {
				if (bounds) {
					var params = {
						"bounds": bounds,
						"queryData": queryData
					};
					var myEvent = new Event("queryUnassignedWorkDispatcher", this.compId, params,
						REQUESTTYPE_HIGHASYNC);
					queueManager.queueEvent(myEvent, "application/json", "json", callback, errorCb);
				} else {
					console.warn("No bounds specified for query unassigned work");
				}
			},
			getCrewLaborByQueryParams: function(callback, erroCb, queryParams) {

				var myEvent = new Event("getCrewLaborByQueryParams", this.compId, queryParams,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", callback, erroCb);
			},
			getWeatherAlertsByQueryParams: function(callback, erroCb, queryParams) {

				var myEvent = new Event("getWeatherAlertsByQueryParams", this.compId, queryParams,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", callback, erroCb);
			},

			_refreshDSRunning: false,
			refreshDatasource: function(callback, errorcb) {
				if (this._refreshDSRunning == true) {
					console.log("refresh datasouce is already taking place.");
					return;
				}
				var onSuccess = function(response) {
					console.log("[Maximo Integration] Refreshing Map: ", response);
					callback(response);
					if ((response != null) && (response != undefined)) {
						/* 12-13622 */
						if (response.action.data.error) {
							this.showMessage(response.action.data.error.group, response.action.data.error.key,
								[
									response.action.data.error.params
								]);
						}
					}
					this._refreshDSRunning = false;
				};
				var onError = function() {
					console.error("Failed to refresh marker position");
					errorcb();
					this._refreshDSRunning = false;
				};
				var myEvent = new Event("refreshMarkersPositions", this.compId, {}, REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", dojo.hitch(this, onSuccess),
					dojo.hitch(this, onError));
			},
			loadSymbologyConfigFile: function(successCallback, errorCallback) {
				var myEvent = new Event("loadSymbologyConfig", this.compId, "", REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", successCallback, errorCallback);
			},
			refreshLinearLayers: function(mapMeasureUnit, successCallback, errorCallback) {
				var params = {
					"mapMeasureUnit": mapMeasureUnit
				};
				var myEvent = new Event("refreshLinearLayers", this.compId, params, REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", successCallback, errorCallback);
			},
			getAutoLocateLabel: function(successCallback) {
				var params = {};
				var myEvent = new Event("getAutoLocateLabel", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager
					.queueEvent(
						myEvent,
						"application/json",
						"json",
						successCallback,
						function(err) {
							console
								.error(
									"Problem with autolocate label function. queue Manager error.",
									err);
						});
			},
			isCurrentMboAddressable: function(callback, erroCb) {
				var myEvent = new Event("isCurrentMboAddressable", this.compId, {}, REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", callback, erroCb);
			},
			isMboFormattedAddressEditable: function(callback, erroCb) {
				var myEvent = new Event("isMboFormattedAddressEditable", this.compId, {}, REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", callback, erroCb);
			},
			unlinkOrphanMaximoRecord: function(systemOfRecord, featureClass, callback, erroCb) {
				var params = {
					systemOfRecord: systemOfRecord,
					featureClass: featureClass
				};
				var myEvent = new Event("unlinkOrphanMaximoRecord", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", callback, erroCb);
			},
			generateUpdatedLayerDefinition: function(mapServiceName, layerIds, callback, erroCb) {
				var params = {
					mapServiceName: mapServiceName,
					layerIds: layerIds
				};
				var myEvent = new Event("generateUpdatedLayerDefinition", "spatialmapdispatcher", params,
					REQUESTTYPE_HIGHASYNC);
				queueManager.queueEvent(myEvent, "application/json", "json", callback, erroCb);
			},
			/**
			 * Send request to Maximo for getting MultiAssetLocCI records
			 * 
			 * @param {*} callback 
			 * @param {*} erroCb 
			 */
			getWOMultiAssetLocCIRecords: function(callback, erroCb) {
				var myEvent = new Event( "getWOMultiAssetLocCIRecords", "spatialmapdispatcher", {},
						REQUESTTYPE_HIGHASYNC );
				queueManager.queueEvent( myEvent, "application/json", "json", callback, erroCb);
			},
			/**
			 *  Send request to Maximo for getting Task records
			 * @param {*} callback 
			 * @param {*} erroCb 
			 */
			getWORelatedTasks: function(callback, erroCb) {
				var myEvent = new Event( "getWOTaskRecords", "spatialmapdispatcher", {},
						REQUESTTYPE_HIGHASYNC );
				queueManager.queueEvent( myEvent, "application/json", "json", callback, erroCb);
			}
		});
	});

},
'dojox/timing/_base':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["dojo/_base/kernel", "dojo/_base/lang"], function(dojo){
	dojo.experimental("dojox.timing");
	dojo.getObject("timing", true, dojox);

	dojox.timing.Timer = function(/*int*/ interval){
		// summary:
		//		Timer object executes an "onTick()" method repeatedly at a specified interval.
		//		repeatedly at a given interval.
		// interval:
		//		Interval between function calls, in milliseconds.
		this.timer = null;
		this.isRunning = false;
		this.interval = interval;

		this.onStart = null;
		this.onStop = null;
	};

	dojo.extend(dojox.timing.Timer, {
		onTick: function(){
			// summary:
			//		Method called every time the interval passes.  Override to do something useful.
		},
			
		setInterval: function(interval){
			// summary:
			//		Reset the interval of a timer, whether running or not.
			// interval:
			//		New interval, in milliseconds.
			if (this.isRunning){
				window.clearInterval(this.timer);
			}
			this.interval = interval;
			if (this.isRunning){
				this.timer = window.setInterval(dojo.hitch(this, "onTick"), this.interval);
			}
		},
		
		start: function(){
			// summary:
			//		Start the timer ticking.
			// description:
			//		Calls the "onStart()" handler, if defined.
			//		Note that the onTick() function is not called right away,
			//		only after first interval passes.
			if (typeof this.onStart == "function"){
				this.onStart();
			}
			this.isRunning = true;
			this.timer = window.setInterval(dojo.hitch(this, "onTick"), this.interval);
		},
		
		stop: function(){
			// summary:
			//		Stop the timer.
			// description:
			//		Calls the "onStop()" handler, if defined.
			if (typeof this.onStop == "function"){
				this.onStop();
			}
			this.isRunning = false;
			window.clearInterval(this.timer);
		}
	});
	return dojox.timing;
});

},
'ibm/tivoli/fwm/mxmap/actions/Actions':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/Menu"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.actions.Actions");

dojo.require("dijit.Menu");
dojo.declare("ibm.tivoli.fwm.mxmap.actions.Actions", null, {
	divId : null,
	map : null,
	label : null,	
	constructor : function(params) {
		dojo.mixin(this, params);

	},
	execute : function(args) {
		console.info("not implemented");
	}

});

});

},
'dijit/form/CheckBox':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"require",
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/has",		// has("dijit-legacy-requires")
	"dojo/query", // query
	"dojo/ready",
	"./ToggleButton",
	"./_CheckBoxMixin",
	"dojo/text!./templates/CheckBox.html",
	"dojo/NodeList-dom", // NodeList.addClass/removeClass
	"../a11yclick"	// template uses ondijitclick
], function(require, declare, domAttr, has, query, ready, ToggleButton, _CheckBoxMixin, template){

	// module:
	//		dijit/form/CheckBox

	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/form/RadioButton"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.form.CheckBox", [ToggleButton, _CheckBoxMixin], {
		// summary:
		//		Same as an HTML checkbox, but with fancy styling.
		//
		// description:
		//		User interacts with real html inputs.
		//		On onclick (which occurs by mouse click, space-bar, or
		//		using the arrow keys to switch the selected radio button),
		//		we update the state of the checkbox/radio.
		//
		//		There are two modes:
		//
		//		1. High contrast mode
		//		2. Normal mode
		//
		//		In case 1, the regular html inputs are shown and used by the user.
		//		In case 2, the regular html inputs are invisible but still used by
		//		the user. They are turned quasi-invisible and overlay the background-image.

		templateString: template,

		baseClass: "dijitCheckBox",

		_setValueAttr: function(/*String|Boolean*/ newValue, /*Boolean*/ priorityChange){
			// summary:
			//		Handler for value= attribute to constructor, and also calls to
			//		set('value', val).
			// description:
			//		During initialization, just saves as attribute to the `<input type=checkbox>`.
			//
			//		After initialization,
			//		when passed a boolean, controls whether or not the CheckBox is checked.
			//		If passed a string, changes the value attribute of the CheckBox (the one
			//		specified as "value" when the CheckBox was constructed
			//		(ex: `<input data-dojo-type="dijit/CheckBox" value="chicken">`).
			//
			//		`widget.set('value', string)` will check the checkbox and change the value to the
			//		specified string.
			//
			//		`widget.set('value', boolean)` will change the checked state.

			if(typeof newValue == "string"){
				this.inherited(arguments);
				newValue = true;
			}
			if(this._created){
				this.set('checked', newValue, priorityChange);
			}
		},
		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works.
			// description:
			//		If the CheckBox is checked, returns the value attribute.
			//		Otherwise returns false.
			return this.checked && this._get("value");
		},

		// Override behavior from Button, since we don't have an iconNode or valueNode
		_setIconClassAttr: null,
		_setNameAttr: "focusNode",

		postMixInProperties: function(){
			this.inherited(arguments);

			// Need to set initial checked state via node.setAttribute so that form submit works
			// and IE8 radio button tab order is preserved.
			// domAttr.set(node, "checked", bool) doesn't work on IE until node has been attached
			// to <body>, see #8666
			this.checkedAttrSetting = "";
		},

		 _fillContent: function(){
			// Override Button::_fillContent() since it doesn't make sense for CheckBox,
			// since CheckBox doesn't even have a container
		},

		_onFocus: function(){
			if(this.id){
				query("label[for='"+this.id+"']").addClass("dijitFocusedLabel");
			}
			this.inherited(arguments);
		},

		_onBlur: function(){
			if(this.id){
				query("label[for='"+this.id+"']").removeClass("dijitFocusedLabel");
			}
			this.inherited(arguments);
		}
	});
});

},
'dijit/_Container':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach array.indexOf
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.place
	"dojo/_base/kernel" // kernel.deprecated
], function(array, declare, domConstruct, kernel){

	// module:
	//		dijit/_Container

	return declare("dijit._Container", null, {
		// summary:
		//		Mixin for widgets that contain HTML and/or a set of widget children.

		buildRendering: function(){
			this.inherited(arguments);
			if(!this.containerNode){
				// All widgets with descendants must set containerNode.
				// NB: this code doesn't quite work right because for TabContainer it runs before
				// _TemplatedMixin::buildRendering(), and thus
				// sets this.containerNode to this.domNode, later to be overridden by the assignment in the template.
				this.containerNode = this.domNode;
			}
		},

		addChild: function(/*dijit/_WidgetBase*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Makes the given widget a child of this widget.
			// description:
			//		Inserts specified child widget's dom node as a child of this widget's
			//		container node, and possibly does other processing (such as layout).

			// I want to just call domConstruct.place(widget.domNode, this.containerNode, insertIndex), but the counting
			// is thrown off by text nodes and comment nodes that show up when constructed by markup.
			// In the future consider stripping those nodes on construction, either in the parser or this widget code.
			var refNode = this.containerNode;
			if(insertIndex > 0){
				// Old-school way to get nth child; dojo.query would be easier but _Container was weened from dojo.query
				// in #10087 to minimize download size.   Not sure if that's still and issue with new smaller dojo/query.
				refNode = refNode.firstChild;
				while(insertIndex > 0){
					if(refNode.nodeType == 1){ insertIndex--; }
					refNode = refNode.nextSibling;
				}
				if(refNode){
					insertIndex = "before";
				}else{
					// to support addChild(child, n-1) where there are n children (should add child at end)
					refNode = this.containerNode;
					insertIndex = "last";
				}
			}

			domConstruct.place(widget.domNode, refNode, insertIndex);

			// If I've been started but the child widget hasn't been started,
			// start it now.  Make sure to do this after widget has been
			// inserted into the DOM tree, so it can see that it's being controlled by me,
			// so it doesn't try to size itself.
			if(this._started && !widget._started){
				widget.startup();
			}
		},

		removeChild: function(/*Widget|int*/ widget){
			// summary:
			//		Removes the passed widget instance from this widget but does
			//		not destroy it.  You can also pass in an integer indicating
			//		the index within the container to remove (ie, removeChild(5) removes the sixth widget).

			if(typeof widget == "number"){
				widget = this.getChildren()[widget];
			}

			if(widget){
				var node = widget.domNode;
				if(node && node.parentNode){
					node.parentNode.removeChild(node); // detach but don't destroy
				}
			}
		},

		hasChildren: function(){
			// summary:
			//		Returns true if widget has child widgets, i.e. if this.containerNode contains widgets.
			return this.getChildren().length > 0;	// Boolean
		},

		_getSiblingOfChild: function(/*dijit/_WidgetBase*/ child, /*int*/ dir){
			// summary:
			//		Get the next or previous widget sibling of child
			// dir:
			//		if 1, get the next sibling
			//		if -1, get the previous sibling
			// tags:
			//		private
			var children = this.getChildren(),
				idx = array.indexOf(children, child);	// int
			return children[idx + dir];
		},

		getIndexOfChild: function(/*dijit/_WidgetBase*/ child){
			// summary:
			//		Gets the index of the child in this container or -1 if not found
			return array.indexOf(this.getChildren(), child);	// int
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/impl/marker/GmapsMarker':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Marker"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

dojo.require("ibm.tivoli.fwm.mxmap._Marker");
dojo.provide("ibm.tivoli.fwm.mxmap.impl.marker.GmapsMarker");

//This variable is always increased so that the last marker added is always on top
ibm.tivoli.fwm.mxmap.impl.marker.markerZIndex = 1000;
ibm.tivoli.fwm.mxmap.impl.marker.getNextMarkerZIndex = function()
{
	return ibm.tivoli.fwm.mxmap.impl.marker.markerZIndex++;
};

/**
 * Marker
 */
dojo.declare("ibm.tivoli.fwm.mxmap.impl.marker.GmapsMarker", ibm.tivoli.fwm.mxmap._Marker, {
	
	toProprietary: function()
	{

		var options = {};

		// do we have an Anchor?
		var ax = 0; // anchor x
		var ay = 0; // anchor y

		if (this.iconAnchor)
		{
			ax = this.iconAnchor[0];
			ay = this.iconAnchor[1];
		}
		if (!this.iconSize)
		{
			this.iconSize = [ 32, 32 ];
		}
		
		// Defect 67228 - The "overlay" logic is a very ugly workaround that was implemented as a solution
		// to a problem in the positioning of label text.
		// However, markers drawn as "overlay" take precedence (position: absolute) over all other markers
		// which would break the multimarker logic (that draws multimarkers last expecting them to be on top) if multimarkers weren't also drawn as "overlay".
		// So the initial solution was to always draw markers as "overlay". The problem with this solution is that the overlay logic has so many
		// hardcoded positioning numbers that, if a marker has different dimensions and different anchor point than those of regular
		// markers (size [47, 36] anchor [24, 36]) then the positioning of such marker (if drawn as "overlay") will be wrong.
		// So, the solution to the "duplicated My Location marker" is to only apply the "overlay" logic to markers that are expected
		// to be part of a multimarker group. Those who are not will have an extra property in the markerdata: dontDrawAsOverlay.
		// This is still very ugly, but it is not uglier than the current implementation...
		var drawMarkerAsOverlay = (this.attributes['dontDrawAsOverlay'] != true);
		
		var gAnchorPoint = new google.maps.Point(ax, ay);
		if (this.iconUrl)
		{
			// Defect 67228 - See the whole explanation in the beginning of this method
//			if (this.labelText != null && this.labelText.length > 0)
//			{
			if (drawMarkerAsOverlay == true)
			{
				// IV96441: GOOGLE MAPS NOT SHOWING ALL WORKORDERS
				// Transparent markers should not be draggable
			    this.draggable = false;
			    
				// If there's a label, overwrite the default icon with a
				// transparent one, because the real one will be in the
				// overlay
				
				// IV96441: GOOGLE MAPS NOT SHOWING ALL WORKORDERS
				// Use correct path to transparent.png; do not hard code
				// Replaced hard-coded path "../webclient/javascript/ibm/tivoli/fwm/mxmap/resources/transparent.png"
				var rtlDir = "";
				if(document.body.dir == "rtl")
				{
					rtlDir = "/rtl";
				}
				options.icon = new google.maps.MarkerImage(dojo.moduleUrl("ibm.tivoli.fwm.mxmap", "resources") + rtlDir + "/transparent.png", new google.maps.Size(this.iconSize[0], this.iconSize[1]),
						new google.maps.Point(0, 0), gAnchorPoint);
			}
			else
			{
				options.icon = new google.maps.MarkerImage(this.iconUrl, new google.maps.Size(this.iconSize[0], this.iconSize[1]), new google.maps.Point(0, 0), gAnchorPoint);
			}

			// do we have a Shadow?
			if (this.iconShadowUrl)
			{
				if (this.iconShadowSize)
				{
					var x = this.iconShadowSize[0];
					var y = this.iconShadowSize[1];
					options.shadow = new google.maps.MarkerImage(this.iconShadowUrl, new google.maps.Size(x, y), new google.maps.Point(0, 0), gAnchorPoint);
				}
				else
				{
					options.shadow = new google.maps.MarkerImage(this.iconShadowUrl);
				}
			}
		}

		if (this.draggable)
		{
			options.draggable = this.draggable;
		}

		// else
		// {
		// if (this.labelText != null && this.labelText.length > 0)
		// {
		// options.title = this.labelText;
		// }
		// }
		if (this.imageMap)
		{
			options.shape = {
				coord: this.imageMap,
				type: 'poly'
			};
		}
		var latLong = this.location.toProprietary();
		options.position = latLong;
		options.map = this.map;
		// Forcing the last marker added to be always on top
		options.zIndex = ibm.tivoli.fwm.mxmap.impl.marker.getNextMarkerZIndex();

		var marker = new google.maps.Marker(options);
		
		var me = this;

		// Defect 67228 - See the whole explanation in the beginning of this method
//		if ((this.labelText != null && this.labelText.length > 0) || (this.getAttribute("isMultiMarker") == true))
//		{
		if (drawMarkerAsOverlay == true)
		{
			var overlay = new this.map.LabelMarkerOverlay(this.labelText, latLong, this.map, marker, this.iconUrl, this.iconAnchor, this.iconSize);
			this._labelOverlay = overlay;
		}

		if (this.infoBubble)
		{
			var event_action = "click";
			if (this.hover)
			{
				event_action = "mouseover";
			}
			google.maps.event.addListener(marker, event_action, function()
			{
				marker.mxmapMarker.closeBubble();
				marker.mxmapMarker.openBubble();
			});
		}
		if (this.tooltip && this.tooltip.length > 0)
		{
			google.maps.event.addListener(marker, "mouseover", function(a)
			{
				var map = marker.map;
				var scale = Math.pow(2, map.getZoom());
				var nw = new google.maps.LatLng(map.getBounds().getNorthEast().lat(), map.getBounds().getSouthWest().lng());
				var worldCoordinateNW = map.getProjection().fromLatLngToPoint(nw);
				var worldCoordinate = map.getProjection().fromLatLngToPoint(marker.getPosition());
				var pixelOffset = new google.maps.Point(Math.floor((worldCoordinate.x - worldCoordinateNW.x) * scale), Math.floor((worldCoordinate.y - worldCoordinateNW.y) * scale));

				marker.mxmapMarker.showTooltip(pixelOffset, map.getDiv());

			});
			google.maps.event.addListener(marker, "mouseout", function()
			{
				marker.mxmapMarker.hideTooltip();
			});
		}
		if (this.hoverIconUrl)
		{
			var gSize = new google.maps.Size(this.iconSize[0], this.iconSize[1]);
			var zerozero = new google.maps.Point(0, 0);
			var hIcon = new google.maps.MarkerImage(this.hoverIconUrl, gSize, zerozero, gAnchorPoint);
			var Icon = new google.maps.MarkerImage(this.iconUrl, gSize, zerozero, gAnchorPoint);
			google.maps.event.addListener(marker, "mouseover", function()
			{
				marker.setIcon(hIcon);
			});
			google.maps.event.addListener(marker, "mouseout", function()
			{
				marker.setIcon(Icon);
			});
		}
		
		if (this.draggable)
		{
			google.maps.event.addListener(marker, 'dragstart', function(arg)
			{
				marker.mxmapMarker.hideTooltip();
				// Passing in the marker (not the proprietaty one) as objectSource
				// Defect 66864: The map id was wrong, it was undefined and the marker auto refresh was broken.
				// This happened during mapstraction removal
				dojo.publish("startedUserInteractionOnMap_" + me.compId, [ {
					objectSource: me,
					objectSourceName: 'googlev3',
					eventName: 'dragstart'
				} ]);
				
				me.fireMarkerEvent(me.MarkerEvents.dragstart, {
					marker: me,
					newLocation: {
						lng: arg.latLng.lng(),
						lat: arg.latLng.lat()
					}
				});

			});
			google.maps.event.addListener(marker, 'drag', function(arg)
			{
				me.fireMarkerEvent(me.MarkerEvents.drag,{
					marker: me,
					newLocation: {
						lng: arg.latLng.lng(),
						lat: arg.latLng.lat()
					}
				}); 
						
			});
			google.maps.event.addListener(marker, 'dragend', function(arg)
			{
				me.fireMarkerEvent(me.MarkerEvents.dragend, {
					marker: me,
					newLocation: {
						lng: arg.latLng.lng(),
						lat: arg.latLng.lat()
					}
				});
				// Passing in the marker (not the proprietaty one) as objectSource
				// Defect 66864: The map id was wrong, it was undefined and the marker auto refresh was broken.
				// This happened during mapstraction removal
				dojo.publish("endedUserInteractionOnMap_" + me.compId, [ {
					objectSource: me,
					objectSourceName: 'googlev3',
					eventName: 'dragend'
				} ]);
			});
		}
		google.maps.event.addListener(marker, 'click', function()
		{
			dojo.publish("onMarkerClicked_" + me.compId, [ {
				marker: marker.mxmapMarker
			} ]);

			me.fireMarkerEvent(me.MarkerEvents.click);
		});
		var infowindow = new google.maps.InfoWindow({
			content: this.infoBubble
		});
		this.proprietary_infowindow = infowindow;
		return marker;
	},

	openBubble: function()
	{
		// Defect 99060: Adding this condition so that markers that have been removed
		// from the map cannot have a maptip showing.
		if(this.onmap == true)
		{
			var me = this;
			// Passing in the marker (not the proprietaty one) as objectSource
			// Defect 66864: The map id was wrong, it was undefined and the marker auto refresh was broken.
			// This happened during mapstraction removal
			dojo.publish("startedUserInteractionOnMap_" + me.compId, [ {
				objectSource: me,
				objectSourceName: 'googlev3',
				eventName: 'openBubble'
			} ]);
			this.hideTooltip();
			var infowindow = this.proprietary_infowindow;
			infowindow.setContent(this.infoBubble);
			google.maps.event.addListenerOnce(infowindow, 'closeclick', function(closedWindow)
			{
				// Passing in the marker (not the proprietaty one) as objectSource
				// Defect 66864: The map id was wrong, it was undefined and the marker auto refresh was broken.
				// This happened during mapstraction removal
				dojo.publish("endedUserInteractionOnMap_" + me.compId, [ {
					objectSource: me,
					objectSourceName: 'googlev3',
					eventName: 'closeBubble'
				} ]);
			});
			
			this.fireMarkerEvent(this.MarkerEvents.openInfoBubble,{
				'marker': this
			});

			// Save
			// so we
			// can
			// close
			// it later
			infowindow.open(this.map, this.proprietary_marker);
			this.inherited(arguments);
		}
	},

	closeBubble: function()
	{
		if (this.hasOwnProperty('proprietary_infowindow'))
		{
			this.proprietary_infowindow.close();
		}
		this.inherited(arguments);
	},

	hide: function()
	{
		this.hideTooltip();

		this.proprietary_marker.setOptions({
			visible: false
		});
	},

	remove: function()
	{
		this.hideTooltip();
		this.proprietary_marker.setMap(null);
		try
		{
			if (this._labelOverlay != null)
			{
				this._labelOverlay.setMap(null);
				this._labelOverlay = null;
			}
		}
		catch (e)
		{
			console.warn("[GMapsMarker.remove()]", e);
		}
	},

	show: function()
	{
		this.proprietary_marker.setOptions({
			visible: true
		});
		if (this._labelOverlay != null)
		{
			this._labelOverlay.onAdd();
		}
	},
	
	_sendCloseBubbleEventIfNecessary: function()
	{
		dojo.publish("endedUserInteractionOnMap_" + this.compId, [ {
			objectSource: this,
			objectSourceName: 'googlev3',
			eventName: 'closeBubble'
		} ]);
	}
});

});

},
'dojo/html':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["./_base/kernel", "./_base/lang", "./_base/array", "./_base/declare", "./dom", "./dom-construct", "./parser"],
	function(kernel, lang, darray, declare, dom, domConstruct, parser){
	// module:
	//		dojo/html

	// the parser might be needed..

	// idCounter is incremented with each instantiation to allow assignment of a unique id for tracking, logging purposes
	var idCounter = 0;

	var html = {
		// summary:
		//		TODOC

		_secureForInnerHtml: function(/*String*/ cont){
			// summary:
			//		removes !DOCTYPE and title elements from the html string.
			//
			//		khtml is picky about dom faults, you can't attach a style or `<title>` node as child of body
			//		must go into head, so we need to cut out those tags
			// cont:
			//		An html string for insertion into the dom
			//
			return cont.replace(/(?:\s*<!DOCTYPE\s[^>]+>|<title[^>]*>[\s\S]*?<\/title>)/ig, ""); // String
		},

		// Deprecated, should use dojo/dom-constuct.empty() directly, remove in 2.0.
		_emptyNode: domConstruct.empty,

		_setNodeContent: function(/*DomNode*/ node, /*String|DomNode|NodeList*/ cont){
			// summary:
			//		inserts the given content into the given node
			// node:
			//		the parent element
			// content:
			//		the content to be set on the parent element.
			//		This can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes

			// always empty
			domConstruct.empty(node);

			if(cont){
				if(typeof cont == "number"){
					cont = cont.toString();
				}
				if(typeof cont == "string"){
					cont = domConstruct.toDom(cont, node.ownerDocument);
				}
				if(!cont.nodeType && lang.isArrayLike(cont)){
					// handle as enumerable, but it may shrink as we enumerate it
					for(var startlen=cont.length, i=0; i<cont.length; i=startlen==cont.length ? i+1 : 0){
						domConstruct.place( cont[i], node, "last");
					}
				}else{
					// pass nodes, documentFragments and unknowns through to dojo.place
					domConstruct.place(cont, node, "last");
				}
			}

			// return DomNode
			return node;
		},

		// we wrap up the content-setting operation in a object
		_ContentSetter: declare("dojo.html._ContentSetter", null, {
			// node: DomNode|String
			//		An node which will be the parent element that we set content into
			node: "",

			// content: String|DomNode|DomNode[]
			//		The content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes
			content: "",

			// id: String?
			//		Usually only used internally, and auto-generated with each instance
			id: "",

			// cleanContent: Boolean
			//		Should the content be treated as a full html document,
			//		and the real content stripped of <html>, <body> wrapper before injection
			cleanContent: false,

			// extractContent: Boolean
			//		Should the content be treated as a full html document,
			//		and the real content stripped of `<html> <body>` wrapper before injection
			extractContent: false,

			// parseContent: Boolean
			//		Should the node by passed to the parser after the new content is set
			parseContent: false,

			// parserScope: String
			//		Flag passed to parser.	Root for attribute names to search for.	  If scopeName is dojo,
			//		will search for data-dojo-type (or dojoType).  For backwards compatibility
			//		reasons defaults to dojo._scopeName (which is "dojo" except when
			//		multi-version support is used, when it will be something like dojo16, dojo20, etc.)
			parserScope: kernel._scopeName,

			// startup: Boolean
			//		Start the child widgets after parsing them.	  Only obeyed if parseContent is true.
			startup: true,

			// lifecycle methods
			constructor: function(/*Object*/ params, /*String|DomNode*/ node){
				// summary:
				//		Provides a configurable, extensible object to wrap the setting on content on a node
				//		call the set() method to actually set the content..

				// the original params are mixed directly into the instance "this"
				lang.mixin(this, params || {});

				// give precedence to params.node vs. the node argument
				// and ensure its a node, not an id string
				node = this.node = dom.byId( this.node || node );

				if(!this.id){
					this.id = [
						"Setter",
						(node) ? node.id || node.tagName : "",
						idCounter++
					].join("_");
				}
			},
			set: function(/* String|DomNode|NodeList? */ cont, /*Object?*/ params){
				// summary:
				//		front-end to the set-content sequence
				// cont:
				//		An html string, node or enumerable list of nodes for insertion into the dom
				//		If not provided, the object's content property will be used
				if(undefined !== cont){
					this.content = cont;
				}
				if(typeof cont == 'number'){
					cont = cont.toString();
				}
				// in the re-use scenario, set needs to be able to mixin new configuration
				if(params){
					this._mixin(params);
				}

				this.onBegin();
				this.setContent();

				var ret = this.onEnd();

				if(ret && ret.then){
					// Make dojox/html/_ContentSetter.set() return a Promise that resolves when load and parse complete.
					return ret;
				}else{
					// Vanilla dojo/html._ContentSetter.set() returns a DOMNode for back compat.   For 2.0, switch it to
					// return a Deferred like above.
					return this.node;
				}
			},

			setContent: function(){
				// summary:
				//		sets the content on the node

				var node = this.node;
				if(!node){
					// can't proceed
					throw new Error(this.declaredClass + ": setContent given no node");
				}
				try{
					node = html._setNodeContent(node, this.content);
				}catch(e){
					// check if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV

					// FIXME: need to allow the user to provide a content error message string
					var errMess = this.onContentError(e);
					try{
						node.innerHTML = errMess;
					}catch(e){
						console.error('Fatal ' + this.declaredClass + '.setContent could not change content due to '+e.message, e);
					}
				}
				// always put back the node for the next method
				this.node = node; // DomNode
			},

			empty: function(){
				// summary:
				//		cleanly empty out existing content

				// If there is a parse in progress, cancel it.
				if(this.parseDeferred){
					if(!this.parseDeferred.isResolved()){
						this.parseDeferred.cancel();
					}
					delete this.parseDeferred;
				}

				// destroy any widgets from a previous run
				// NOTE: if you don't want this you'll need to empty
				// the parseResults array property yourself to avoid bad things happening
				if(this.parseResults && this.parseResults.length){
					darray.forEach(this.parseResults, function(w){
						if(w.destroy){
							w.destroy();
						}
					});
					delete this.parseResults;
				}
				// this is fast, but if you know its already empty or safe, you could
				// override empty to skip this step
				domConstruct.empty(this.node);
			},

			onBegin: function(){
				// summary:
				//		Called after instantiation, but before set();
				//		It allows modification of any of the object properties -
				//		including the node and content provided - before the set operation actually takes place
				//		This default implementation checks for cleanContent and extractContent flags to
				//		optionally pre-process html string content
				var cont = this.content;

				if(lang.isString(cont)){
					if(this.cleanContent){
						cont = html._secureForInnerHtml(cont);
					}

					if(this.extractContent){
						var match = cont.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
						if(match){ cont = match[1]; }
					}
				}

				// clean out the node and any cruft associated with it - like widgets
				this.empty();

				this.content = cont;
				return this.node; // DomNode
			},

			onEnd: function(){
				// summary:
				//		Called after set(), when the new content has been pushed into the node
				//		It provides an opportunity for post-processing before handing back the node to the caller
				//		This default implementation checks a parseContent flag to optionally run the dojo parser over the new content
				if(this.parseContent){
					// populates this.parseResults and this.parseDeferred if you need those..
					this._parse();
				}
				return this.node; // DomNode
				// TODO: for 2.0 return a Promise indicating that the parse completed.
			},

			tearDown: function(){
				// summary:
				//		manually reset the Setter instance if its being re-used for example for another set()
				// description:
				//		tearDown() is not called automatically.
				//		In normal use, the Setter instance properties are simply allowed to fall out of scope
				//		but the tearDown method can be called to explicitly reset this instance.
				delete this.parseResults;
				delete this.parseDeferred;
				delete this.node;
				delete this.content;
			},

			onContentError: function(err){
				return "Error occurred setting content: " + err;
			},

			onExecError: function(err){
				return "Error occurred executing scripts: " + err;
			},

			_mixin: function(params){
				// mix properties/methods into the instance
				// TODO: the intention with tearDown is to put the Setter's state
				// back to that of the original constructor (vs. deleting/resetting everything regardless of ctor params)
				// so we could do something here to move the original properties aside for later restoration
				var empty = {}, key;
				for(key in params){
					if(key in empty){ continue; }
					// TODO: here's our opportunity to mask the properties we don't consider configurable/overridable
					// .. but history shows we'll almost always guess wrong
					this[key] = params[key];
				}
			},
			_parse: function(){
				// summary:
				//		runs the dojo parser over the node contents, storing any results in this.parseResults
				//		and the parse promise in this.parseDeferred
				//		Any errors resulting from parsing are passed to _onError for handling

				var rootNode = this.node;
				try{
					// store the results (widgets, whatever) for potential retrieval
					var inherited = {};
					darray.forEach(["dir", "lang", "textDir"], function(name){
						if(this[name]){
							inherited[name] = this[name];
						}
					}, this);
					var self = this;
					this.parseDeferred = parser.parse({
						rootNode: rootNode,
						noStart: !this.startup,
						inherited: inherited,
						scope: this.parserScope
					}).then(function(results){
							return self.parseResults = results;
						}, function(e){
							self._onError('Content', e, "Error parsing in _ContentSetter#" + self.id);
						});
				}catch(e){
					this._onError('Content', e, "Error parsing in _ContentSetter#" + this.id);
				}
			},

			_onError: function(type, err, consoleText){
				// summary:
				//		shows user the string that is returned by on[type]Error
				//		override/implement on[type]Error and return your own string to customize
				var errText = this['on' + type + 'Error'].call(this, err);
				if(consoleText){
					console.error(consoleText, err);
				}else if(errText){ // a empty string won't change current content
					html._setNodeContent(this.node, errText, true);
				}
			}
		}), // end declare()

		set: function(/*DomNode*/ node, /*String|DomNode|NodeList*/ cont, /*Object?*/ params){
			// summary:
			//		inserts (replaces) the given content into the given node. dojo/dom-construct.place(cont, node, "only")
			//		may be a better choice for simple HTML insertion.
			// description:
			//		Unless you need to use the params capabilities of this method, you should use
			//		dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct..place() has more robust support for injecting
			//		an HTML string into the DOM, but it only handles inserting an HTML string as DOM
			//		elements, or inserting a DOM node. dojo/dom-construct..place does not handle NodeList insertions
			//		dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct.place() has more robust support for injecting
			//		an HTML string into the DOM, but it only handles inserting an HTML string as DOM
			//		elements, or inserting a DOM node. dojo/dom-construct.place does not handle NodeList insertions
			//		or the other capabilities as defined by the params object for this method.
			// node:
			//		the parent element that will receive the content
			// cont:
			//		the content to be set on the parent element.
			//		This can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes
			// params:
			//		Optional flags/properties to configure the content-setting. See dojo/html/_ContentSetter
			// example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage:
			//	|	html.set(node, "some string");
			//	|	html.set(node, contentNode, {options});
			//	|	html.set(node, myNode.childNodes, {options});
			if(undefined == cont){
				console.warn("dojo.html.set: no cont argument provided, using empty string");
				cont = "";
			}
			if (typeof cont == 'number'){
				cont = cont.toString();
			}
			if(!params){
				// simple and fast
				return html._setNodeContent(node, cont, true);
			}else{
				// more options but slower
				// note the arguments are reversed in order, to match the convention for instantiation via the parser
				var op = new html._ContentSetter(lang.mixin(
					params,
					{ content: cont, node: node }
				));
				return op.set();
			}
		}
	};
	lang.setObject("dojo.html", html);

	return html;
});

},
'ibm/tivoli/fwm/mxmap/Map':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
define([
	"dojo/main", "dijit/main", "dojox/main", "dojo/on",
	"dojo/_base/declare", "ibm/tivoli/fwm/mxmap/_MapProvider",
	"ibm/tivoli/fwm/mxmap/ContextMenu",
	"ibm/tivoli/fwm/mxmap/CurrentMXRecordSet",
	"ibm/tivoli/fwm/mxmap/MXRecord",
	"ibm/tivoli/fwm/mxmap/MaximoIntegration",
	"ibm/tivoli/fwm/mxmap/helpers/GeocoderHelper",
	"ibm/tivoli/fwm/mxmap/UserSessionManager",
	"ibm/tivoli/fwm/mxmap/MapTipsManager",
	"ibm/tivoli/fwm/mxmap/helpers/MapMarkersRefresher",
	"ibm/tivoli/fwm/mxmap/toolbar/ToolbarManager",
	"ibm/tivoli/fwm/mxmap/CurrentMXRecManager",
	"ibm/tivoli/fwm/mxmap/helpers/MapFullScreenHelper",
	"ibm/tivoli/fwm/mxmap/layers/manager/LayersManager",
	"ibm/tivoli/fwm/mxmap/symbology/SymbologyManager",
	"ibm/tivoli/fwm/mxmap/ImageLibraryManager",
	"dijit/Tooltip",
	"dojo/topic",
	"dojo/dom-style",
	"dojo/dom-construct",
	"dojo/dom-class",
	"ibm/tivoli/fwm/mxmap/MapZIndexHandler"
], function(dojo, dijit, dojox, on, declare, _MapProvider, ContextMenu, CurrentMXRecordSet, MXRecord, MaximoIntegration, GeocoderHelper, UserSessionManager, MapTipsManager, 
		MapMarkersRefresher, ToolbarManager, CurrentMXRecManager, MapFullScreenHelper, LayersManager,
		SymbologyManager, ImageLibraryManager, Tooltip, topic, domStyle, domConstruct, domClass, MapZIndexHandler) {
	ibm.tivoli.fwm.mxmap.WarningCodes =
	{
		NO_LBS_LOCATION_FOUND: "NO_LBS_LOCATION_FOUND"
	};
	
	return declare(_MapProvider, {
		events: {
			mapLoaded: "mxmap.mapLoaded"
		},
		maptraction: null,
		_actionsAreEnabled: true,
		routeManager: null,
		divId: null,
		height: null,
		width: null,
		heightPx: null,
		widthPx: null,
		compId: null,
		mapConf: null,
		routeConf: null,
		providerName: null,
		isMobile: false,
		router: null,
		isFullScreen: false,
		customInitialMapOptions: {},
		fullScreenHelper: null,
		geocoder: null,
		maximo: null,
		currentRecordSetControl: null,
		userSessionManager: null,
		initialized: false,
		markerRefresher: null,
		toolbar: null,
		currentRecordMgr: null,
		maptips: null,
		contextMenu: null,
		layersManager: null,
		symbologyManager: null,
		_executingFullScreen: null,
		defaultRouteColor: "#ffffff",
		dispatcher: null,
		showDelayTimeTooltip: null,
		toolbarStartupHandle: null,
		DEFAULT_INITIAL_ZOOM: 3,
		mapZIndexHandler: null,
		_providerOK: null,
		MAP_TAB_PARENT_ID: "SystemNavAppContent-sc_div",
		NAV_LIST_COLLAPSE_ID: "nav_list_collapse",
		_isLayoutReady: null,
		LATLONGWKID: 4326,
		getId: function()
		{
			return this.compId;
		},
		constructor: function(options)
		{
			this._datasources = [];

			// MAXIMOLBS-1606 - initiating handler of z-indexes
			this.mapZIndexHandler = new MapZIndexHandler({
				map: this
			});
		},
		getMaximo: function()
		{
			return this.maximo;
		},
		getSessionData: function()
		{
			if (this.mapConf)
			{
				return this.mapConf.sessionData;
			}
			return {};
		},

		/**
		 * In case no configuration was made
		 */
		_getDefaultInitialLocation: function()
		{
			return {
				lat: 0.0,
				lng: 0.0,
				level: 3
			};
		},
		_getInitialLocation: function()
		{
			var location = this.mapConf.initialLocation;

			console.log("[Map] Configured Initial Location ", location);
			var loc = this._getDefaultInitialLocation();

			if (this.userSessionManager != null && this.userSessionManager.hasLastUserLocation())
			{
				location = this.userSessionManager.getLastUserLocation();
			}
			if (location && location.lat && location.lng)
			{
				loc.lat = location.lat;
				loc.lng = location.lng;
			}

			if (location && location.level)
			{
				loc.level = location.level;
			}
			console.log("[Map] Initial Location to be used if no record", loc);
			return loc;

		},
		getMapTipsManager: function()
		{
			return this.maptips;
		},
		_afterInit: function(options, mapDiv) {
			console.log("[Map] Options", options);

			this.mapZIndexHandler.postCreate();

			if (options.isTesting == true)
			{
				console.log("[Map] UT ENABLED");
				this.maximo = options.maximoImpl;
			}
			else
			{
				if( !this.maximo )
				{
					this.maximo = new MaximoIntegration(options);			
				}
			}
			this.maptips = new MapTipsManager({
				maximo: this.maximo
			});
		
			
			if (this.allowsTrafficLayer() == true)
			{
				// Create the traffic layer
				var trafficLayerOptions = {
					layerName: ibm.tivoli.fwm.i18n.getMaxMsg("map", "traffic"),// "Traffic";
					layerId: "traffic",
					map: this
				};
				var TrafficLayerClass = dojo.require("ibm.tivoli.fwm.mxmap.layers.TrafficLayer");
				var trafficLayer = new TrafficLayerClass(trafficLayerOptions);
				this.layersManager.addLayer(trafficLayer, false);
			}

			if(this.mapConf.inputConfs.routedatasrc != null)
			{
			// Create the route layer
				this.createRouteLayer();
			}

			var interval = this.mapConf.inputConfs.refreshmapinterval;
			if (interval != null && interval > 0)
			{
				this.markerRefresher = new MapMarkersRefresher({
					map: this,
					maximo: this.maximo,
					interval: interval
				});
			}

			var me = this;

			/* 12-13622 */
			if (me._sectionExpanded)
			{
				me._showConfErrors();
			}

			this.geocoder = new GeocoderHelper({
				map: me,
				key: this.mapConf.key
			});
			this.setMapType(this.MapType.ROAD);

			console.log("[Map] Input Configurations", this.mapConf.inputConfs);
			if (this.mapConf.inputConfs.toolbarenabled == 1 || this.mapConf.inputConfs.toolbarenabled == true || this.mapConf.inputConfs.toolbarenabled=="true")
			{
				if (dojo.config.fwm.debug == true)
				{
					console.log("[Map] Toolbar enabled with these additional items", this.mapConf.inputConfs.toolitems);
				}
				var additionalItems = [];
				if (this.mapConf.inputConfs.toolitems)
				{
					additionalItems = dojo.fromJson(this.mapConf.inputConfs.toolitems);
				}

				this.toolbar = new ToolbarManager({
					gisdata: this.mapConf.gisdata,
					mxdata: this.mapConf.mxdata,
					items: additionalItems,
					map: me
				});
				
				if (this.mapConf.provider == "spatial") {
					this.toolbarStartupHandle = dojo.subscribe("startupToolbarMapInit", dojo.hitch(this,function(data){
						console.log("[TOOLBAR] startupToolbarMapInit");
						this.toolbar.toolbarWidth = this.width;
						this._startToolbar();
						dojo.unsubscribe(this.toolbarStartupHandle);
					}));
				} else {
					this._startToolbar();
				}
				
			} else {
				if (this.mapConf.provider == "spatial") {
					this.toolbarStartupHandle = dojo.subscribe("startupToolbarMapInit", dojo.hitch(this,function(data){
						//If there is no toolbar, we need to hide the loading image here
						this.hideLoadingImg();
						dojo.unsubscribe(this.toolbarStartupHandle);
					}));
				}			
			}

			this.isFullScreen = (this.mapConf.inputConfs.fullscreenmode == "true");
			this.fullScreenHelper = new MapFullScreenHelper({
				map: me,
				mapToolbar: me.toolbar,
				mapDivElement: dojo.byId(me.divId),
				mapDivWidth: me.widthPx,
				mapDivHeight: me.heightPx
			});
			console.log("[Map] Map configured, waiting for Map loading");
			if (!this.isLoaded())
			{
				this.addOnload(dojo.hitch(this, this._completeInitAfterMapLoads));
			}
			else
			{
				this._completeInitAfterMapLoads();
			}

			if (this.mapConf.isInMapManager)
			{
				var updateExtentsFn = dojo.hitch(this, this.saveExtent);

				this.addMapEventHandler('changeZoom',updateExtentsFn);
				this.addMapEventHandler('endPan',updateExtentsFn);
			} else if (!this.mapConf.isOpenMap && this.mapConf.currentMbo) {
				
				// Create the symbologyManager object and build the layer tree
				// according to the symbology configuration file
				this.mapConf.inputConfs.defaultsymbology = dojo.fromJson(this.mapConf.inputConfs.defaultsymbology);
			    if (!this.symbologyManager)
                {
                    this.symbologyManager = new SymbologyManager({
                        map: this,
                        defaultSymbologyConfig: this.mapConf.inputConfs.defaultsymbology
                    });
                }
                else
                {
                    this.symbologyManager.defaultSymbologyConfig = this.mapConf.inputConfs.defaultsymbology;
                }
				
				this.labelConfs = this.getLabelConfs();
				/*
				 * Create the Service Address label
				 */
				if (this.mapConf.currentMbo.gisdata) {
					var address = this.mapConf.currentMbo.gisdata.address;
					if (address) {
						this.createMapLabel("address");
						this.updateMapAddressLabel(address);
					}
				}
				
				/*
				 * Create the mbo label 
				 */
				if (!this.mboAttributesLabel) {
					this.createMapLabel("attributes");  
				}
				this.updateMboAttributesLabelContent();
				/*
				 * Create the tooltip with the mbo long description
				 */
				var longDescription = this.mapConf.currentMbo.mxdata.attributes.description_longdescription;
				var longDescToolTip = dijit.byId("tooltipAttributesLabel");
				if (longDescToolTip) {
					longDescToolTip.destroyRecursive(true);
				}
				this.longDescriptionToolTip = new Tooltip({
					id : "tooltipAttributesLabel",
					connectId : this.mboAttributesLabel,
					label : longDescription,
					showDelay : this.showDelayTimeTooltip
				});	
				
				/*
				 * Labels update
				 */
				dojo.subscribe("onCurrentRecordUpdate_"+this.getId(), dojo.hitch(this, function(data) {
					var address;
					if (data && data.gisdata) {
						address = data.gisdata.address;
					} 
					if (address) {
						this.updateMapAddressLabel(address);
					} else {
						this.hideMapAddressLabel();
					}
					
					if (data && data.mxdata) {
						this.updateMboAttributesLabelContent(data.mxdata);
						this.updateLongDescToolTip(data.mxdata);
					}
					
				}));
			}
			
			// reset timeout timer
			this.endPanMapEventHandler = this.addMapEventHandler('endPan',dojo.hitch(this, function()
			{
				this.maximo.resetMaximoTimeout(false);
			}));
		},
		convertPoint: function(x, y, sourceWKID, targetWKID) {
			var sourcePoint = new esri.geometry.Point(x, y, new esri.SpatialReference({ wkid: sourceWKID }));
			var	targetPoint = esri.geometry.project(sourcePoint, new esri.SpatialReference({ wkid: targetWKID }));

			return {
				x: targetPoint.x,
				y: targetPoint.y
			};
		},
		convertXYToLongLat: function(x, y, sourceWKID) {
			return this.convertPoint(x, y, sourceWKID, this.LATLONGWKID);
		},
		getMapWKID: function() {
			if (this.mapConf.provider !== "spatial") {
				return this.LATLONGWKID;
			}

			if (!this.map || !this.map.spatialReference) {
				return null;
			}

			return this.map.spatialReference.wkid;
		},
		saveExtent: function(context, args)
		{
			var spatialReference = this.getMapWKID();
			var locInfo = {
				lat: this.getCenter().lat,
				lng: this.getCenter().lng,
				level: this.getZoom(),
				spatialReference: spatialReference
			};
			if (this.selectionTool) {
				locInfo.geometry = this.selectionTool.geometrySelected;
				locInfo.lng = this.selectionTool.geometryCentroid.x;
				locInfo.lat = this.selectionTool.geometryCentroid.y;
			} else {
				var extent = this.map.extent;
				
				if (extent != undefined && extent != null)
				{
					locInfo.xmin = extent.xmin;
					locInfo.ymin = extent.ymin;
					locInfo.xmax = extent.xmax;
					locInfo.ymax = extent.ymax;
				}
				
			}
			
			this.storeUserLocation(locInfo);
		},
		storeUserLocation: function(locInfo) {
			var shouldConvertToLatLong = this.mapConf && this.mapConf.isCoordinatesLatLong;
			if (shouldConvertToLatLong) {
				console.info("[Map] Convert Location to LatLong before saving", locInfo);
				this.convertLocInfoToLatLong(locInfo);
			}

			console.info("[Map] Saving Location", locInfo);
			this.getMaximo().storeUserLocation(locInfo);
		},
		convertLocInfoToLatLong: function (locInfo) {
			var mapWKID = this.getMapWKID();
			var convertXYToLongLat = dojo.hitch(this, this.convertXYToLongLat);

			if (mapWKID === this.LATLONGWKID) {
				return;
			}

			function convertXYFieldsToLongLat(x, y) {
				if (locInfo[x] === undefined || locInfo[y] === undefined) {
					return;
				}

				var point = convertXYToLongLat(locInfo[x], locInfo[y], mapWKID);

				locInfo[x] = point.x;
				locInfo[y] = point.y;
			}

			convertXYFieldsToLongLat('lng', 'lat');
			convertXYFieldsToLongLat('xmin', 'ymin');
			convertXYFieldsToLongLat('xmax', 'ymax');
			locInfo.spatialReference = this.LATLONGWKID;
		},
		/**
		 * Creates a map based on the props of the options param.
		 */
		createMap: function(options)
		{
			console.log('[Map] Map Component Id ', options.compId);
			if (options.compId.indexOf("open_map") > 0) {
				options.mapConf.isOpenMap = true;
			} else {
				options.mapConf.isOpenMap = false;
			}		
			this.refreshListener = [];
			this.compId = options.compId;
			this._sectionExpanded = options.isInExpanded;
			try
			{

				if (this.initialized === true)
				{
					console.warn("already created!");
					return;
				}
				if (options.isInExpanded == false)
				{
					this.disableActions();
				}
				dojo.mixin(this, options);
				
				var mapDiv = dojo.byId(this.divId);
				
				this.userSessionManager = new UserSessionManager({
					map: this,
					persistence: this.mapConf.inputConfs.contextpersistent
				});

				var mapInitOptions = this.getInitOptions();
				if (this.isMobile == true)
				{
					dojo.mixin(mapInitOptions, {
						pan: true,
						zoom: 'small',
						scale: true,
						enableScrollWheelZoom: true,
						map_type: true
					});
				}
				else
				{
					dojo.mixin(mapInitOptions, {
						pan: true,
						zoom: 'large',
						scale: true,
						enableScrollWheelZoom: true,
						map_type: true
					});
				}

				function initializeToolsJson(options) {
					var mapConf = options.mapConf;
					var isSpatialProvider = mapConf && mapConf.provider === "spatial";

					function extractToolsJsonFromOptions(options) {
						if (mapConf) {
							var toolsPersistenceEnable = options.mapConf.toolsPersistenceEnable;
							var loadedToolsConfiguration = options.mapConf.loadedToolsConfiguration;
	
							if (toolsPersistenceEnable && loadedToolsConfiguration) {
								return loadedToolsConfiguration;
							}
						}
					}
					var optionsToolsJson = extractToolsJsonFromOptions(options);

					if (optionsToolsJson) {
						return optionsToolsJson;
					}

					if (isSpatialProvider) {
						return {};
					}

					// Other providers do not have Tools persistence
					return undefined;
				}
				this.toolsJson = initializeToolsJson(options);

				/*
				 * Instantiate these objects here, for being able to use them in the _init method
				 * 
				 */
				this.currentRecordMgr = new CurrentMXRecManager({
					mbo: this.mapConf.currentMbo,
					map: this,
					draggable: (this.isMapViewOnly() == false),
					markerImgUrl: this.mapConf.inputConfs.markerimgurl
				});
				this.symbologyManager = new SymbologyManager({
					map: this,
					defaultSymbologyConfig: this.mapConf.inputConfs.defaultsymbology
				});
				this.layersManager = new LayersManager({
					symbManager: this.symbologyManager,
					layerType: ibm.tivoli.fwm.mxmap.layers.LayerType.LAYER,
					map: this
				});
				this.currentRecordSetControl = new CurrentMXRecordSet({
					records: this.mapConf.records,
					markerImgUrl: this.mapConf.inputConfs.markerimgurl,
					map: this
				});
				
				this.showDelayTimeTooltip = this.mapConf.tooltipDelayTime;
				var backToThisObj = this;
				
				this.adjustMapSize();
				this.resizeInterval = setInterval(dojo.hitch(this, function() {
					if (this._getIsLayoutReady()) {
						clearInterval(this.resizeInterval);
						this._createScroolbarsObserver();
						this._resize();
					}
				}), 50);

				this.navListCollapse = dojo.byId(this.NAV_LIST_COLLAPSE_ID);
				if (this.navListCollapse) {
					this.onNavListCollapseClick = on(this.navListCollapse, "click", dojo.hitch(this, function() {
						setTimeout(dojo.hitch(this, function() {
							this._resize();
							setTimeout(dojo.hitch(this, function() {
								this._resize();
							}), 100);
						}), 250);
					}));
				}

				if (this.mapConf.provider == "spatial") {
					this.init(mapDiv, mapInitOptions).then(dojo.hitch(this, function() {
						this._providerOK = true;
						this._afterInit(options, mapDiv);
					}));
				} else {
					this.init(mapDiv, mapInitOptions);
					this._providerOK = true;
					this._afterInit(options, mapDiv);
				}
			}
			catch (e)
			{
				console.error("Error in map creation", e, dojo.toJson(e));
				sendEvent('showErrors', options.compId, "mapcreationerror");
			}
		},
		adjustMapSize: function() 
		{
			var tableBodyElements = document.getElementsByClassName("tabBodyTableStretch");
			if (tableBodyElements.length > 0) {
				var tableBodyTable = tableBodyElements[0];
				dojo.setStyle(tableBodyTable, "border-spacing", "0px");
			}

		},
		centerAndZoomMap: function()
		{

			if (this.routerManager != null && this.routeConf.hasRoute == true)
			{
				return;
			}
			var initialLocation = this._getInitialLocation();
			if (this.mapConf.zoomToDataInput == true)
			{

				console.log("[Map] Zoom to data input enabled ", this.currentRecordSetControl.isEmpty(), this.currentRecordMgr.hasAnyCoordinates());

				if (this.currentRecordSetControl.isEmpty() == true && this.currentRecordMgr.hasAnyCoordinates() != true)
				{
					if (!this.toolsJson || this.toolsJson.saveMapExtent == "0")
					{
						console.log("[Map] Center and Zoom Map - on default location");
						this._setDefaultLocation(initialLocation);
					}

				}
				else
				{
					if (this.currentRecordMgr.hasAnyCoordinates() == true)
					{
						console.log("[Map] Center and Zoom Map - with current record ");
						this._zoomToCurrentMboRec(initialLocation);
					}
					else
					{
						console.log("[Map] Center and Zoom Map - with multiple records and Zoom Data Enabled");
						this.zoomToMbos(this.currentRecordSetControl.mboInfoArray);
					}
				}

			}
			else
			{
				if (!this.toolsJson || this.toolsJson.saveMapExtent == "0") {
					console.log(this.getId(), "[Map] Center and Zoom Map - on default location", initialLocation);
					this._setDefaultLocation(initialLocation);
				}
			}

		},
		_zoomToCurrentMboRec: function(initialLocation)
		{
			this.currentRecordMgr.centerAndZoom(initialLocation.level);
		},
		_fixMapConfLocation: function(location) {
			var mapWKID = this.getMapWKID();
				
			if (!location.wkid) {
				location.wkid = this.mapConf.isCoordinatesLatLong ? this.LATLONGWKID : mapWKID;
			}

			if (location.wkid !== mapWKID) {
				var lng = location.lng;
				var lat = location.lat;

				var convertedPoint = this.convertPoint(lng, lat, location.wkid, mapWKID);
				location.lng = convertedPoint.x;
				location.lat = convertedPoint.y;
				location.wkid = mapWKID;
			}
		},
		_completeInitAfterMapLoads: function()
		{
			this._checkMapLoadedCorrectly();
			if (dojo.config.fwm.debug == true)
			{
				console.log("[Map] Loading actions", this.mapConf);
			}
			if (this.mapConf.initialLocation) {
				this._fixMapConfLocation(this.mapConf.initialLocation);
			}
			if (this.mapConf.mapFullExtent) {
				this._fixMapConfLocation(this.mapConf.mapFullExtent);
			}
			if (this.mapConf.action)
			{
				switch (this.mapConf.action)
				{
					case "showMBOLocation":
						if (dojo.config.fwm.debug == true)
						{
							console.log("[Map] Show Mbos Location");
						}
						this.currentRecordSetControl.showMXRecordsOnMap();
						
						// IV96441: GOOGLE MAPS NOT SHOWING ALL WORKORDERS
						// If there is a multi-marker at the location of the current record, then the current record will be
						// included in the multi-marker so there is no reason to show the current record. If the current record
						// is in the multi-marker, isMboOnMap is set to true so a separate marker isn't added through the
						// centerAndZoomMap function
						var multiMarkerInfoForCurrentMbo = this._getMultiMarkerInfoUsingGisData(this.currentRecordMgr.mbo);
						if(this.mapConf.provider != "gmaps" || !multiMarkerInfoForCurrentMbo)
						{
							if (this.currentRecordMgr.hasAnyCoordinates())
							{
								this.currentRecordMgr.showCurrentRecord(true);
							}
						}
						else if (this.mapConf.provider == "gmaps" && multiMarkerInfoForCurrentMbo)
						{
							this.currentRecordMgr.isMboOnMap = true;
						}
						/*
						 * If the provider is spatial, and the Map was created with no center, centralize map.
						 * This happens when the mbo position is stored without SpatialReference, or we are at the List Tab
						 */
						if (this.mapConf.provider == "spatial") { 
							if ( this.centerWithNoSpatialReference ) {
								this.centerAndZoomMap();
							} else {
								var initialLocation = this._getInitialLocation();
							this._setDefaultLocation(initialLocation);
							}
						} else {
							this.centerAndZoomMap();
						}

						break;
					case "noAction":
						var initialLocation = this._getInitialLocation();
						this._setDefaultLocation(initialLocation);
						break;
					default:
						console.error("[Map] Unknown initial action", this.mapConf.action);
						break;
				}
			}

			dojo.connect(window, "onresize", this, this._resize);
			if (this.isMobile == true)
			{
				// 12-13046. Safari triggers onorientationchange instead of onresize
				// upon tilting the device.
				var res = function()
				{
					var rr = function()
					{
						this._resize();
					};
					setTimeout(dojo.hitch(this, rr), 200);
				};
				dojo.connect(window, "onorientationchange", this, res);
			}

			this.addSubscription("mxmap_section_expanded_" + this.getId(), dojo.hitch(this, this._mapSectionExpanded));

			if (this.isMapViewOnly() == false)
			{
				console.log("[Map] Map is not read only - creating context menu");
				this.contextMenu = new ContextMenu({
					divId: this.divId,
					compId: this.getId(),
					map: this
				});
				
				// In future we must be able to load
				require(["ibm/tivoli/fwm/mxmap/actions/SetRecordLocation"], dojo.hitch(this, function(SetRecordLocation) {
					var setLocationConf = {
							map: this,
							compId: this.getId(),
							label: "Set record location"
						};
					this.contextMenu.addChild(new SetRecordLocation(setLocationConf));
					this.contextMenu.serverUpdated(this.currentRecordMgr.mboInfo);
				}));
				
			}

			if (this.markerRefresher)
			{
				console.log("[Map] Starting Map Marker Refresher");
				this.markerRefresher.start();
			}
			console.log("[Map] Route Configuration Info: ", this.routeConf);
			if (this.routeConf)
			{

				var rparam = {
					routeUrl: this.mapConf.route,
					map: this,
					provider: this.mapConf.provider,
					routeConf: this.routeConf

				};
				dojo.require("ibm.tivoli.fwm.mxmap.routing.MultipleRoutesManager");
				this.routeManager = new ibm.tivoli.fwm.mxmap.routing.MultipleRoutesManager(rparam);


				if (this._sectionExpanded)
				{
					this._showRouteConfErrors();
				}
				else if (this.routeConf.hasRoute == true)
				{
					var opendirectionsdialog = this.routeConf.showdirectionsonload;

					this.refreshRoute(true, opendirectionsdialog);
				}
				var fctR = function()
				{
					this.refreshRoute(true, false, true);
				};
				this.addSubscription("refreshroute_" + this.getId(), dojo.hitch(this, fctR));
			}

			console.log("[Map] Map is full screen", this.isFullScreen);
			
			this.initialized = true;
			console.log("[Map] Publishing event to indicate map loaded.", this.events.mapLoaded);
			/*
			 * Need to publish using esri API Dojo and Maximo Dojo
			 * window.dojo will always be Maximo Dojo
			 * if the provider is Spatial, dojo will point to esriDojo
			 */
			window.dojo.publish(this.events.mapLoaded, [ this, this.getId(), this ]);
			if (this.mapConf.provider == "spatial") {
				dojo.publish(this.events.mapLoaded, [ this, this.getId(), this ]);
			}
			console.log("[Map] Done");
			var webMapDefined = this.mapConf.SPATIAL && this.mapConf.SPATIAL.webMap && this.mapConf.SPATIAL.webMap.webMapDefined;
			if ((this.mapConf.maplinearConf && this.mapConf.maplinearConf.layersLenght == 0) && (webMapDefined==false)) {
				dojo.publish("startupToolbarMapInit",[]);
			}			
			if (this.isMobile == true)
			{
				// need to handle fullscreen when dialogs are opened/closed
				var onDialogOpen = function()
				{
					if (this.fullScreenHelper._fullScreenOn == true)
					{
						this.fullScreenOff();
						this._mustResetFullScreen = true;
					}
					else
					{
						this._mustResetFullScreen = false;
					}
				};
				var onDialogClose = function()
				{
					if (this._mustResetFullScreen == true)
					{
						this.fullScreenOn();
						this._mustResetFullScreen = false;
					}
				};
				this.addSubscription("onDialogRequested_" + this.getId(), dojo.hitch(this, onDialogOpen));
				this.addSubscription("onDialogClosed_" + this.getId(), dojo.hitch(this, onDialogClose));
			}
			if (this.mapConf.provider != "spatial") {
				// Keeping consistency between spatial and other map providers:
				// When map loads, resize
				this._resize();
			}

		},
		getMapConfiguration: function()
		{
			return this.mapConf;
		},
		getSymbologyManager: function()
		{
			return this.symbologyManager;
		},

		_routeRefreshRunning: false,
		refreshRoute: function(forceRefresh, opendirectionsdialog, servercallback, noZoom, routeFinishCallback, routeErrorCallback)
		{
			if (this._actionsAreEnabled == false)
			{
				console.log("[Map] Actions are disabled maybe map is in a collapsed section");
				return;
			}
			console.log("[Map] Refreshing Routes");
			if (this.routeManager)
			{
				if (this._routeRefreshRunning == true)
				{
					console.warn("Route is already being refreshed");
					return;
				}
				this._routeRefreshRunning = true;
				var fct = function(data)
				{
					this.routeManager.clearAll();
					if (data.hasRoute == true)
					{
						var callback = dojo.hitch(this, function()
						{
							this._routeRefreshRunning = false;
							if (routeFinishCallback)
							{
								routeFinishCallback(this.routeManager);
							}
						});
						console.log("opendirectionsdialog", opendirectionsdialog);
						if (opendirectionsdialog == "true")
						{
							callback = dojo.hitch(this, function()
							{
								// forces the itinerary dialog to open per conf.
								dojo.publish("showItinerary_" + this.getId());
								console.log("forcing dialog to show route info");
								this._routeRefreshRunning = false;
							});
						}
						var errFct2 = dojo.hitch(this, function(statusCode, error)
						{
							this._routeRefreshRunning = false;
							if (routeErrorCallback)
							{
								routeErrorCallback(statusCode, error);
							}
							else
							{
								this.routeManager.routingError(statusCode, error);
							}

						});
						this.routeManager.createRoute(data.stops, this.routeConf, callback, errFct2, noZoom);

					}
					else
					{
	                                    this._routeRefreshRunning = false;
						if (routeFinishCallback)
						{
							routeFinishCallback();
						}
					}

				};
				var fctErr = function(data)
				{
					console.warn("[Map] Error refreshing route", data);
					this._routeRefreshRunning = false;
					if (routeErrorCallback)
					{
						routeErrorCallback(data);
					}
					else
					{
						if (data.error)
						{
							this.maximo.showMessage(data.error.group, data.error.key, [ data.error.params ]);
						}
						else
						{
							this.maximo.showMessage("mapserver", "route_unknown_failure", [ data ]);
						}
					}

				};
				this.maximo.getRouteStops(dojo.hitch(this, fct), dojo.hitch(this, fctErr), forceRefresh, servercallback);
			}
			else
			{
				console.warn("[Map] No route manager on map - could not refresh route.", this.compId);
			}
		},
		refreshDatasource: function(callback, errcallback)
		{
			if (this._actionsAreEnabled == false)
			{
				console.log("[Map] Actions are disabled maybe map is in a collapsed section");
				return;
			}
			var success = dojo.hitch(this, function(response)
			{
				var noZoom = true;
				var datasource = null;
				if(response != null && response != undefined)
				{
				if (response.action.data.currentMbo)
				{
					this.currentRecordMgr.serverUpdated(response.action.data.currentMbo, noZoom);
					datasource = this.currentRecordMgr;
				}
				else
				{
					this.currentRecordSetControl.updateRecordSetAndRefresh(response.action.data.records, noZoom);
					datasource = this.currentRecordSetControl;
				}
				}
				if (callback)
				{
					callback(datasource);
				}
			});
			var error = dojo.hitch(this, function()
			{
				if (errcallback)
				{
					errcallback(response);
				}
			});
			this.maximo.refreshDatasource(success, error);
		},
		_datasources: [],
		registerDatasourceRefresh: function(callback)
		{
			this._datasources.push(callback);

		},
		_refreshEntireMapRunning: null,
		clearMarkerLayer: function() {
			console.log("Map clearMarkerLayer method must be implemented by each map factory");
		},
		refreshMap: function(refreshOptions)
		{
			if (this._actionsAreEnabled == false)
			{
				console.log("[Map] Actions are disabled maybe map is in a collapsed section");
				return;
			}
			if (this._refreshEntireMapRunning == true)
			{
				console.warn("[Map] refresh going on, ignoring second request");
				return;
			}
			console.info("Refresh:Started");
			this._refreshEntireMapRunning = true;
			this.clearMarkerLayer();
			var datasourceToZoomTo = null;
			var finalRefreshStep = dojo.hitch(this, function(routeDatasource)
			{

				var i = -1;
				var mustZoom = true;
				if (refreshOptions && refreshOptions.zoom == false)
				{
					mustZoom = false;
				}
				var fct = dojo.hitch(this, function(datasourceObjectToZoom)
				{

					i++;
					if (datasourceObjectToZoom)
					{
						datasourceToZoomTo = datasourceObjectToZoom;
					}
					if (i < this._datasources.length)
					{
						this._datasources[i](fct, null, !mustZoom);
					}
					else
					{
						if (datasourceToZoomTo != null && mustZoom)
						{
							datasourceToZoomTo.centerAndZoom();
							if(datasourceToZoomTo.getWarning != undefined)
							{
								var warning = datasourceToZoomTo.getWarning();
								if(warning)
								{
									this.showWarning(warning);
						}
							}
						}
						console.info("Refresh:Ended");
						//Remove linear layer if the currentMbo is not linked
						if (this.mapConf.currentMbo != null 
								&& this.mapConf.currentMbo.gisdata != null
								&& this.mapConf.currentMbo.gisdata.PLUSSISGIS == false)
						{
							var layersToRemove = [];
							
							var graphicsLayerIds = this.map.graphicsLayerIds;
							dojo.forEach(graphicsLayerIds, dojo.hitch(this, function(graphicsLayerId, i){
								var layerExist = this.map.getLayer(graphicsLayerId);
								if (layerExist && layerExist.isLinear) {
									layersToRemove.push(graphicsLayerId);
								} 
							}));
							if (layersToRemove.length == 0) {
								dojo.publish("refreshMapTools", []);
							} else {
								var layerRemoveEvent = this.map.on("layer-remove", dojo.hitch(this, function(layerRemoved){
									if (layerRemoved.layer) {
										var layerId = layerRemoved.layer.id;
										var index = layersToRemove.indexOf(layerId);
										if (index > -1) {
											layersToRemove.splice(index, 1);
										}
										if (layersToRemove.length == 0) {
											layerRemoveEvent.remove();
											dojo.publish("refreshMapTools", []);
										}
									}
								}));
								var layersToRemoveClone = dojo.clone(layersToRemove);
								dojo.forEach(layersToRemoveClone, dojo.hitch(this, function(layerToRemove, i){
									if (layerToRemove != undefined && layerToRemove != null) {
										var layer = this.map.getLayer(layerToRemove);
										this.map.removeLayer(layer);
									}								
								}));
							}
						};
						this._refreshEntireMapRunning = false;
						dojo.publish("onMapRefresh_" + this.getId(), [ refreshOptions ]);

					}
				});
				fct(routeDatasource);
			});
			// this only happens if we have the applet as datasource so we can skip
			// to the last step directly
			if (this._datasources.length > 0 && (this.mapConf.inputConfs.datasrc == 'MAINRECORD' && this.currentRecordMgr.hasAnyCoordinates() == false) || this.mapConf.inputConfs.datasrc == null
					|| this.mapConf.inputConfs.datasrc.length == 0)
			{
				finalRefreshStep();
			}
			else
			{

				var routeTrigger = dojo.hitch(this, function(datasource)
				{
					datasourceToZoomTo = datasource;
					var routeError = dojo.hitch(this, function(statusCode, error)
					{
						if (refreshOptions && refreshOptions.automatic == false)
						{
							this.routeManager.routingError(statusCode, error);
						}
						finalRefreshStep();
					});
					this.refreshRoute(true, false, false, true, finalRefreshStep, routeError);
				});
				this.refreshDatasource(routeTrigger);
			}

		},
		setRecordLocation: function()
		{
			console.log("[Map] Setting current record location: ", this.contextMenu.map.point);
			dijit.popup.close(this.contextMenu);
		},
		clearMarkers: function()
		{
			this.removeAllMarkers();
		},
		getMultipleRoutesManager: function()
		{
			return this.routeManager;
		},
		/**
		 * Return any initial provider specific configuration. If any custom conf is
		 * set (by MapControl or presentations 'initialMapOptions' property) it will
		 * override the current code conf.
		 *
		 */
		getInitOptions: function()
		{
			var defOptions = this._getInitOptions();
			var customInitOptions = this._getCustomInitOptions(this.mapConf.mapoptions);
			for ( var propName in customInitOptions)
			{
				if (customInitOptions.hasOwnProperty(propName))
				{
					var propValue = customInitOptions[propName];
					defOptions[propName] = propValue;
				}
			}
			return defOptions;
		},
		_getCustomInitOptions: function()
		{
			throw "Cannot find custom init options";
		},
		_getInitOptions: function()
		{
			console.warn("No implementation found");
			return {};
		},
		getGeoCoderConf: function()
		{
			return {};
		},
		/**
		 * Set the map current location based on lat/lng and zoom level
		 */
		_setLocation: function(lat, lng, level)
		{
			var latLng = this.latLng(lat, lng);
			this.setCenterAndZoom(latLng, level);
		},
		/**
		 * Set the map current location based on location object {latitude,
		 * longitude, zoomlevel}
		 */
		_setDefaultLocation: function(location)
		{

			if (location && location.lat && location.lng)
			{
				console.log("[Map] setDefaultLocation", location);
				var latLng = this.latLng(location.lat, location.lng);
				this.setCenterAndZoom(latLng, location.level);
			}
			else
			{
				console.log("[Map] setDefaultLocation missing default location");
				this.setCenterAndZoom(this.latLng(0, 0), this.DEFAULT_INITIAL_ZOOM);
			}

		},
		/**
		 * this function resizes the map div based on the input.
		 */
		_resize: function()
		{
			if (!this._getIsLayoutReady()) {
				return;
			}
			
			var mapElement = dojo.byId(this.divId);

			if (!mapElement) {
				if (dojo.config.fwm.debug) {
					console.info('[Map] Ignoring resize as map element does not exist');
				}

				return;
			}

			var h = this.height;
			var w = this.width;
			if (!this.height)
			{
				h = '100%';
			}
			if (!this.width)
			{
				w = '100%';
			}

			if ((typeof h.substr != 'undefined') && (h.substr(h.length - 1, 1) == '%'))
			{

				// 100% is not valid in maximo, so we need to
				// configure
				// FYI... offsetTop is only returned when the
				// style on the div is position:absolute or
				// position:relative (in
				// some
				// cases)
				// we minus 50, since there is extra padding in
				// maximo that causes
				// scrolling
				// 12-10712 negative values breaks in ie
				if(!this.mapConf.isOpenMap)
				{
					
					h = this._getHeightInPixels(h, mapElement);
					if (h <= 0)
					{
						h = 200;
					}
					
				}
				else //In OpenMap context, we must calculate it differently so we hide vertical scroll-bar
				{
					h = this._getHeightInPixels(h, mapElement) * 0.7;
					if (h <= 0)
					{
						h = 200;
					}
					
					var openMapDialog = dojo.byId("pluss_open_map-dialog_inner");
					domStyle.set(openMapDialog,'top', '80px' );
				}
			}

			// 142350 - Someone has appended a "px" in both w and h without even checking if
			// it is a number, or a string, or if it already contains either a "px" or a "%" sufix... :(
			var widthWithUom = w;
			var heightWithUom = h;
			if (typeof h == 'string' || h instanceof String)
			{
				if ((h.indexOf("px") < 0) && (h.indexOf("%") < 0))
				{
					heightWithUom = h + "px";
				}
			}
			else
			{
				heightWithUom = h + "px";
			}

			if (typeof w == 'string' || w instanceof String)
			{
				if ((w.indexOf("px") < 0) && (w.indexOf("%") < 0))
				{
					widthWithUom = w + "px";
				}
			}
			else
			{
				widthWithUom = w + "px";
			}

			// we don't do the same for width, since maximo components are in TD
			// rows and the map inherits the row width.
			domStyle.set(mapElement, 'width', widthWithUom);
			domStyle.set(mapElement, 'height', heightWithUom);

			if (this.toolbar)
			{
				this.toolbar.updateToolbarWidth(w);
			}
			this.heightPx = parseInt(("" + h).match(/\d+/) || 0);

			this.widthPx = this._getWidthInPixels(w);

			if (this._providerOK)
			{
				// 12-10810 - it is needed not only for the full
				// screen but also if the user resizes the screen
				// without fullscreen.
				this.resizeTo(w, h, this.widthPx, this.heightPx);
				// Issue 12-12704. If in fullscreen mode, the map div needs to be
				// resized differently

				if (this.fullScreenHelper)
				{
					this.fullScreenHelper.updateMapDimensions(w, h);
				}
			}

		},
		/**
		 * Converts values in % into actual pixel ones
		 */
		_getHeightInPixels: function(height, mapElement)
		{
			var h = height.substr(0, height.length - 1);
			var parentHeight = this._getMapParentHeight();
			var availableHorRegion = parseInt(parentHeight - mapElement.offsetTop);
			var pct = parseInt(h);

			h = (availableHorRegion * (pct / 100.0));

			if (!dojo.isWebKit) {
				h -= 1;
			}

			return h;
		},

		_getWidthInPixels: function(w)
		{
			if (w.substr(w.length - 1, 1) == '%')
			{
				var mapElement = dojo.byId(this.divId);
				var widthPercentageStr = w.substr(0, w.length - 1);
				var availableHorRegion = parseInt(dojo.window.getBox(dojo.doc).w - this._getMapOffsetLeft());
				var widthPercentage = parseInt(widthPercentageStr);
				var width = (availableHorRegion * (widthPercentage / 100.0));
				width -= 15;
				return parseInt(("" + width).match(/\d+/) || 0);//
			}
			else
			{
				return parseInt(("" + w).match(/\d+/) || 0);//
			}
		},

		getCurrentRecordSetControl: function()
		{
			return this.currentRecordSetControl;
		},
		destroyRecursive: function()
		{
			if (this.longDescriptionToolTip) {
				this.longDescriptionToolTip.destroyRecursive();
			}
			if (this.toolbarStartupHandle ) {
				dojo.unsubscribe(this.toolbarStartupHandle);
			}
			this.userSessionManager.onMapExit();
			if (this.markerRefresher)
			{
				this.markerRefresher.destroyRecursive();
				this.markerRefresher = null;
			}
			if (this.routeManager)
			{
				this.routeManager.destroyRecursive();
			}
			if (this.isProviderInitialized())
			{
				this.destroyMap();
			}
			if (this.maximo)
			{
				this.maximo.destroyRecursive();
			}
			if (this.geocoder)
			{
				this.geocoder.destroyRecursive();
			}
			if (this.currentRecordSetControl)
			{
				this.currentRecordSetControl.destroyRecursive();
			}
			if (this.currentRecordMgr)
			{
				this.currentRecordMgr.destroyRecursive();
			}
			if (this.contextMenu)
			{
				this.contextMenu.destroyRecursive();
			}
			if (this.maptips)
			{
				this.maptips.destroyRecursive();
			}
			if (this.toolbar)
			{
				this.toolbar.destroyRecursive();
			}
			if (this.fullScreenHelper)
			{
				this.fullScreenHelper.destroyRecursive();
			}
			if (this.layersManager)
			{
				this.layersManager.destroyRecursive();
			}
			if(this.dispatcher)
			{
				this.dispatcher.destroyRecursive();
			}

			// MAXIMOLBS-1606 - destroy handler of z-indexes
			if (this.mapZIndexHandler) {
				this.mapZIndexHandler.destroy();
			}

			this._isLayoutReady = null;
			this._providerOK = null;

			if (this.onNavListCollapseClick) {
				this.onNavListCollapseClick.remove();
			}

			if (this.resizeInterval) {
				clearInterval(this.resizeInterval);
			}

			if (this.scrollbarsObserver) {
				this.scrollbarsObserver.disconnect();
				this.scrollbarsObserver = null;
			}

			this.inherited(arguments);
		},
		destroyMap: function()
		{
			throw "To be implemented by provider";
		},
		// Defect 57860 - Reset the flag that indicates that full screen operations
		// were being executed
		_resetExecutingFullscreen: function()
		{
			this._executingFullScreen = false;
		},
		fullScreenOn: function()
		{
			// Defect 57860 - Turn on a flag stating that full screen operations
			// are being executed at the moment. This is so that pan events are not misinterpreted
			// by the MyLocation tool. This flag resets after 2s.
			this._executingFullScreen = true;
			setTimeout(dojo.hitch(this, this._resetExecutingFullscreen), 2000);
			this.fullScreenHelper.fullScreenModeOn();
			this.map.isFullScreen = true;
		},
		fullScreenOff: function()
		{
			// Defect 57860 - Turn on a flag stating that full screen operations
			// are being executed at the moment. This is so that pan events are not misinterpreted
			// by the MyLocation tool. This flag resets after 2s.
			this._executingFullScreen = true;
			setTimeout(dojo.hitch(this, this._resetExecutingFullscreen), 2000);
			this.fullScreenHelper.fullScreenModeOff();
			this.map.isFullScreen = false;
		},
		// Defect 57860 - Used by MyLocation tool. Only accept pan events
		// if there are no full screen operations being executed.
		isExecutingFullScreen: function()
		{
			return (this._executingFullScreen == true);
		},
		getWidthInPixels: function()
		{
			var w = this.width;
			if (!this.width)
			{
				w = '100%';
			}
			this.widthPx = this._getWidthInPixels(w);
			return this.widthPx;
		},
		getHeightInPixels: function()
		{
			return this.heightPx;
		},
		/**
		 * If we failed to retrieve user location. The possible errors are:<br>
		 * code 1 - Permission denied, user did not allow to share his location<br>
		 * code 2 - Position unavailable, the position of the device could not be
		 * determined<br>
		 * code 3 - Timeout, device took too long (longer than the timeout
		 * specified) to return current location<br>
		 * code 4 - Geolocation not supported, this device does not support
		 * geolocation, this is a custom error code<br>
		 *
		 * @see http://dev.w3.org/geo/api/spec-source.html#permission_denied_error
		 * @param error:
		 *            {code,message}
		 */
		failedToGetLocation: function()
		{
			var maximo = this.getMaximo();
			var myLocationInstance = ibm.tivoli.fwm.mxmap.geolocation.MyCurrentLocation.getMyCurrentLocationInstance();
			switch (myLocationInstance.getStatus())
			{
				case ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.PERMISSION_DENIED:
					maximo.showMessage("map", "curr_loc_perm_denied");
					break;
				case ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.TIMEOUT:
					maximo.showMessage("map", "curr_loc_timeout");
					break;
				case ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.POSITION_UNAVAILABLE:
					maximo.showMessage("map", "curr_loc_position_unavailable");
					break;
				case ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.GEOLOCATION_NOT_SUPPORTED:
					maximo.showMessage("map", "curr_loc_not_supported");
					break;
				default:
					maximo.showMessage("mapserver", "current_loc_failure", [ error.code ]);
			}
			;
		},
		failedToGetLocationStatusMessages: function()
		{
			var maximo = this.getMaximo();
			var myLocationInstance = ibm.tivoli.fwm.mxmap.geolocation.MyCurrentLocation.getMyCurrentLocationInstance();
			switch (myLocationInstance.getStatus())
			{
				case ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.PERMISSION_DENIED:
					maximo.showMessage("map", "curr_loc_perm_denied_statusmsg");
					break;
				case ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.TIMEOUT:
					maximo.showMessage("map", "curr_loc_timeout_statusmsg");
					break;
				case ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.POSITION_UNAVAILABLE:
					maximo.showMessage("map", "curr_loc_position_unavailable_statusmsg");
					break;
				case ibm.tivoli.fwm.mxmap.geolocation.GeoLocationStatus.GEOLOCATION_NOT_SUPPORTED:
					maximo.showMessage("map", "curr_loc_not_supported_statusmsg");
					break;
				default:
					maximo.showMessage("mapserver", "current_loc_failure", [ error.code ]);
			}
			;
		},
		getLayersManager: function()
		{
			return this.layersManager;
		},
		_checkMapLoadedCorrectly: function()
		{
			// this is to allow async map services loading to check for errors.
		},
		/* mboInfo:{mxdata,gisdata,autolocatedata,lbsdata} */
		handlerMapping: {
			"onMoveEnd": "dragend"
		},
		centerOnMbo: function(mboInfo, zoomlevel)
		{
			// Using the MXRecord wrapper to handle mboInfo's properties
			var mxRec = new MXRecord({
				mboInfo: mboInfo,
				map: this
			});

			var localgisdata = mxRec.getGISData();
			if (mxRec.getAutolocateMboInfo() != null)
			{
				localgisdata = mxRec.getAutolocateGISData();
			}
			if (dojo.config.fwm.debug == true)
			{
				console.log("Center on  ", mboInfo.mxdata.mboName, localgisdata.lat, localgisdata.lng);
				console.log("Is autolocated ", mboInfo.autolocate != null);
			}
			var point = this.latLng(localgisdata.lat, localgisdata.lng);

			// For GIS points and autolocate GIS points, the coordinate system
			// is expected to match the map's coordinate system. However, LBS
			// points are always in Web Mercator format so we need to run
			// the point through getAllPointsFromWGS84() before attempting to
			// display it.
			if (mxRec.useLBSData())
			{
				point = mxRec.getLBSPoint();
				point.sr = this.WGS84WKID;
				var auxFct = function(/* array of projected points */points)
				{
					this._centerOnPoint(points[0], zoomlevel);
				};
				this.getAllPointsFromWGS84([ point ], dojo.hitch(this, auxFct));
			}
			else
			{
				// Adding a null check to make sure that the marker is only drawn if the coordinates are not null.
				// The only possible scenario for this to happen is if the record is linked to a spatial feature class
				// and after that the user tries to see the the record on another map provider.
				// There is a MXRecord.hasAnyCoordinates() check before the code reaches here, but, if the record is
				// linked to a spatial feature class, that method will return true even if no GIS lat/lng exist for the Maximo record
				if(point.lat != null && point.lng != null)
				{
				this._centerOnPoint(point, zoomlevel);
			}
				else
				{
					console.warn("Cannot center on null lat/lng.");
				}
			}

		},
		_centerOnPoint: function(cp, zoomlevel)
		{

			if (zoomlevel)
			{
				this.setCenterAndZoom(cp, zoomlevel);
			}
			else
			{
				this.setCenter(cp);
			}

		},
		/*
		 * Removes the given MBO's highlight from the map, each provider implements your own method
		 */
		removeMboHighligh: function(mboInfo)
		{
			
		},
		/*
		 * Removes the given MBO's marker from the map
		 */
		removeMboMarker: function(mboInfo, layerId)
		{
			var info = this._getMboMarkerInfo(mboInfo, layerId);
			if (info != null)
			{
				if (!layerId)
				{
					this.removeMboFromLayerManager(mboInfo);
				}
				else
				{
					this.removeMboMarkerFromMap(mboInfo, layerId);
				}

			}
			else
			{
				console.warn("There was no marker for ", mboInfo);
			}
		},
		/*
		 * Removes the MBO from the map
		 */
		removeMboMarkerFromMap: function(mboInfo, layerId)
		{
			var info = this._getMboMarkerInfo(mboInfo, layerId);
			if (info != null)
			{
				console.log("[%% mxmap.Map.removeMboMarkerFromMap]", layerId, " mbo=" + mboInfo.mxdata.mboName + "," + mboInfo.mxdata.uid.value + " removing marker");

				// Before removing this marker from the map, remove all the references to this record from
				// other records that are at the same spot
				var remainingRecordsAtTheSpot = this.removeRecordsAtTheSameSpotReferences(mboInfo);
				mboInfo.isOnMap = info.isOnMap = false;
				this.removeMarker(info.marker);
				if (info.lbsCircle || info.lbsMarker)
				{
					this.removePolyline(info.lbsCircle);
					this.removeMarker(info.lbsMarker);
				}

				// If there are still 2 or more markers at the same spot as the removed marker,
				// update the multimarker records (maptip and tooltip)
				if(remainingRecordsAtTheSpot.length > 1)
				{
					this._updateMultiMarkerRecords(remainingRecordsAtTheSpot);
				}
				// If there is only one remaining record at the spot
				// multimarker is not needed anymore, remove it
				else if(remainingRecordsAtTheSpot.length == 1)
				{
					this._removeMultiMarker(remainingRecordsAtTheSpot[0]);
				}
				info = {};
			}
			else
			{
				console.warn("no marker for ", mboInfo);
			}
		},
		/*
		 * If the given MBO has been previously added to the map, show its marker
		 * using the stored marker options.
		 */
		showMboMarker: function(mboInfo, layerId)
		{
			var info = this._getMboMarkerInfo(mboInfo, layerId);
			if (info != null)
			{
				mboInfo.isOnMap = info.isOnMap = true;
				this.addMboMarker(mboInfo, info.markerOptions, layerId);
			}
		},
		/*
		 * Adds the MBO to its default layer (based on type).
		 */
		addMboToLayerManager: function(mboInfo, markerOptions)
		{
			this.layersManager.addRecord(mboInfo, markerOptions);
		},
		/*
		 * Removes the MBO from its default layer (based on type).
		 */
		removeMboFromLayerManager: function(mboInfo)
		{
			this.layersManager.removeRecord(mboInfo);
		},
		/*
		 * Adds a reference to the given MBO, and if this is the first reference
		 * also creates a marker for it using the given marker options.
		 */
		addMboMarker: function(mboInfo, options, layerId)
		{
			// Using the MXRecord wrapper to handle mboInfo's properties
			var mxRec = new MXRecord({
				mboInfo: mboInfo,
				map: this
			});

			var point = mxRec.getGISPoint();
			if (mxRec.getAutolocateMboInfo() != null)
			{
				point = mxRec.getAutolocateGISPoint();
			}

			// The converted coordinates may have already been calculated
			// by routing logic
			if(mxRec.hasPointInCurrentSR())
			{
				this._createMarker(mxRec, options, mxRec.getPointInCurrentSR(), layerId);
			}
			// For GIS points and autolocate GIS points, the coordinate system
			// is expected to match the map's coordinate system. However, LBS
			// points are always in Web Mercator format so we need to run
			// the point through getAllPointsFromWGS84() before attempting to
			// display it.
			else if (mxRec.useLBSData())
			{

				point = mxRec.getLBSPoint();
				// must be sure to convert the WGS point into the current coord
				// system
				point.sr = this.WGS84WKID;
				var succFct = function(pointInCurrentSR)
				{
					// Add the converted coorditates to a known variable in the mboInfo
					// regardless of provider, type of conversion, etc, so that the lat/lng point
					// can be retrieved from the layer records
					mxRec.setPointInCurrentSR(pointInCurrentSR[0]);
					this._createMarker(mxRec, options, pointInCurrentSR[0], layerId);
				};
				var errFct = function(err)
				{
					console.error("Error converting point to current SR", err);
				};

				this.getAllPointsFromWGS84([ point ], dojo.hitch(this, succFct), dojo.hitch(this, errFct));

			}
			else
			{
				// Add the coorditates to a known variable in the mboInfo
				// regardless of provider, type of conversion, etc, so that the lat/lng point
				// can be retrieved from the layer records
				mxRec.setPointInCurrentSR(point);
				// Adding a null check to make sure that the marker is only drawn if the coordinates are not null.
				// The only possible scenario for this to happen is if the record is linked to a spatial feature class
				// and after that the user tries to see the the record on another map provider.
				// There is a MXRecord.hasAnyCoordinates() check before the code reaches here, but, if the record is
				// linked to a spatial feature class, that method will return true even if no GIS lat/lng exist for the Maximo record
				if(point.lat != null && point.lng != null)
				{
					this._createMarker(mxRec, options, point, layerId);
				}
				else
				{
					console.warn("Cannot create marker when lat/lng is null.");
				}
			}

		},
		/*
		 * Creates a marker in the map for the given MBO, with the given marker
		 * options, in the given point.
		 */
		// Using the MXRecord wrapper to handle mboInfo's properties
		_createMarker: function(mxRecord, options, point, layerId)
		{	
			if (dojo.config.fwm.debug == true)
			{
				console.log("[Map._createMarker] Beginning");
			}

			var draggable = true;
			if (mxRecord.isGISDataReadOnly())
			{
				draggable = false;
			}
			else if (this.isMapViewOnly() == true)
			{
				draggable = false;
			}
			else if (options && options.draggable)
			{
				draggable = options.draggable;
			}

			if (mxRecord.useLBSData() && point.lat != null)
			{
				// When the record comes from the LBS table, it cannot be dragged
				draggable = false;
				var lbsData = mxRecord.getLBSData();
				var accuracyMarker = this._addLBSAccuracyMarker(lbsData, point);
				var circle = this._addLBSAccuracyCircle(lbsData, point);

				this._updateMboMarkerHash(mxRecord.getMboInfo(), {
					lbsMarker: accuracyMarker,
					lbsCircle: circle
				}, layerId);

			}
			var color = options ? options.color : this.getDefaultRouteColor();
			var symbol = this.getSymbologyManager().getLegendSymbolForObject(mxRecord.getMboInfo(), color);
			var icon = symbol.url;
			var tooltip = "";
			// Now the mouseover (tooltip) is part of the mboInfo received from the server
			if (this.isMobile != true)
			{
				tooltip = mxRecord.hasMouseover() ? mxRecord.getMouseover() : "";
			}

			var activityId = mxRecord.getActivityId();

			// Defect 67228 - See explanation in GmapsMarker (toProprietary method)
			var dontDrawAsOverlay = false;
			if (options && (options.dontDrawAsOverlay == true))
			{
				dontDrawAsOverlay = options.dontDrawAsOverlay;
			}

			var markerdata = {
				infoBubble: "FWMMAPTIPS",
				label: null,
				tooltip: tooltip,
				marker: 4,
				icon: icon,
				iconSize: [ symbol.width, symbol.height ],
				iconAnchor: [ symbol.offsetx, symbol.offsety ],
				draggable: draggable,
				hover: false,
				// Defect 67228 - See explanation in GmapsMarker (toProprietary method)
				dontDrawAsOverlay: dontDrawAsOverlay,
				activityId: activityId
			};
			if (options != null)
			{
				markerdata.label = options.label;
				markerdata.hover = options.hover;
			}

			var marker = this.addMarker(point, markerdata);
			// Add the marker to the mboInfo so that it can be retrieved by the multimarker logic
			// in case this mbo is at the same spot as another one. The multimarker logic needs
			// to retrieve the marker for all mbos at the same spot so that the openBubble callback function
			// of all these markers are bound to the maptip summary of the multimarker.
			mxRecord.setMarker(marker);
			if (options && options.events)
			{
				for ( var eventName in options.events)
				{
					var eventFtc = options.events[eventName];
					var markerEventName = this.handlerMapping[eventName];
					marker.addMarkerEventHandler(markerEventName, eventFtc);
				}
			}
			console.log("[mxmap.Map._createMarker] mbo=" + mxRecord.mboInfo.mxdata.mboName + "," + mxRecord.mboInfo.mxdata.uid.value + " creating marker");

			this.getMapTipsManager().enableMarker(marker, mxRecord.getMXData(), mxRecord.getMapTipOverrides());

			mxRecord.setIsOnMap(true);
			this._updateMboMarkerHash(mxRecord.getMboInfo(), {
				isOnMap: true,
				marker: marker,
				markerOptions: options
			}, layerId);
			if (options && options.markerReferenceCallback)
			{
				try
				{
					options.markerReferenceCallback(marker);
				}
				catch (e)
				{
					console.error("cannot call reference ftc", e);
				}
			}
			// Check if there are other markers at the same spot
			// This method below adds references to other records at the same spot in mboInfo and
			// it also adds references to this record in all other records at the same spot
			var recordsAtTheSameSpot = this.addRecordsAtTheSameSpotReferences(mxRecord.getMboInfo());
			if(recordsAtTheSameSpot.length > 1)
			{
				// If there are more than 2 markers at the same spot (i.e. the multimarker is already showing),
				// we need to remove the multimarker and add it again after we add the new marker
				// to force the multimarker to be always on top
				if(recordsAtTheSameSpot.length > 2)
				{
					this._removeMultiMarker(mxRecord.getMboInfo());
				}
				this._addMultiMarker(point, recordsAtTheSameSpot, options);
			}
		},
		/*
		 * Stores a reference for the given MBO with the given options. If a
		 * reference already exists, updates all of its properties with the given
		 * ones.
		 */
		_updateMboMarkerHash: function(mboInfo, opt, layerId)
		{
			return this.layersManager.setMboMarkerInfo(mboInfo, opt, layerId);
		},
		/*
		 * Returns the stored info for the given MBO.
		 */
		_getMboMarkerInfo: function(mboInfo, layerId)
		{
			return this.layersManager.getMboMarkerInfo(mboInfo, layerId);
		},
		/*
		 * Stores a reference for the multi marker of the given MBO with the given options. If a
		 * reference already exists, updates all of its properties with the given
		 * ones.
		 */
		_updateMultiMarkerHash: function(mboInfo, opt)
		{
			return this.layersManager.setMultiMarkerInfo(mboInfo, opt);
		},
		/*
		 * Returns the stored info for the multi marker of the given MBO.
		 */
		_getMultiMarkerInfo: function(mboInfo)
		{
			return this.layersManager.getMultiMarkerInfo(mboInfo);
		},
		/*
		 * Returns the stored info for the multi marker of the given MBO.
		 * This function uses the lat/lng in gisdata to retrieve the info 
		 * instead of the lat/lng in pointInCurrentSR.
		 */
		_getMultiMarkerInfoUsingGisData: function(mbo)
		{
			return this.layersManager.getMultiMarkerInfoUsingGisData(mbo);
		},
		/**
		 * in order to place several markers at once, can improve performance by
		 * using this method
		 */
		showAllMboRecords: function(mboInfoArray, options, zoom)
		{
			if (!mboInfoArray || mboInfoArray.length == 0)
			{
				return;
			}
			for ( var index in mboInfoArray)
			{
				// Using the MXRecord wrapper to handle mboInfo's properties
				var mxRec = new MXRecord({
					mboInfo: mboInfoArray[index],
					map: this
				});

				// Fix the issue where records with no lat/lng were displayed in 0/0
				if(mxRec.hasAnyCoordinates())
				{
					this.addMboToLayerManager(mxRec.getMboInfo());
				}
			}
			if (zoom == true)
			{
				this.zoomToMbos(mboInfoArray);
			}

		},
		/**
		 * Forces zoom to cover all the current records on the map.
		 */
		zoomToMbos: function(mboInfoArray)
		{
			if (!mboInfoArray || mboInfoArray.length == 0)
			{
				return;
			}
			if (mboInfoArray && mboInfoArray.length == 1)
			{
				this.centerOnMbo(mboInfoArray[0]);
			}
			else
			{
				this.autoCenterAndZoom(mboInfoArray);
			}
		},
		_addLBSAccuracyCircle: function(lbsdata, point)
		{
			console.log("LBS", lbsdata, lbsdata.max_accuracy_state);
			if ("EXCEEDED_TOLERANCE" !== lbsdata.max_accuracy_state)
			{
				var circle = this.radius(point, 10);
				var radiusInKms = (lbsdata.location_accuracy / 1000);
				var lbsCircle = circle.getPolyline(radiusInKms, lbsdata.circle_border_color);
				var borderOpacity = null;
				if (lbsdata.is_weather_alert_impact) {
					borderOpacity = lbsdata.circle_opacity;
				}
				this.addPolyline(lbsCircle, {
					centerPoint: point,
					width: lbsdata.circle_border_width,
					opacity: lbsdata.circle_opacity,
					fillColor: lbsdata.circle_fill_color,
					borderOpacity: borderOpacity,
					closed: true,
					radiusInKMs: radiusInKms
				});
			}
			else
			{
				console.log("accuracy exceeded tolerance");
			}
			return lbsCircle;
		},
		_addLBSAccuracyMarker: function(lbsdata, point)
		{
			var accuracyMarkerInfo = ImageLibraryManager.getImageLibraryManager().getLBSMarkerImageInfo(lbsdata);
			var markerdata2 = {
				infoBubble: "",
				label: null,// nothing specified in spec.
				marker: 4,
				icon: accuracyMarkerInfo.getImageURL(),
				iconSize: accuracyMarkerInfo.getImageSize(),
				iconAnchor: accuracyMarkerInfo.getImageAnchor(),
				draggable: false,
				hover: false,
				// Defect 67228 - See explanation in GmapsMarker (toProprietary method)
				dontDrawAsOverlay: true
			};
			return this.addMarker(point, markerdata2);
		},
		enableTraffic: function()
		{
			this.setShowTraffic(true);
		},
		disableTraffic: function()
		{
			this.setShowTraffic(false);
		},
		enableRoutes: function()
		{
			if (this.getMultipleRoutesManager())
			{
				this.getMultipleRoutesManager().showRoutesLinesAndCalculatedMarkers();
			}
		},
		disableRoutes: function()
		{
			this.getMultipleRoutesManager().hideRoutesLinesAndCalculatedMarkers();
		},
		disableActions: function()
		{
			this._actionsAreEnabled = false;
		},

		enableActions: function()
		{
			this._actionsAreEnabled = true;
		},
		isMapViewOnly: function()
		{
			var confs = this.mapConf.inputConfs;
			if (confs != null && confs.mapviewonly != null)
			{
				return confs.mapviewonly == "1" || confs.mapviewonly == "true";
			}
			// map default is read only
			return true;
		},
		allowsTrafficLayer: function()
		{
			return true;
		},
		getDefaultLengthUnit: function()
		{
			return this.mapConf.lengthunit;
		},
		/**
		 * when map is ina section and it just got expanded we force map to refresh
		 * its data.
		 */
		_mapSectionExpanded: function()
		{
			this.enableActions();
			var showdirectionsonload = false;
			if (this.routeConf && this.routeConf.showdirectionsonload == true)
			{
				showdirectionsonload = true;
			}
			// this.refreshRoute(true, showdirectionsonload);
			// Issue 12-13542. The line below shouldn't have been commented out.
			this._resize();
			var refreshOptions = {
					zoom: true,
					disableMsgs: false,
					automatic: false
				};
			this.refreshMap(refreshOptions);
			if (this._sectionExpanded == false)
			{
				this.centerAndZoomMap();
				this._sectionExpanded = true;
			}
			this._showConfErrors();
		},
		_showConfErrors: function() {
			if (this.mapConf.error) {
				this.maximo.showMessage(this.mapConf.error.group, this.mapConf.error.key, [this.mapConf.error.params]);
			}
		},	
		_showRouteConfErrors: function() {
			if (this.routeConf && this.routeConf.error) {
				this.maximo.showMessage(this.routeConf.error.group, this.routeConf.error.key, [this.routeConf.error.params]);
			}
		},
		getInitialLocationCustomInfo: function()
		{
			return {};
		},
		autoRefreshMap: function()
		{
			var refreshOptions = {
				zoom: false,
				disableMsgs: true,
				automatic: true
			};
			this.refreshMap(refreshOptions);
		},
		_getMapOffsetLeft: function()
		{
			var mapDiv = dojo.byId(this.divId);
			return mapDiv.offsetLeft;
		},
		_getMapOffsetTop: function()
		{
			var mapDiv = dojo.byId(this.divId);
			return mapDiv.offsetTop;
		},
		createRouteLayer: function()
		{
			if(this.layersManager.getLayerById("route") == null)
			{
				var routeLayerOptions = {
						layerName: ibm.tivoli.fwm.i18n.getMaxMsg("map", "routelayer"),// "Route";
						layerId: "route",
						map: this
					};
				var RouteLayerClass = dojo.require("ibm.tivoli.fwm.mxmap.layers.RouteLayer");
				var routeLayer = new RouteLayerClass(routeLayerOptions);
				this.layersManager.addLayer(routeLayer, false);
			}
		},
		// This method returns the lat/lng point from a known mboInfo property
		// because the lat/lng info can be scattered across the mboInfo object
		// in different places depending on "autolocate", if it is spatial, etc...
		getLatLngFromMboInfo: function(mboInfo)
		{
			var point = null;
			if(mboInfo.pointInCurrentSR)
			{
				point = this.latLng(mboInfo.pointInCurrentSR.lat, mboInfo.pointInCurrentSR.lng);
			}
			return point;
		},
		addRecordsAtTheSameSpotReferences: function (newMboInfo)
		{
			return this.layersManager.addRecordsAtTheSameSpotReferences(newMboInfo);
		},
		removeRecordsAtTheSameSpotReferences: function(mboInfoToBeRemoved)
		{
			return this.layersManager.removeRecordsAtTheSameSpotReferences(mboInfoToBeRemoved);
		},
		_addMultiMarker: function(point, recordsAtTheSameSpot, options)
		{
			// Multimarker info
			var multiMarkerImgInfo = ImageLibraryManager.getImageLibraryManager().getMultiMarkerImageInfo();

			var multiMarkerTooltip = this._getMultiMarkerMouseover(recordsAtTheSameSpot);

			var multiMarkerData = {
					infoBubble: "FWMMAPTIPS",
					label: null,
					tooltip: multiMarkerTooltip,
					icon: multiMarkerImgInfo.imageUrl,
					iconSize: multiMarkerImgInfo.imageSize,
					iconAnchor: multiMarkerImgInfo.imageAnchor,
					draggable: false,
					hover: false,
					isMultiMarker: true,
					// IV96441: GOOGLE MAPS NOT SHOWING ALL WORKORDERS
					// See explanation in GMapsMarker.js, toProprietary function
					dontDrawAsOverlay: false
				};
			// Add the multimarker
			var multiMarker = this.addMarker(point, multiMarkerData);
			// It doesn't matter which of the records is used to update the hash
			// because the hash key is the lat/lon (which is the same for all records).
			this._updateMultiMarkerHash(recordsAtTheSameSpot[0],{
					marker: multiMarker,
					markerOptions: options
				});
			this.getMapTipsManager().enableMultiMarker(multiMarker, recordsAtTheSameSpot);
		},
		_removeMultiMarker: function(mboInfo)
		{
			var multiMarkerInfo = this._getMultiMarkerInfo(mboInfo);
			if(multiMarkerInfo != null)
			{
				this.removeMarker(multiMarkerInfo.marker);
				multiMarkerInfo = {};
			}
		},
		_updateMultiMarkerRecords: function(recordsAtTheSameSpot)
		{
			// It doesn't matter which of the records is used to retrieve the mboInfo from the hash table
			// because the hash key is the lat/lon (which is the same for all records).
			var multiMarkerInfo = this._getMultiMarkerInfo(recordsAtTheSameSpot[0]);
			this.getMapTipsManager().updateMultiMarkerOpenBubbleHandler(multiMarkerInfo.marker, recordsAtTheSameSpot);
			var mouseover = this._getMultiMarkerMouseover(recordsAtTheSameSpot);
			multiMarkerInfo.marker.setTooltip(mouseover);
		},
		_getMultiMarkerMouseover: function(recordsAtTheSameSpot)
		{
			var multiMarkerTooltip = "";
			// Stacking the mouseover data from all markers within this multimarker
			// Tooltip does not make sense for mobile devices
			if(this.isMobile != true)
			{
				var horizontalLineTag = "<hr>";
				// Remember, it is no use adding "max-" and "min-" style properties in IE... what a shame.
				if(dojo.isIE)
				{
					horizontalLineTag = "<hr style=\"width=200px\">";
				}

				for(var i=0; i<recordsAtTheSameSpot.length; i++)
				{
					multiMarkerTooltip += ((recordsAtTheSameSpot[i].mouseover != null) && (recordsAtTheSameSpot[i].mouseover != undefined)) ? recordsAtTheSameSpot[i].mouseover : "";
					if(i < (recordsAtTheSameSpot.length - 1))
					{
						multiMarkerTooltip += horizontalLineTag;
					}
				}
			}
			return multiMarkerTooltip;
		},
		getDefaultRouteColor: function()
		{
			return this.defaultRouteColor;
		},
		getDispatcher: function()
		{
			return this.dispatcher;
		},
		setDispatcher: function(dispatcher)
		{
			this.dispatcher = dispatcher;
		},
		showWarningMessage: function(msgGroup, msgKey, params) {
			 this.getMaximo().showMessage(msgGroup, msgKey, params);
		},
		showWarning: function(warningCode)
		{
			var maximo = this.getMaximo();
			switch (warningCode)
			{
				case ibm.tivoli.fwm.mxmap.WarningCodes.NO_LBS_LOCATION_FOUND:
					if (this.mapConf.provider != "spatial") {
						maximo.showMessage("mapcontrol", "nogeolocationfound");
					}
					break;
				default:
					break;
			}
		},

		/**
		 * Returns whether or not the markers should be drawn even when the provider fails to generate a route
		 */
		getShowMarkersOnRouteError: function()
		{
			var showMarkersOnRouteError = false;
			var mapConf = this.mapConf;
			if((mapConf != null) && (mapConf!= undefined) && (mapConf.showMarkersOnRouteError != null) && (mapConf.showMarkersOnRouteError != undefined))
			{
				if(mapConf.showMarkersOnRouteError > 0)
				{
					showMarkersOnRouteError = true;
				}
			}
			return showMarkersOnRouteError;
		},
		/**
		 * Get the label configuration from the symbology manager
		 * @return the label configuration from the Map Manager symbology
		 */
		getLabelConfs: function() {
			var labelConfs;
			var symbologyLayerId = this.mapConf.currentMbo.mxdata.mboName.toLowerCase();
			var layerSymbologyConfig = this.symbologyManager.getLayerConfigById(symbologyLayerId);
			labelConfs = (layerSymbologyConfig) ? layerSymbologyConfig.mapLabelsStyle : null;
			return labelConfs;
		},
		
		/**
		 * Create the labels on the map
		 * Can be of type "address" or "attributes"
		 */
		createMapLabel: function(labelType) {
			var label;

			if ( labelType == "address" && !this.addressLabel) {
				label = domConstruct.create("span", {
					id: "mapAddresslabel"
				});
				this.addressLabel = label;
				domConstruct.place( label, this.element, "last" );
				
			} else if ("attributes" && !this.mboAttributesLabel) {
				label = domConstruct.create("span", {
					id: "mapAttributeslabel"
				});	
				this.mboAttributesLabel = label;
				domConstruct.place( label, this.element, "first" );
			}
			

			try {
					
				this.setLabelStyle(label, this.labelConfs, labelType);
					
			} catch (e) {
				if ((this.mapConf.provider == "spatial") && (this.messageDiv)) {
					this.writeMessageInBox( this.messageDiv, "map", "errorInMapLabelParams", [], true );
				} else {
					console.error(ibm.tivoli.fwm.i18n.getMaxMsg( "map", "errorInMapLabelParams" ));
				}
			}
				
			this.setLabelProviderClass(labelType);
				
		},
		setLabelStyle: function( label, labelStyleConf, labelType) {
			if (labelStyleConf) {
				domStyle.set(label,"color", "rgb("+labelStyleConf.fontColor+")" );
				domStyle.set(label,"font-size", labelStyleConf.fontSize );
				domStyle.set(label,"max-width", labelStyleConf.labelLength );
					
				var backgroundColor = "rgb("+ labelStyleConf.backgroundColor + "," + labelStyleConf.backgroundTransparency +")" ;
				domStyle.set(label,"background-color", backgroundColor );
				if (labelType == "attributes") {
					if (labelStyleConf.attributesLabel && labelStyleConf.attributesLabel.left) {
						domStyle.set(label,"left", labelStyleConf.attributesLabel.left);
					}
					if (labelStyleConf.attributesLabel && labelStyleConf.attributesLabel.top) {
						domStyle.set(label,"top", labelStyleConf.attributesLabel.top);
					}
				}
			}
		},
		/**
		 * Updates the Address label
		 * @param address the new address to be displayed
		 */
		updateMapAddressLabel: function(address) {
			if (!this.addressLabel) {
				this.createMapLabel("address");
			}
			
			if (this.addressLabel.textContent != address) {
				this.addressLabel.textContent = address;
			}
			domStyle.set(this.addressLabel,"display", "inline" );
		}, 
		/**
		 * Set the css class for the address label based on the provider
		 */
		setLabelProviderClass: function(labelType) {
			
			var providerClasses;
			if (labelType == "address") {
				
				providerClasses = {
						"spatial": "spatialMapAddressLabel",
						"gmaps" : "gMapAddressLabel",
						"bingmaps":"bMapAddressLabel"
				};
				domClass.add(this.addressLabel, providerClasses[this.mapConf.provider]);
				
			} else if (labelType == "attributes") {
				
				providerClasses = {
						"spatial": "spatialAttributesLabel",
						"gmaps" : "gMapAttributesLabel",
						"bingmaps":"bMapAttributesLabel"
				};
				domClass.add(this.mboAttributesLabel, providerClasses[this.mapConf.provider]);
			}
		}, 
		/**
		 * Hide the Address label
		 */
		hideMapAddressLabel: function() {
			if (this.addressLabel) {
				this.addressLabel.content = null;
				domStyle.set(this.addressLabel,"display", "none" );
			}
		},
		/**
		 * Update the content of the mbo attributes label
		 */
		updateMboAttributesLabelContent: function(mxdata) {
			var attributes;
			var invalidAttribute = false;
			if (mxdata) {
				attributes = mxdata.attributes;
			} else {
				attributes = this.mapConf.currentMbo.mxdata.attributes;
			}
			var attributesNameArray = this.labelConfs != null ? this.labelConfs.labelAttributes.split(",") : [];
			var textContent = "";
			dojo.forEach(attributesNameArray, function(attributeName, i) {
				var trimmedAttributeName = attributeName.trim();
				if (attributes.hasOwnProperty(trimmedAttributeName)) {
					var newContent = attributes[trimmedAttributeName] || "";
					if ( (i > 0) && !(newContent == "")) {
						textContent = textContent + " - ";
					}
					textContent = textContent + newContent;
				} else {
					invalidAttribute = true;
				}
				
			}, this);
			if (invalidAttribute) {
				this.mboAttributesLabel.textContent = "INVALID BINDING"
			} else if (this.mboAttributesLabel.textContent != textContent) {
				this.mboAttributesLabel.textContent = textContent;
			}
		},
		updateLongDescToolTip: function(mxdata) {
			if (mxdata && mxdata.attributes) {
				var longDescription = mxdata.attributes.longDescription;
				this.longDescriptionToolTip.label = longDescription;
			}
			
		},

		_getMapParentHeight: function() {
			if (this.mapConf.isOpenMap) {
				return dojo.window.getBox(dojo.doc).h;
			}

			return dojo.byId(this.MAP_TAB_PARENT_ID).offsetHeight;
		},

		_getIsLayoutReady: function() {
			if (this._isLayoutReady) {
				return this._isLayoutReady;
			}

			var isTabGroupDefined = this.mapConf && this.mapConf.tabGroupId;
			var isUsingOverlay = this.skinVersion === 'mas8';
			if (isUsingOverlay && isTabGroupDefined) {
				return this._isLayoutReady = dojo.byId(this.mapConf.tabGroupId).style.paddingTop === '3rem';
			}

			return this._isLayoutReady = true;
		},

		_startToolbar: function() {
			var mapElement = dojo.byId(this.divId);
			dojo.style(mapElement, "height", (this.heightPx - this.toolbar.getToolbarHeight()) + "px");

			this.toolbar.startup();
		},

		_createScroolbarsObserver: function() {
			var scrollbars = this._getScrollbars();
			if (!scrollbars.length) {
				return;
			}

			if (!this.scrollbarsObserver) {
				this.scrollbarsObserver = new MutationObserver(dojo.hitch(this, this._onScrollbarChanged));
			}

			dojo.forEach(scrollbars, dojo.hitch(this, function(scrollbar) {
				this.scrollbarsObserver.observe(scrollbar, { attributes: true });
			}));
		},

		_onScrollbarChanged: function() {
			if (this.map && this.map.isFullScreen) {
				return;
			}
			
			var scroller = dojo.query('.custom-scroller', this.MAP_TAB_PARENT_ID)[0];
			if (scroller) {
				var firstChild = scroller.children[0];
				if (firstChild) {
					dojo.style(firstChild, {
						'margin-inline-end': '0px',
						'margin-bottom': '0px'
					});
				}
			}
			
			this._resize();
			this._hideScrollbars();
		},

		_getScrollbars: function() {
			return dojo.query('.custom-scroller-track', this.MAP_TAB_PARENT_ID);
		},

		_hideScrollbars: function() {
			var scrollbars = this._getScrollbars();
			if (scrollbars) {
				dojo.forEach(scrollbars, dojo.hitch(this, function(scrollbar) {
					dojo.style(scrollbar, 'display', 'none');
				}));
			}
		},

		isMapGraphite: function() {
			return false;
		},

		inFullScreen: function() {
			if (!this.map) {
				return false;
			}

			return this.map.inFuisFullScreen;
		},

	});
});

},
'dojo/window':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["./_base/lang", "./sniff", "./_base/window", "./dom", "./dom-geometry", "./dom-style", "./dom-construct"],
	function(lang, has, baseWindow, dom, geom, style, domConstruct){

	// feature detection
	/* not needed but included here for future reference
	has.add("rtl-innerVerticalScrollBar-on-left", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'hidden', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', width:'64px', height:'64px'}
			}, body, "last"),
			center = domConstruct.create('center', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			inner = domConstruct.create('div', {
				style: {overflow:'visible', display:'inline' }
			}, center, "last");
		inner.innerHTML="&nbsp;";
		var midPoint = Math.max(inner.offsetLeft, geom.position(inner).x);
		var ret = midPoint >= 32;
		center.removeChild(inner);
		scrollable.removeChild(center);
		body.removeChild(scrollable);
		return ret;
	});
	*/
	has.add("rtl-adjust-position-for-verticalScrollBar", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'visible', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', top:'0', width:'64px', height:'64px'}
			}, body, "last"),
			div = domConstruct.create('div', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			ret = geom.position(div).x != 0;
		scrollable.removeChild(div);
		body.removeChild(scrollable);
		return ret;
	});

	has.add("position-fixed-support", function(win, doc){
		// IE6, IE7+quirks, and some older mobile browsers don't support position:fixed
		var	body = baseWindow.body(doc),
			outer = domConstruct.create('span', {
				style: {visibility:'hidden', position:'fixed', left:'1px', top:'1px'}
			}, body, "last"),
			inner = domConstruct.create('span', {
				style: {position:'fixed', left:'0', top:'0'}
			}, outer, "last"),
			ret = geom.position(inner).x != geom.position(outer).x;
		outer.removeChild(inner);
		body.removeChild(outer);
		return ret;
	});

	// module:
	//		dojo/window

	var window = {
		// summary:
		//		TODOC

		getBox: function(/*Document?*/ doc){
			// summary:
			//		Returns the dimensions and scroll position of the viewable area of a browser window

			doc = doc || baseWindow.doc;

			var
				scrollRoot = (doc.compatMode == 'BackCompat') ? baseWindow.body(doc) : doc.documentElement,
				// get scroll position
				scroll = geom.docScroll(doc), // scrollRoot.scrollTop/Left should work
				w, h;

			if(has("touch")){ // if(scrollbars not supported)
				var uiWindow = window.get(doc);   // use UI window, not dojo.global window
				// on mobile, scrollRoot.clientHeight <= uiWindow.innerHeight <= scrollRoot.offsetHeight, return uiWindow.innerHeight
				w = uiWindow.innerWidth || scrollRoot.clientWidth; // || scrollRoot.clientXXX probably never evaluated
				h = uiWindow.innerHeight || scrollRoot.clientHeight;
			}else{
				// on desktops, scrollRoot.clientHeight <= scrollRoot.offsetHeight <= uiWindow.innerHeight, return scrollRoot.clientHeight
				// uiWindow.innerWidth/Height includes the scrollbar and cannot be used
				w = scrollRoot.clientWidth;
				h = scrollRoot.clientHeight;
			}
			return {
				l: scroll.x,
				t: scroll.y,
				w: w,
				h: h
			};
		},

		get: function(/*Document*/ doc){
			// summary:
			//		Get window object associated with document doc.
			// doc:
			//		The document to get the associated window for.

			// In some IE versions (at least 6.0), document.parentWindow does not return a
			// reference to the real window object (maybe a copy), so we must fix it as well
			// We use IE specific execScript to attach the real window reference to
			// document._parentWindow for later use
			if(has("ie") && window !== document.parentWindow){
				/*
				In IE 6, only the variable "window" can be used to connect events (others
				may be only copies).
				*/
				doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
				//to prevent memory leak, unset it after use
				//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
				var win = doc._parentWindow;
				doc._parentWindow = null;
				return win;	//	Window
			}

			return doc.parentWindow || doc.defaultView;	//	Window
		},

		scrollIntoView: function(/*DomNode*/ node, /*Object?*/ pos){
			// summary:
			//		Scroll the passed node into view using minimal movement, if it is not already.

			// Don't rely on node.scrollIntoView working just because the function is there since
			// it forces the node to the page's bottom or top (and left or right in IE) without consideration for the minimal movement.
			// WebKit's node.scrollIntoViewIfNeeded doesn't work either for inner scrollbars in right-to-left mode
			// and when there's a fixed position scrollable element

			try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
				node = dom.byId(node);
				var	doc = node.ownerDocument || baseWindow.doc,	// TODO: why baseWindow.doc?  Isn't node.ownerDocument always defined?
					body = baseWindow.body(doc),
					html = doc.documentElement || body.parentNode,
					isIE = has("ie") || has("trident"),
					isWK = has("webkit");
				// if an untested browser, then use the native method
				if(node == body || node == html){ return; }
				if(!(has("mozilla") || isIE || isWK || has("opera") || has("trident") || has("edge"))
						&& ("scrollIntoView" in node)){
					node.scrollIntoView(false); // short-circuit to native if possible
					return;
				}
				var	backCompat = doc.compatMode == 'BackCompat',
					rootWidth = Math.min(body.clientWidth || html.clientWidth, html.clientWidth || body.clientWidth),
					rootHeight = Math.min(body.clientHeight || html.clientHeight, html.clientHeight || body.clientHeight),
					scrollRoot = (isWK || backCompat) ? body : html,
					nodePos = pos || geom.position(node),
					el = node.parentNode,
					isFixed = function(el){
						return (isIE <= 6 || (isIE == 7 && backCompat))
							? false
							: (has("position-fixed-support") && (style.get(el, 'position').toLowerCase() == "fixed"));
					},
					self = this,
					scrollElementBy = function(el, x, y){
						if(el.tagName == "BODY" || el.tagName == "HTML"){
							self.get(el.ownerDocument).scrollBy(x, y);
						}else{
							x && (el.scrollLeft += x);
							y && (el.scrollTop += y);
						}
					};
				if(isFixed(node)){ return; } // nothing to do
				while(el){
					if(el == body){ el = scrollRoot; }
					var	elPos = geom.position(el),
						fixedPos = isFixed(el),
						rtl = style.getComputedStyle(el).direction.toLowerCase() == "rtl";

					if(el == scrollRoot){
						elPos.w = rootWidth; elPos.h = rootHeight;
						if(scrollRoot == html && (isIE || has("trident")) && rtl){
							elPos.x += scrollRoot.offsetWidth-elPos.w;// IE workaround where scrollbar causes negative x
						}
						elPos.x = 0;
						elPos.y = 0;
					}else{
						var pb = geom.getPadBorderExtents(el);
						elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
						var clientSize = el.clientWidth,
							scrollBarSize = elPos.w - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							if(rtl && has("rtl-adjust-position-for-verticalScrollBar")){
								elPos.x += scrollBarSize;
							}
							elPos.w = clientSize;
						}
						clientSize = el.clientHeight;
						scrollBarSize = elPos.h - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							elPos.h = clientSize;
						}
					}
					if(fixedPos){ // bounded by viewport, not parents
						if(elPos.y < 0){
							elPos.h += elPos.y; elPos.y = 0;
						}
						if(elPos.x < 0){
							elPos.w += elPos.x; elPos.x = 0;
						}
						if(elPos.y + elPos.h > rootHeight){
							elPos.h = rootHeight - elPos.y;
						}
						if(elPos.x + elPos.w > rootWidth){
							elPos.w = rootWidth - elPos.x;
						}
					}
					// calculate overflow in all 4 directions
					var	l = nodePos.x - elPos.x, // beyond left: < 0
//						t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
						t = nodePos.y - elPos.y, // beyond top: < 0
						r = l + nodePos.w - elPos.w, // beyond right: > 0
						bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
					var s, old;
					if(r * l > 0 && (!!el.scrollLeft || el == scrollRoot || el.scrollWidth > el.offsetHeight)){
						s = Math[l < 0? "max" : "min"](l, r);
						if(rtl && ((isIE == 8 && !backCompat) || has("trident") >= 5)){ s = -s; }
						old = el.scrollLeft;
						scrollElementBy(el, s, 0);
						s = el.scrollLeft - old;
						nodePos.x -= s;
					}
					if(bot * t > 0 && (!!el.scrollTop || el == scrollRoot || el.scrollHeight > el.offsetHeight)){
						s = Math.ceil(Math[t < 0? "max" : "min"](t, bot));
						old = el.scrollTop;
						scrollElementBy(el, 0, s);
						s = el.scrollTop - old;
						nodePos.y -= s;
					}
					el = (el != scrollRoot) && !fixedPos && el.parentNode;
				}
			}catch(error){
				console.error('scrollIntoView: ' + error);
				node.scrollIntoView(false);
			}
		}
	};

	 1  && lang.setObject("dojo.window", window);

	return window;
});

},
'dijit/_FocusMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"./focus",
	"./_WidgetBase",
	"dojo/_base/declare", // declare
	"dojo/_base/lang" // lang.extend
], function(focus, _WidgetBase, declare, lang){

	// module:
	//		dijit/_FocusMixin

	// We don't know where _FocusMixin will occur in the inheritance chain, but we need the _onFocus()/_onBlur() below
	// to be last in the inheritance chain, so mixin to _WidgetBase.
	lang.extend(_WidgetBase, {
		// focused: [readonly] Boolean
		//		This widget or a widget it contains has focus, or is "active" because
		//		it was recently clicked.
		focused: false,

		onFocus: function(){
			// summary:
			//		Called when the widget becomes "active" because
			//		it or a widget inside of it either has focus, or has recently
			//		been clicked.
			// tags:
			//		callback
		},

		onBlur: function(){
			// summary:
			//		Called when the widget stops being "active" because
			//		focus moved to something outside of it, or the user
			//		clicked somewhere outside of it, or the widget was
			//		hidden.
			// tags:
			//		callback
		},

		_onFocus: function(){
			// summary:
			//		This is where widgets do processing for when they are active,
			//		such as changing CSS classes.  See onFocus() for more details.
			// tags:
			//		protected
			this.onFocus();
		},

		_onBlur: function(){
			// summary:
			//		This is where widgets do processing for when they stop being active,
			//		such as changing CSS classes.  See onBlur() for more details.
			// tags:
			//		protected
			this.onBlur();
		}
	});

	return declare("dijit._FocusMixin", null, {
		// summary:
		//		Mixin to widget to provide _onFocus() and _onBlur() methods that
		//		fire when a widget or its descendants get/lose focus

		// flag that I want _onFocus()/_onBlur() notifications from focus manager
		_focusManager: focus
	});

});

},
'dijit/_WidgetsInTemplateMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // forEach()
	"dojo/aspect", // after()
	"dojo/_base/declare", // declare()
	"dojo/_base/lang",	// hitch()
	"dojo/parser" // parse()
], function(array, aspect, declare, lang, parser){

	// module:
	//		dijit/_WidgetsInTemplateMixin

	return declare("dijit._WidgetsInTemplateMixin", null, {
		// summary:
		//		Mixin to supplement _TemplatedMixin when template contains widgets

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

		// contextRequire: Function
		//		Used to provide a context require to the dojo/parser in order to be
		//		able to use relative MIDs (e.g. `./Widget`) in the widget's template.
		contextRequire: null,

		_beforeFillContent: function(){
			// Short circuit the parser when the template doesn't contain any widgets.  Note that checking against
			// this.templateString is insufficient because the data-dojo-type=... may appear through a substitution
			// variable, like in ConfirmDialog, where the widget is hidden inside of the ${!actionBarTemplate}.
			if(/dojoType|data-dojo-type/i.test(this.domNode.innerHTML)){
				// Before copying over content, instantiate widgets in template
				var node = this.domNode;

				if(this.containerNode && !this.searchContainerNode){
					// Tell parse call below not to look for widgets inside of this.containerNode
					this.containerNode.stopParser = true;
				}

				parser.parse(node, {
					noStart: !this._earlyTemplatedStartup,
					template: true,
					inherited: {dir: this.dir, lang: this.lang, textDir: this.textDir},
					propsThis: this,	// so data-dojo-props of widgets in the template can reference "this" to refer to me
					contextRequire: this.contextRequire,
					scope: "dojo"	// even in multi-version mode templates use dojoType/data-dojo-type
				}).then(lang.hitch(this, function(widgets){
					this._startupWidgets = widgets;

					// _WidgetBase::destroy() will destroy any supporting widgets under this.domNode.
					// If we wanted to, we could call this.own() on anything in this._startupWidgets that was moved outside
					// of this.domNode (like Dialog, which is moved to <body>).

					// Hook up attach points and events for nodes that were converted to widgets
					for(var i = 0; i < widgets.length; i++){
						this._processTemplateNode(widgets[i], function(n,p){
							// callback to get a property of a widget
							return n[p];
						}, function(widget, type, callback){
							// callback to do data-dojo-attach-event to a widget
							if(type in widget){
								// back-compat, remove for 2.0
								return widget.connect(widget, type, callback);
							}else{
								// 1.x may never hit this branch, but it's the default for 2.0
								return widget.on(type, callback, true);
							}
						});
					}

					// Cleanup flag set above, just in case
					if(this.containerNode && this.containerNode.stopParser){
						delete this.containerNode.stopParser;
					}
				}));

				if(!this._startupWidgets){
					throw new Error(this.declaredClass + ": parser returned unfilled promise (probably waiting for module auto-load), " +
						"unsupported by _WidgetsInTemplateMixin.   Must pre-load all supporting widgets before instantiation.");
				}
			}
		},

		_processTemplateNode: function(/*DOMNode|Widget*/ baseNode, getAttrFunc, attachFunc){
			// Override _AttachMixin._processNode to skip DOMNodes with data-dojo-type set.   They are handled separately
			// in the _beforeFillContent() code above.

			if(getAttrFunc(baseNode, "dojoType") || getAttrFunc(baseNode, "data-dojo-type")){
				return true;
			}

			return this.inherited(arguments);
		},

		startup: function(){
			array.forEach(this._startupWidgets, function(w){
				if(w && !w._started && w.startup){
					w.startup();
				}
			});
			this._startupWidgets = null;
			this.inherited(arguments);
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/MarkerImageInfo':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

/**
 * Holds information for a Marker Image.
 * 
 * Constructor params:
 * 
 * ibm.tivoli.fwm.mxmap.MarkerImageInfo({
 * 											imageUrl: string (required), 
 * 											imageSize: [Integer, Integer] (optional), 
 * 											imageAnchor: [Integer] (optional)
 * 										})
 */

define(["dojo/_base/declare"],
	 function(declare) {
	
	return declare(null, {
		_imageSize: null,
		_imageAnchor: null,
		_imageURL: null,
		constructor : function(options) {
			dojo.mixin(this, options);		
			this._imageSize = options.imageSize || [32,32];
			this._imageAnchor = options.imageAnchor || [0,32];
			this._imageURL = options.imageUrl || "";
		},
		getImageSize: function()
		{
			return this._imageSize;
		},
		getImageAnchor: function()
		{
			return this._imageAnchor;
		},
		getImageURL: function()
		{
			return this._imageURL;
		},
		getSymbolURL: function()
		{
			return this._imageURL;
		},
		setImageURL: function(newURL)
		{
			this._imageURL = newURL;
		},
		generateMarkerData:function(label,draggable,hover){
			return {
			label : label,
			draggable : true==draggable,
			icon : this.getImageURL(),
			iconSize : this.getImageSize(),
			iconAnchor : this.getImageAnchor(),
			hover : true==hover,
			// Defect 67228 - See explanation in GmapsMarker (toProprietary method)
			dontDrawAsOverlay: true
			};			
		}
	});
});


},
'ibm/tivoli/fwm/mxmap/toolbar/ToolbarManager':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
/**
 * Controls the toolbar actions
 */
define(["dojo/main", "dijit/main", "dojox/main", "dojo/_base/declare", "dojo/parser", 
	"dijit/_WidgetBase", "ibm/tivoli/fwm/mxmap/_Base", "dijit/Toolbar", "ibm/tivoli/fwm/mxmap/toolbar/ToolbarSeparator",
	"dojo/_base/Deferred", "dojo/_base/lang", "dojo/dom-attr"],
	function(dojo, dijit, dojox, declare, parser, _WidgetBase, _Base,
			Toolbar, ToolbarSeparator, Deferred, lang, domAttr){

	if (!ibm.tivoli.fwm.mxmap.toolbar) {
		ibm.tivoli.fwm.mxmap.toolbar = {};
	}
	if (!ibm.tivoli.fwm.mxmap.toolbar.ext) {
		ibm.tivoli.fwm.mxmap.toolbar.ext = {};
	}
	
	return declare([_Base], {
		gisdata: null,
		mxdata: null,
		map: null,			
		items:[],
		toolbarItems:null,
		toolbarDivElement: null,
		addOnsAvailable: null,
		_toolbarHeight: 40,
		toolbarWidth:null,
		destroyingToolbar: null,
		currentTool: null,
		previousTool: null,
		isStartUp: null,

		/**
		 * Subscribes to the server updates to the current record
		 */
		constructor: function(options)
		{
			dojo.mixin(this, options);
			this.toolbarItems = [];
			this.addOnsAvailable = [];
			this.destroyingToolbar = false;
			// ['FullScreen','RefresherTool','MyLocationTool','ItineraryTool','QueryUnassignedWorkTool','QueryNearResources', 'LayersTool'];
			//if(this.map.isMobile == true){
			//this._defaultItems.push('MobileInfoPanel');
			//}
		},
		postCreate: function(){
			this.addSubscription("onCurrentRecordUpdate_"+this.map.getId(),
					dojo.hitch(this, this.serverUpdated));
		},
		container:null,
		toolbar:null, 
		loadToolBar: function() {

			var borderBottomStyle = dojo.isIE ? '1px solid #AAA' : '0px solid #AAA';
			this.container = dojo.create("div", {
				id: this.map.divId + "_toolbar",
				style: {
					whiteSpace: 'normal',
					'background-color': '#FFFFFF',
					'border':'1px solid #AAA',
					'border-bottom-color':'black','display':'block',
					'borderBottom' : borderBottomStyle,
					width: this.map.getWidthInPixels() + "px",
					height: this._toolbarHeight + "px"
				}
			}, dojo.byId(this.map.divId), 'before');
			var div = dojo.create("div", null, this.container);
			this.toolbar = new dijit.Toolbar(
				/* Object? */ 
				{
					style: {
						width: '100%',
						'border':'0',
						'background-position-y':'4%',
						'display': 'flex',
						'align-items': 'center',
						'height': '100%'
					}, 
					splitter: "true"
				}, 
				/* DomNode|String */
				div
			);				



			var mapid = this.map.getId();	
			var addOns = this.addOnsAvailable;
			var createItemButton = function(item){
				if(item == "sep"){
					var d = new ibm.tivoli.fwm.mxmap.toolbar.ToolbarSeparator();
					this.toolbar.addChild(d);
				}else{
					if (item == 'QueryWeatherAlertsTool' && !this.map.mapConf.schedulerPlusLicenseEnabled)
						return;

					var dijitName ="ibm/tivoli/fwm/mxmap/toolbar/ext/"+item;
					
					require([dijitName], dojo.hitch(this, function(itemName){ 
						try
						{
							this.itemDojo =  new itemName({map: this.map});
							if(this.map.mapConf.mapViewOnly && this.itemDojo.modifiesMap){
								if (dojo.config.fwm.debug == true)
								{
									console.debug("Tool will not be added in the toolbar: " + item);
								}
							}else{
								var itemDojo=this.itemDojo;// breaking up dojo. and require necessary to fool the dojo parser!
								if (itemDojo.isAddOn) 
								{
									addOns.push(itemDojo.addOnName);
								}
								var button = null;
								if (itemDojo.createToolbarButton) {
									button = itemDojo.createToolbarButton();
								}
								if (button == null){									
									return;
								}		
								var clickListener = function(){	
									if(this.lastItemClicked && this.lastItemClicked.declaredClass!=itemDojo.declaredClass){
										this.lastItemClicked.disable();
									}
									dojo.publish("mxnToolbarClicked_"+this.map.getId(),[itemDojo, this.lastItemClicked]);
									this.lastItemClicked=itemDojo;
								};
								this.addConnection("onClick", clickListener, button, this);
								this.toolbar.addChild(button);
								this.toolbarItems.push(itemDojo); 
							}								
						}
						catch(e)
						{
							console.log("Error ");
							console.log(e);
						}							
					})
					);
				}					
			};
			console.log("Toolbar items",this.items);
			dojo.forEach(this.items, createItemButton, this);

			this.map.mapConf.addOnsAvailable = addOns;
			// toolbar div is necessary for the full screen feature
			this.toolbarDivElement = this.container;

			if (this.map.providerName == "maximospatial" && this.map.mapConf.toolsPersistenceEnable == "1")
			{
				dojo.forEach(this.toolbarItems, function(toolbarItem){		
					if (typeof toolbarItem.loadToolConfiguration == 'function') {
						toolbarItem.loadToolConfiguration();
					}				
				});
			    /*
				 * Calls the events after the creation of all
				 */
				 dojo.forEach(this.toolbarItems, function(toolbarItem){
				 if (typeof toolbarItem.postCreate == 'function') {
			      toolbarItem.postCreate();
				 }
				 });

			}
			this.updateToolbarWidth(this.toolbarWidth);

			//Hide the loading icon after the toobar items are loaded
			if (this.map.providerName == "maximospatial")
			{
				this.map.hideLoadingImg();
			}

			if (this.map.isFullScreen == true)
			{
				this.map.fullScreenOn();
			} else {
				this.map._resize();
			}
		},
		disableTools: function(currentTool) {
			this.previousTool = this.currentTool;
			this.currentTool = currentTool;
			dojo.forEach(this.toolbarItems, function(itemDojo){							
				if (currentTool == null || currentTool.toolName != itemDojo.toolName) {
					if (typeof itemDojo.disableHighlightButton == 'function') {
						itemDojo.disableActions();
						itemDojo.disableHighlightButton();
					}
				}									
			});
		},
		startup:function(){
			this.loadToolBar();
		},
		lastItemClicked:null,
		serverUpdated: function()
		{
			this.mxdata = data.mxdata;
			this.gisdata = data.gisdata;
		},
		destroyToolbar: function() {
			dojo.forEach(this.toolbarItems, function(item){										
				item.destroy();					
			});				
			if (this.toolbar) {
				this.toolbar.destroyRecursive(true);
			}
			if (this.container) {
				dojo.empty(this.container);
			}
		},
		destroyRecursive: function(){
			this.inherited(arguments);

			if (!this.destroyingToolbar) {
				this.destroyingToolbar = true;
				if (this.map.providerName == "maximospatial")
				{
					if (this.map.mapConf.toolsPersistenceEnable == "1") {
						dojo.forEach(this.toolbarItems, function(item){		
							if (typeof item.saveToolConfiguration == 'function') {
								item.saveToolConfiguration();
							}				
						});
						var toolsJson = this.map.toolsJson;
						if (toolsJson) {
							toolsJson.saveMapExtent = this.map.mapConf.saveMapExtent;
							toolsJson.mapExtent = this.map.map.extent.toJson();
							toolsJson.zoomLevel = this.map.map.getLevel();
							this.map.getMaximo().saveToolsConfiguration(toolsJson, dojo.hitch(this, function(success) {
								this.destroyToolbar();
							}));
						} else {
							this.destroyToolbar();
						}

					} else {
						this.destroyToolbar();
					}

				} else {
					this.destroyToolbar();
				}
			}
		},
		getToolbarDivElement: function(){				
			return this.toolbarDivElement;
		},
		updateToolbarWidth: function(newWidth)
		{
			if (!newWidth)
			{
				newWidth = '99%';
			}
			if (this.toolbarDivElement) {
				if (newWidth.substr(newWidth.length - 1, 1) == '%')
				{
					dojo.style(this.toolbarDivElement, {width: newWidth});
				}
				else
				{
					dojo.style(this.toolbarDivElement, {width: newWidth + "px"});
				}					
			}

		},
		getToolbarHeight: function()
		{
			return this._toolbarHeight;
		},
		getToolItems: function() {
			return this.toolbarItems;
		}
	});
});

},
'dojo/data/util/sorter':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["../../_base/lang"], function(lang){
	// module:
	//		dojo/data/util/sorter
	// summary:
	//		TODOC

var sorter = {};
lang.setObject("dojo.data.util.sorter", sorter);

sorter.basicComparator = function(	/*anything*/ a,
													/*anything*/ b){
	// summary:
	//		Basic comparison function that compares if an item is greater or less than another item
	// description:
	//		returns 1 if a > b, -1 if a < b, 0 if equal.
	//		'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	//		And compared to each other, null is equivalent to undefined.

	//null is a problematic compare, so if null, we set to undefined.
	//Makes the check logic simple, compact, and consistent
	//And (null == undefined) === true, so the check later against null
	//works for undefined and is less bytes.
	var r = -1;
	if(a === null){
		a = undefined;
	}
	if(b === null){
		b = undefined;
	}
	if(a == b){
		r = 0;
	}else if(a > b || a == null){
		r = 1;
	}
	return r; //int {-1,0,1}
};

sorter.createSortFunction = function(	/* attributes[] */sortSpec, /*dojo/data/api/Read*/ store){
	// summary:
	//		Helper function to generate the sorting function based off the list of sort attributes.
	// description:
	//		The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	//		it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	//		use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	//		Returns the sorting function for this particular list of attributes and sorting directions.
	// sortSpec:
	//		A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	//		The objects should be formatted as follows:
	// |	{
	// |		attribute: "attributeName-string" || attribute,
	// |		descending: true|false;   // Default is false.
	// |	}
	// store:
	//		The datastore object to look up item values from.

	var sortFunctions=[];

	function createSortFunction(attr, dir, comp, s){
		//Passing in comp and s (comparator and store), makes this
		//function much faster.
		return function(itemA, itemB){
			var a = s.getValue(itemA, attr);
			var b = s.getValue(itemB, attr);
			return dir * comp(a,b); //int
		};
	}
	var sortAttribute;
	var map = store.comparatorMap;
	var bc = sorter.basicComparator;
	for(var i = 0; i < sortSpec.length; i++){
		sortAttribute = sortSpec[i];
		var attr = sortAttribute.attribute;
		if(attr){
			var dir = (sortAttribute.descending) ? -1 : 1;
			var comp = bc;
			if(map){
				if(typeof attr !== "string" && ("toString" in attr)){
					 attr = attr.toString();
				}
				comp = map[attr] || bc;
			}
			sortFunctions.push(createSortFunction(attr,
				dir, comp, store));
		}
	}
	return function(rowA, rowB){
		var i=0;
		while(i < sortFunctions.length){
			var ret = sortFunctions[i++](rowA, rowB);
			if(ret !== 0){
				return ret;//int
			}
		}
		return 0; //int
	}; // Function
};

return sorter;
});

},
'dijit/form/_ButtonMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/has",
	"../registry"        // registry.byNode
], function(declare, dom, has, registry){

	// module:
	//		dijit/form/_ButtonMixin

	var ButtonMixin = declare("dijit.form._ButtonMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
		// summary:
		//		A mixin to add a thin standard API wrapper to a normal HTML button
		// description:
		//		A label should always be specified (through innerHTML) or the label attribute.
		//
		//		Attach points:
		//
		//		- focusNode (required): this node receives focus
		//		- valueNode (optional): this node's value gets submitted with FORM elements
		//		- containerNode (optional): this node gets the innerHTML assignment for label
		// example:
		// |	<button data-dojo-type="dijit/form/Button" onClick="...">Hello world</button>
		// example:
		// |	var button1 = new Button({label: "hello world", onClick: foo});
		// |	dojo.body().appendChild(button1.domNode);

		// label: HTML String
		//		Content to display in button.
		label: "",

		// type: [const] String
		//		Type of button (submit, reset, button, checkbox, radio)
		type: "button",

		__onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to divert the real click onto the hidden INPUT that has a native default action associated with it
			// type:
			//		private
			e.stopPropagation();
			e.preventDefault();
			if(!this.disabled){
				// cannot use on.emit since button default actions won't occur
				this.valueNode.click(e);
			}
			return false;
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to handle click actions
			if(this.disabled){
				e.stopPropagation();
				e.preventDefault();
				return false;
			}
			if(this.onClick(e) === false){
				e.preventDefault();
			}
			var cancelled = e.defaultPrevented;

			// Signal Form/Dialog to submit/close.  For 2.0, consider removing this code and instead making the Form/Dialog
			// listen for bubbled click events where evt.target.type == "submit" && !evt.defaultPrevented.
			if(!cancelled && this.type == "submit" && !(this.valueNode || this.focusNode).form){
				for(var node = this.domNode; node.parentNode; node = node.parentNode){
					var widget = registry.byNode(node);
					if(widget && typeof widget._onSubmit == "function"){
						widget._onSubmit(e);
						e.preventDefault(); // action has already occurred
						cancelled = true;
						break;
					}
				}
			}

			return !cancelled;
		},

		postCreate: function(){
			this.inherited(arguments);
			dom.setSelectable(this.focusNode, false);
		},

		onClick: function(/*Event*/ /*===== e =====*/){
			// summary:
			//		Callback for when button is clicked.
			//		If type="submit", return true to perform submit, or false to cancel it.
			// type:
			//		callback
			return true;		// Boolean
		},

		_setLabelAttr: function(/*String*/ content){
			// summary:
			//		Hook for set('label', ...) to work.
			// description:
			//		Set the label (text) of the button; takes an HTML string.
			this._set("label", content);
			var labelNode = this.containerNode || this.focusNode;
			labelNode.innerHTML = content;
			this.onLabelSet();
		},

		onLabelSet: function(){
		}
	});

	if(has("dojo-bidi")){
		ButtonMixin = declare("dijit.form._ButtonMixin", ButtonMixin, {
			onLabelSet: function(){
				this.inherited(arguments);
				var labelNode = this.containerNode || this.focusNode;
				this.applyTextDir(labelNode);
			}
		});
	}

	return ButtonMixin;
});

},
'ibm/tivoli/fwm/mxmap/_Base':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/main", "dijit/main", "dojox/main", "dojo/_base/declare"], function(dojo, dijit, dojox, declare) {

	var mapDojo = null;
	
	return declare( null, {
		_handlers : null,
		constructor : function(options) {
			this._handlers = [];
			this.useMaxDojo = (options && options.useMaxDojo) ? true : false;
		},
		/**
		 * Sets a different dojo version for the module
		 * Needed when the module was loaded previously with a different dojo version
		 * 
		 * @param dojoVersion
		 * 
		 */
		setMapDojoVersion: function(dojoVersion) {
			mapDojo = dojoVersion;
		},
		/**
		 * Select the dojo version to be used
		 * @return dojo
		 */
		selectDojoVersion: function() {
			var dojoVersion = null;
			if (this.useMaxDojo) {
				dojoVersion = window.dojo;
			} else {
				dojoVersion = mapDojo || dojo;
			}
			return dojoVersion;
		},
		_getExistingHandler: function(event, handlerFunction)
		{
			// Check first if there is an existing handler for the same event/handlerFunction
			var existingHandler = dojo.filter(this._handlers, function(h)
			{
				return ((event === h.event) && (handlerFunction === h.advice));
			});
			return (existingHandler.length > 0) ? existingHandler[0] : null;
			
		},
		addSubscription: function(event, handlerFunction)
		{
			var dojoVersion = this.selectDojoVersion();
			if(this._getExistingHandler(event, handlerFunction) == null)
			{
				var newHandler = dojoVersion.subscribe(event, handlerFunction);
				// Adding the event property because it looks like dojo.subscribe does not
				// add the event to the handler (I wonder how dojo.unsubscribe knows which event to remove...)
				newHandler.event = event;
				this._handlers.push(newHandler);
			}
		},

		addConnection: function(event, handlerFunction, obj, context)
		{
			var dojoVersion = this.selectDojoVersion();
			if(this._getExistingHandler(event, handlerFunction) == null)
			{
				var newHandler = dojoVersion.connect(obj, event, context, handlerFunction);
				// Adding the event property because it looks like dojo.subscribe does not
				// add the event to the handler (I wonder how dojo.unsubscribe knows which event to remove...)
				newHandler.event = event;
				this._handlers.push(newHandler);
			}
		},
		
		removeSubscription: function(event, handlerFunction)
		{
			var dojoVersion = this.selectDojoVersion();
			var handler = this._getExistingHandler(event, handlerFunction)
			if(handler != null)
			{
				// Remove the handler from the array and call dojo.unsubscribe for that handler
				var index = this._handlers.indexOf(handler);
				this._handlers.splice(index, 1);
				dojoVersion.unsubscribe(handler);
			}
		},

		destroyRecursive: function()
		{
			var dojoVersion = this.selectDojoVersion();
			var h;
			while ((h = this._handlers.pop())) {
				dojoVersion.unsubscribe(h);
			}
		}

	});

});

},
'ibm/tivoli/fwm/i18n':function(){
// wrapped by build app
define(["dijit","dojo","dojox"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
/**
 * This dojo object implements the load of maxmessages to be accessible in the map 
 * 
 * @author rcouto
 */
dojo.provide("ibm.tivoli.fwm.i18n");
/**
 * This js loads msgs translated messages from MAXMESSAGES
 * 
 */
//caching variable
ibm.tivoli.fwm.i18n.msgs = {};


/**
 * Loads all MAXMESSAGES from a msggroup.
 */
ibm.tivoli.fwm.i18n.preLoadMsgGroup = function(msggroup) {
	if (ibm.tivoli.fwm.i18n.msgs[msggroup] == null) {
		var txt = dojohelper.getText(dojo.config.fwm.ctxRoot + '/rest/mbo/maxmessages?msggroup=' + msggroup + '&_includecols=msgkey,value&_format=json&');
		var maxmsgResult = dojo.fromJson(txt);
		if (maxmsgResult.MAXMESSAGESMboSet.MAXMESSAGES.length > 0) {
			ibm.tivoli.fwm.i18n.msgs[msggroup] = {};
			for ( var i = 0; i < maxmsgResult.MAXMESSAGESMboSet.MAXMESSAGES.length; i++) {
				var msg = maxmsgResult.MAXMESSAGESMboSet.MAXMESSAGES[i];				
				ibm.tivoli.fwm.i18n.msgs[msggroup][msg.Attributes.MSGKEY.content] = msg.Attributes.VALUE.content;
			}
		}
	}
};
/**
 * Loads a specific msgkey from a msggroup from MAXMESSAGES
 */
ibm.tivoli.fwm.i18n.getMaxMsg = function(msggroup, msgkey) {
	if (ibm.tivoli.fwm.i18n.msgs[msggroup] == null) {
		ibm.tivoli.fwm.i18n.msgs[msggroup] = {};
	}
	if (ibm.tivoli.fwm.i18n.msgs[msggroup][msgkey] == null) {
		ibm.tivoli.fwm.i18n.msgs[msggroup][msgkey] = ibm.tivoli.fwm.i18n._loadMsgThruRest(msggroup, msgkey);
	}
	if (ibm.tivoli.fwm.i18n.msgs[msggroup][msgkey] == null) {
		return (msggroup + "#" + msgkey);
	}

	return ibm.tivoli.fwm.i18n.msgs[msggroup][msgkey];
};
/**
 * Loads a specific msgkey from a msggroup from MAXMESSAGES with parameters
 */
ibm.tivoli.fwm.i18n.getMaxMsgWithParams = function(msggroup, msgkey, params) {
	if (ibm.tivoli.fwm.i18n.msgs[msggroup] == null) {
		ibm.tivoli.fwm.i18n.msgs[msggroup] = {};
	}
	if (ibm.tivoli.fwm.i18n.msgs[msggroup][msgkey] == null) {
		ibm.tivoli.fwm.i18n.msgs[msggroup][msgkey] = ibm.tivoli.fwm.i18n._loadMsgThruRest(msggroup, msgkey);
	}
	if (ibm.tivoli.fwm.i18n.msgs[msggroup][msgkey] == null) {
		return (msggroup + "#" + msgkey);
	}
	var message = ibm.tivoli.fwm.i18n.msgs[msggroup][msgkey];
	for (var i=0; i< params.length; i++) {
		message = message.split("{"+ i + "}").join(params[i]);
	}
	return message;
};
/**
 * Internal method for loading a specific message.
 */
ibm.tivoli.fwm.i18n._loadMsgThruRest = function(msggroup, msgkey) {
	var txt = dojohelper.getText(dojo.config.fwm.ctxRoot + '/rest/mbo/maxmessages?msgkey=' + msgkey + '&msggroup=' + msggroup + '&_includecols=msgkey,value&_format=json&_maxItems=1');
	var maxmsgResult = dojo.fromJson(txt);
	if (maxmsgResult.MAXMESSAGESMboSet.MAXMESSAGES.length > 0) {
		return maxmsgResult.MAXMESSAGESMboSet.MAXMESSAGES[0].Attributes.VALUE.content;
	}
	return null;
};

});

},
'dijit/registry':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/window", // win.body
	"./main"	// dijit._scopeName
], function(array, win, dijit){

	// module:
	//		dijit/registry

	var _widgetTypeCtr = {}, hash = {};

	var registry =  {
		// summary:
		//		Registry of existing widget on page, plus some utility methods.

		// length: Number
		//		Number of registered widgets
		length: 0,

		add: function(widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(hash[widget.id]){
				throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
			}
			hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from the registry. Does not destroy the widget; simply
			//		removes the reference.
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},

		byId: function(/*String|Widget*/ id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit/_WidgetBase
		},

		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit/_WidgetBase
		},

		toArray: function(){
			// summary:
			//		Convert registry into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	array.map(registry.toArray(), function(w){ return w.domNode; });

			var ar = [];
			for(var id in hash){
				ar.push(hash[id]);
			}
			return ar;	// dijit/_WidgetBase[]
		},

		getUniqueId: function(/*String*/widgetType){
			// summary:
			//		Generates a unique id for a given widgetType

			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
		},

		findWidgets: function(root, skipNode){
			// summary:
			//		Search subtree under root returning widgets found.
			//		Doesn't search for nested widgets (ie, widgets inside other widgets).
			// root: DOMNode
			//		Node to search under.
			// skipNode: DOMNode
			//		If specified, don't search beneath this node (usually containerNode).

			var outAry = [];

			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else if(node !== skipNode){
							getChildrenHelper(node);
						}
					}
				}
			}

			getChildrenHelper(root);
			return outAry;
		},

		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			dijit._curFocus = null;
			dijit._prevFocus = null;
			dijit._activeStack = [];

			// Destroy all the widgets, top down
			array.forEach(registry.findWidgets(win.body()), function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});
		},

		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.nodeType == 1 && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};

	dijit.registry = registry;

	return registry;
});

},
'dojo/io/script':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"../_base/connect", /*===== "../_base/declare", =====*/ "../_base/kernel", "../_base/lang",
	"../sniff", "../_base/window","../_base/xhr",
	"../dom", "../dom-construct", "../request/script", "../aspect"
], function(connect, /*===== declare, =====*/ kernel, lang, has, win, xhr, dom, domConstruct, _script, aspect){

	// module:
	//		dojo/io/script

	kernel.deprecated("dojo/io/script", "Use dojo/request/script.", "2.0");

	/*=====
	var __ioArgs = declare(kernel.__IoArgs, {
		// summary:
		//		All the properties described in the dojo.__ioArgs type, apply to this
		//		type as well, EXCEPT "handleAs". It is not applicable to
		//		dojo/io/script.get() calls, since it is implied by the usage of
		//		"jsonp" (response will be a JSONP call returning JSON)
		//		or the response is pure JavaScript defined in
		//		the body of the script that was attached.
		// callbackParamName: String
		//		Deprecated as of Dojo 1.4 in favor of "jsonp", but still supported for
		//		legacy code. See notes for jsonp property.
		// jsonp: String
		//		The URL parameter name that indicates the JSONP callback string.
		//		For instance, when using Yahoo JSONP calls it is normally,
		//		jsonp: "callback". For AOL JSONP calls it is normally
		//		jsonp: "c".
		// checkString: String
		//		A string of JavaScript that when evaluated like so:
		//		"typeof(" + checkString + ") != 'undefined'"
		//		being true means that the script fetched has been loaded.
		//		Do not use this if doing a JSONP type of call (use callbackParamName instead).
		// frameDoc: Document
		//		The Document object for a child iframe. If this is passed in, the script
		//		will be attached to that document. This can be helpful in some comet long-polling
		//		scenarios with Firefox and Opera.
	});
	=====*/

	var script = {
		// summary:
		//		TODOC

		get: function(/*__ioArgs*/ args){
			// summary:
			//		sends a get request using a dynamically created script tag.
			var rDfd;
			var dfd = this._makeScriptDeferred(args, function(dfd){
				rDfd && rDfd.cancel();
			});
			var ioArgs = dfd.ioArgs;
			xhr._ioAddQueryToUrl(ioArgs);

			xhr._ioNotifyStart(dfd);

			rDfd = _script.get(ioArgs.url, {
				timeout: args.timeout,
				jsonp: ioArgs.jsonp,
				checkString: args.checkString,
				ioArgs: ioArgs,
				frameDoc: args.frameDoc,
				canAttach: function(rDfd){
					// sync values
					ioArgs.requestId = rDfd.id;
					ioArgs.scriptId = rDfd.scriptId;
					ioArgs.canDelete = rDfd.canDelete;

					return script._canAttach(ioArgs);
				}
			}, true);

			// Run _validCheck at the same time dojo/request/watch runs the
			// rDfd.isValid function
			aspect.around(rDfd, "isValid", function(isValid){
				return function(response){
					script._validCheck(dfd);
					return isValid.call(this, response);
				};
			});

			rDfd.then(function(){
				dfd.resolve(dfd);
			}).otherwise(function(error){
				dfd.ioArgs.error = error;
				dfd.reject(error);
			});

			return dfd;
		},

		attach: _script._attach,
		remove: _script._remove,

		_makeScriptDeferred: function(/*Object*/ args, /*Function?*/ cancel){
			// summary:
			//		sets up a Deferred object for an IO request.
			var dfd = xhr._ioSetArgs(args, cancel || this._deferredCancel, this._deferredOk, this._deferredError);

			var ioArgs = dfd.ioArgs;
			ioArgs.id = kernel._scopeName + "IoScript" + (this._counter++);
			ioArgs.canDelete = false;

			//Special setup for jsonp case
			ioArgs.jsonp = args.callbackParamName || args.jsonp;
			if(ioArgs.jsonp){
				//Add the jsonp parameter.
				ioArgs.query = ioArgs.query || "";
				if(ioArgs.query.length > 0){
					ioArgs.query += "&";
				}
				ioArgs.query += ioArgs.jsonp +
					"=" + (args.frameDoc ? "parent." : "") +
					kernel._scopeName + ".io.script.jsonp_" + ioArgs.id + "._jsonpCallback";

				ioArgs.frameDoc = args.frameDoc;

				//Setup the Deferred to have the jsonp callback.
				ioArgs.canDelete = true;
				dfd._jsonpCallback = this._jsonpCallback;
				this["jsonp_" + ioArgs.id] = dfd;
			}
			// Make sure this runs no matter what happens to clean things up if need be
			dfd.addBoth(function(value){
				if(ioArgs.canDelete){
					if(value instanceof Error){
						// Set up a callback that will clean things up for timeouts and cancels
						script["jsonp_" + ioArgs.id]._jsonpCallback = function(){
							// Delete the cached deferred
							delete script["jsonp_" + ioArgs.id];
							if(ioArgs.requestId){
								// Call the dojo/request/script callback to clean itself up as well
								kernel.global[_script._callbacksProperty][ioArgs.requestId]();
							}
						};
					}else{
						script._addDeadScript(ioArgs);
					}
				}
			});
			return dfd; // dojo/_base/Deferred
		},

		_deferredCancel: function(/*Deferred*/ dfd){
			// summary:
			//		canceller function for xhr._ioSetArgs call.

			//DO NOT use "this" and expect it to be script.
			dfd.canceled = true;
		},

		_deferredOk: function(/*Deferred*/ dfd){
			// summary:
			//		okHandler function for xhr._ioSetArgs call.

			//DO NOT use "this" and expect it to be script.
			var ioArgs = dfd.ioArgs;

			//Favor JSONP responses, script load events then lastly ioArgs.
			//The ioArgs are goofy, but cannot return the dfd since that stops
			//the callback chain in Deferred. The return value is not that important
			//in that case, probably a checkString case.
			return ioArgs.json || ioArgs.scriptLoaded || ioArgs;
		},

		_deferredError: function(/*Error*/ error, /*Deferred*/ dfd){
			// summary:
			//		errHandler function for xhr._ioSetArgs call.

			console.log("dojo.io.script error", error);
			return error;
		},

		_deadScripts: [],
		_counter: 1,

		_addDeadScript: function(/*Object*/ ioArgs){
			// summary:
			//		sets up an entry in the deadScripts array.
			script._deadScripts.push({id: ioArgs.id, frameDoc: ioArgs.frameDoc});
			//Being extra paranoid about leaks:
			ioArgs.frameDoc = null;
		},

		_validCheck: function(/*Deferred*/ dfd){
			// summary:
			//		inflight check function to see if dfd is still valid.

			// TODO: why isn't dfd accessed?

			//Do script cleanup here. We wait for one inflight pass
			//to make sure we don't get any weird things by trying to remove a script
			//tag that is part of the call chain (IE 6 has been known to
			//crash in that case).
			var deadScripts = script._deadScripts;
			if(deadScripts && deadScripts.length > 0){
				for(var i = 0; i < deadScripts.length; i++){
					//Remove the script tag
					script.remove(deadScripts[i].id, deadScripts[i].frameDoc);
					//Clean up the deferreds
					delete script["jsonp_" + deadScripts[i].id];
					deadScripts[i].frameDoc = null;
				}
				script._deadScripts = [];
			}

			return true;
		},

		_ioCheck: function(dfd){
			// summary:
			//		inflight check function to see if IO finished.
			// dfd: Deferred
			var ioArgs = dfd.ioArgs;
			//Check for finished jsonp
			if(ioArgs.json || (ioArgs.scriptLoaded && !ioArgs.args.checkString)){
				return true;
			}

			//Check for finished "checkString" case.
			var checkString = ioArgs.args.checkString;
			return checkString && eval("typeof(" + checkString + ") != 'undefined'");


		},

		_resHandle: function(/*Deferred*/ dfd){
			// summary:
			//		inflight function to handle a completed response.
			if(script._ioCheck(dfd)){
				dfd.callback(dfd);
			}else{
				//This path should never happen since the only way we can get
				//to _resHandle is if _ioCheck is true.
				dfd.errback(new Error("inconceivable dojo.io.script._resHandle error"));
			}
		},

		_canAttach: function(/*===== ioArgs =====*/ ){
			// summary:
			//		A method that can be overridden by other modules
			//		to control when the script attachment occurs.
			// ioArgs: Object
			return true;
		},

		_jsonpCallback: function(/*JSON Object*/ json){
			// summary:
			//		generic handler for jsonp callback. A pointer to this function
			//		is used for all jsonp callbacks.  NOTE: the "this" in this
			//		function will be the Deferred object that represents the script
			//		request.
			this.ioArgs.json = json;
			if(this.ioArgs.requestId){
				kernel.global[_script._callbacksProperty][this.ioArgs.requestId](json);
			}
		}
	};

	lang.setObject("dojo.io.script", script);

	/*=====
	script.attach = function(id, url, frameDocument){
		// summary:
		//		creates a new `<script>` tag pointing to the specified URL and
		//		adds it to the document.
		// description:
		//		Attaches the script element to the DOM. Use this method if you
		//		just want to attach a script to the DOM and do not care when or
		//		if it loads.
	};
	script.remove = function(id, frameDocument){
		// summary:
		//		removes the script element with the given id, from the given frameDocument.
		//		If no frameDocument is passed, the current document is used.
	};
	=====*/

	return script;
});

},
'ibm/tivoli/fwm/mxmap/ContextMenu':function(){
/*
 * IBM Confidential
 * 
 * OCO Source Materials
 * 
 * 5724-U18, 5737-M66
 * 
 * (C) COPYRIGHT IBM CORP. 2011,2024
 * 
 * The source code for this program is not published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with the U.S.
 * Copyright Office.
 */

define(["dojo/_base/declare", "ibm/tivoli/fwm/mxmap/_Base", "dijit/Menu", "dijit/MenuItem" ], function(declare, _Base, Menu, MenuItem) {
	return declare( [_Base], {

		divId: null,
		map: null,
		compId:null,
		_contextMenu: null,
		_emptyContextMenu: null,
		_currentCtxMenu:null,
		constructor: function(params)
		{
			dojo.mixin(this, params);
			//TODO mapstraction implement
			this.map.addMapEventHandler(this.map.Events.click, dojo.hitch(this, this._onClick));
//			this.map.click.addHandler(this._onClick,this);
			this.map.addMapEventHandler(this.map.Events.rightclick, dojo.hitch(this, this._onRightClick));
//			this.map.rightclick.addHandler(this._onRightClick,this);

			dojo.create("div", {
				id: "popUpCtx"
			}, dojo.byId(this.divId));
			dojo.create("div", {
				id: "popUpEmptyCtx"
			}, dojo.byId(this.divId));
			this._contextMenu = new Menu({
				targetNodeIds: [ "popUpCtx" ]
			});
			this._currentCtxMenu=this._contextMenu;
			this._emptyContextMenu = new Menu({
				targetNodeIds: [ "popUpEmptyCtx" ]
			});
			var menuItem = new MenuItem({
				label: ibm.tivoli.fwm.i18n.getMaxMsg("map","no_actions_available_label"),
				onClick: dojo.hitch(this, function()
						{
					console.log("nothing to be done");
						})
			});
			this._emptyContextMenu.addChild(menuItem);
			this.addSubscription("onCurrentRecordUpdate_" + this.compId, dojo.hitch(this, this.serverUpdated));

		},
		serverUpdated:function(data){
			console.log("ctx menu",data);
			if(data && data.gisdata && data.gisdata.flags && data.gisdata.flags.readonly==true){
				this._currentCtxMenu=this._emptyContextMenu;
			}else{
				this._currentCtxMenu=this._contextMenu;
			}
		},

		/**
		 * on map click outside the menu, we close the opened menu
		 */
		_onClick: function()
		{
			dijit.popup.close(this._currentCtxMenu);
		},
		/**
		 * Context menu args like map location where the menu was opened
		 */
		_contextArgs: {
			mapLocation: {}
		},
		/**
		 * Executed when user right clicks the map in order to show the context menu
		 */
		_onRightClick: function(event_args)
		{
			dijit.popup.close(this._currentCtxMenu);
			var point = event_args.location;
			var divPosition = dojo.position(dojo.byId(this.divId), true);					
			var x = event_args.pixel.x + divPosition.x;
			var y = event_args.pixel.y + divPosition.y;				
			this._contextArgs = {
					mapLocation: point
			};
			dijit.popup.open({
				popup: this._currentCtxMenu,
				x: x,
				y: y,
				onExecute: dojo.hitch(this, function(ag)
						{
					dijit.popup.close(this._currentCtxMenu);
						}),
						onCancel: function(ag)
						{
							if (dojo.config.fwm.debug == true)
							{
								console.log("cancel", ag);
							}
						},
						orient: 'L'
			});
		},
		/**
		 * If an menu item is execute we must call the menu controller method
		 */
		_executeAction: function(action)
		{
			action.execute(this._contextArgs);
		},
		/**
		 * Adds a new Action into the menu. Action must be a
		 * ibm.tivoli.fwm.mxmap.actions.Actions
		 */
		addChild: function(action)
		{
			var menuItem = new MenuItem({
				label: action.label,
				onClick: dojo.hitch(this, function()
						{
					this._executeAction(action);
						})
			});
			this._contextMenu.addChild(menuItem);
		},
		/**
		 * Destroy the map handlers /TODO must be moved to _Base
		 */
		destroyRecursive: function()
		{
			dijit.popup.close(this._contextMenu);
			dijit.popup.close(this._emptyContextMenu);
			//TODO mapstraction implement
//			this.map.click.removeHandler( this.onClick,this);
//			this.map.rightclick.removeHandler(this.onRightClick,this);

		}

	});
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/LayersTool':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/layers/LayerPanelWidget,ibm/tivoli/fwm/mxmap/_Base,ibm/tivoli/fwm/mxmap/toolbar/ext/_ToolTemplate,dijit/form/Button"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.toolbar.ext.LayersTool");
dojo.require("ibm.tivoli.fwm.mxmap.layers.LayerPanelWidget");
dojo.require("ibm.tivoli.fwm.mxmap._Base");
dojo.require("ibm.tivoli.fwm.mxmap.toolbar.ext._ToolTemplate");
dojo.require("dijit.form.Button");

/**
 * Layers tool
 */
dojo.declare("ibm.tivoli.fwm.mxmap.toolbar.ext.LayersTool", ibm.tivoli.fwm.mxmap.toolbar.ext._ToolTemplate, {
		label: "Layers",
		iconClass: "basicMapToolbarBtn layersMapToolbarBtn",
		map: null,
		currentPanelWidget: null,
		constructor: function(params)
		{			
			dojo.mixin(this, params); 
			var _label = ibm.tivoli.fwm.i18n.getMaxMsg("map", "layers");
			this.label = _label || this.label;
		},
		execute: function()
		{	
			this._destroyCurrentPanelWidget();
			var _layerPanelManager = new ibm.tivoli.fwm.mxmap.layers.LayerPanelWidget({map: this.map, tool: this});		
			_layerPanelManager.updateLayers(this.map.getLayersManager().getLayers());
		},
		disable: function()
		{
		},
		setPanelWidget: function(panel)
		{
			this.currentPanelWidget = panel;
		},
		destroy: function()
		{
			this._destroyCurrentPanelWidget();
			this.destroyRecursive();
		},
		_destroyCurrentPanelWidget: function()
		{
			// Close the tool when destroying (when leaving the map tab)
			if((this.currentPanelWidget != null) && (this.currentPanelWidget != undefined))
			{
				this.currentPanelWidget.close();
			}
		}
});

});

},
'dijit/form/_FormSelectWidget':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.filter array.forEach array.map array.some
	"dojo/_base/Deferred",
	"dojo/aspect", // aspect.after
	"dojo/data/util/sorter", // util.sorter.createSortFunction
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/kernel",	// _scopeName
	"dojo/_base/lang", // lang.delegate lang.isArray lang.isObject lang.hitch
	"dojo/query", // query
	"dojo/when",
	"dojo/store/util/QueryResults",
	"./_FormValueWidget"
], function(array, Deferred, aspect, sorter, declare, dom, domClass, kernel, lang, query, when,
			QueryResults, _FormValueWidget){

	// module:
	//		dijit/form/_FormSelectWidget

	/*=====
	var __SelectOption = {
		// value: String
		//		The value of the option.  Setting to empty (or missing) will
		//		place a separator at that location
		// label: String
		//		The label for our option.  It can contain html tags.
		// selected: Boolean
		//		Whether or not we are a selected option
		// disabled: Boolean
		//		Whether or not this specific option is disabled
	};
	=====*/

	var _FormSelectWidget = declare("dijit.form._FormSelectWidget", _FormValueWidget, {
		// summary:
		//		Extends _FormValueWidget in order to provide "select-specific"
		//		values - i.e., those values that are unique to `<select>` elements.
		//		This also provides the mechanism for reading the elements from
		//		a store, if desired.

		// multiple: [const] Boolean
		//		Whether or not we are multi-valued
		multiple: false,

		// options: __SelectOption[]
		//		The set of options for our select item.  Roughly corresponds to
		//		the html `<option>` tag.
		options: null,

		// store: dojo/store/api/Store
		//		A store to use for getting our list of options - rather than reading them
		//		from the `<option>` html tags.   Should support getIdentity().
		//		For back-compat store can also be a dojo/data/api/Identity.
		store: null,
		_setStoreAttr: function(val){
			if(this._created){		// don't repeat work that will happen in postCreate()
				this._deprecatedSetStore(val);
			}
		},

		// query: object
		//		A query to use when fetching items from our store
		query: null,
		_setQueryAttr: function(query){
			if(this._created){		// don't repeat work that will happen in postCreate()
				this._deprecatedSetStore(this.store, this.selectedValue, {query: query});
			}
		},

		// queryOptions: object
		//		Query options to use when fetching from the store
		queryOptions: null,
		_setQueryOptionsAttr: function(queryOptions){
			if(this._created){		// don't repeat work that will happen in postCreate()
				this._deprecatedSetStore(this.store, this.selectedValue, {queryOptions: queryOptions});
			}
		},

		// labelAttr: String?
		//		The entries in the drop down list come from this attribute in the dojo.store items.
		//		If ``store`` is set, labelAttr must be set too, unless store is an old-style
		//		dojo.data store rather than a new dojo/store.
		labelAttr: "",

		// onFetch: Function
		//		A callback to do with an onFetch - but before any items are actually
		//		iterated over (i.e. to filter even further what you want to add)
		onFetch: null,

		// sortByLabel: Boolean
		//		Flag to sort the options returned from a store by the label of
		//		the store.
		sortByLabel: true,


		// loadChildrenOnOpen: Boolean
		//		By default loadChildren is called when the items are fetched from the
		//		store.  This property allows delaying loadChildren (and the creation
		//		of the options/menuitems) until the user clicks the button to open the
		//		dropdown.
		loadChildrenOnOpen: false,

		// onLoadDeferred: [readonly] dojo.Deferred
		//		This is the `dojo.Deferred` returned by setStore().
		//		Calling onLoadDeferred.then() registers your
		//		callback to be called only once, when the prior setStore completes.
		onLoadDeferred: null,

		getOptions: function(/*anything*/ valueOrIdx){
			// summary:
			//		Returns a given option (or options).
			// valueOrIdx:
			//		If passed in as a string, that string is used to look up the option
			//		in the array of options - based on the value property.
			//		(See dijit/form/_FormSelectWidget.__SelectOption).
			//
			//		If passed in a number, then the option with the given index (0-based)
			//		within this select will be returned.
			//
			//		If passed in a dijit/form/_FormSelectWidget.__SelectOption, the same option will be
			//		returned if and only if it exists within this select.
			//
			//		If passed an array, then an array will be returned with each element
			//		in the array being looked up.
			//
			//		If not passed a value, then all options will be returned
			//
			// returns:
			//		The option corresponding with the given value or index.
			//		null is returned if any of the following are true:
			//
			//		- A string value is passed in which doesn't exist
			//		- An index is passed in which is outside the bounds of the array of options
			//		- A dijit/form/_FormSelectWidget.__SelectOption is passed in which is not a part of the select

			// NOTE: the compare for passing in a dijit/form/_FormSelectWidget.__SelectOption checks
			//		if the value property matches - NOT if the exact option exists
			// NOTE: if passing in an array, null elements will be placed in the returned
			//		array when a value is not found.
			var opts = this.options || [];

			if(valueOrIdx == null){
				return opts; // __SelectOption[]
			}
			if(lang.isArrayLike(valueOrIdx)){
				return array.map(valueOrIdx, function(item){
					return this.getOptions(item);
				}, this); // __SelectOption[]
			}
			if(lang.isString(valueOrIdx)){
				valueOrIdx = { value: valueOrIdx };
			}
			if(lang.isObject(valueOrIdx)){
				// We were passed an option - so see if it's in our array (directly),
				// and if it's not, try and find it by value.

				if(!array.some(opts, function(option, idx){
					for(var a in valueOrIdx){
						if(!(a in option) || option[a] != valueOrIdx[a]){ // == and not === so that 100 matches '100'
							return false;
						}
					}
					valueOrIdx = idx;
					return true; // stops iteration through opts
				})){
					valueOrIdx = -1;
				}
			}
			if(valueOrIdx >= 0 && valueOrIdx < opts.length){
				return opts[valueOrIdx]; // __SelectOption
			}
			return null; // null
		},

		addOption: function(/*__SelectOption|__SelectOption[]*/ option){
			// summary:
			//		Adds an option or options to the end of the select.  If value
			//		of the option is empty or missing, a separator is created instead.
			//		Passing in an array of options will yield slightly better performance
			//		since the children are only loaded once.
			array.forEach(lang.isArrayLike(option) ? option : [option], function(i){
				if(i && lang.isObject(i)){
					this.options.push(i);
				}
			}, this);
			this._loadChildren();
		},

		removeOption: function(/*String|__SelectOption|Number|Array*/ valueOrIdx){
			// summary:
			//		Removes the given option or options.  You can remove by string
			//		(in which case the value is removed), number (in which case the
			//		index in the options array is removed), or select option (in
			//		which case, the select option with a matching value is removed).
			//		You can also pass in an array of those values for a slightly
			//		better performance since the children are only loaded once.
			//		For numeric option values, specify {value: number} as the argument.
			var oldOpts = this.getOptions(lang.isArrayLike(valueOrIdx) ? valueOrIdx : [valueOrIdx]);
			array.forEach(oldOpts, function(option){
				// We can get null back in our array - if our option was not found.  In
				// that case, we don't want to blow up...
				if(option){
					this.options = array.filter(this.options, function(node){
						return (node.value !== option.value || node.label !== option.label);
					});
					this._removeOptionItem(option);
				}
			}, this);
			this._loadChildren();
		},

		updateOption: function(/*__SelectOption|__SelectOption[]*/ newOption){
			// summary:
			//		Updates the values of the given option.  The option to update
			//		is matched based on the value of the entered option.  Passing
			//		in an array of new options will yield better performance since
			//		the children will only be loaded once.
			array.forEach(lang.isArrayLike(newOption) ? newOption : [newOption], function(i){
				var oldOpt = this.getOptions({ value: i.value }), k;
				if(oldOpt){
					for(k in i){
						oldOpt[k] = i[k];
					}
				}
			}, this);
			this._loadChildren();
		},

		setStore: function(store, selectedValue, fetchArgs){
			kernel.deprecated(this.declaredClass+"::setStore(store, selectedValue, fetchArgs) is deprecated. Use set('query', fetchArgs.query), set('queryOptions', fetchArgs.queryOptions), set('store', store), or set('value', selectedValue) instead.", "", "2.0");
			this._deprecatedSetStore(store, selectedValue, fetchArgs);
		},

		_deprecatedSetStore: function(store, selectedValue, fetchArgs){
			// summary:
			//		Sets the store you would like to use with this select widget.
			//		The selected value is the value of the new store to set.  This
			//		function returns the original store, in case you want to reuse
			//		it or something.
			// store: dojo/store/api/Store
			//		The dojo.store you would like to use - it MUST implement getIdentity()
			//		and MAY implement observe().
			//		For backwards-compatibility this can also be a data.data store, in which case
			//		it MUST implement dojo/data/api/Identity,
			//		and MAY implement dojo/data/api/Notification.
			// selectedValue: anything?
			//		The value that this widget should set itself to *after* the store
			//		has been loaded
			// fetchArgs: Object?
			//		Hash of parameters to set filter on store, etc.
			//
			//		- query: new value for Select.query,
			//		- queryOptions: new value for Select.queryOptions,
			//		- onFetch: callback function for each item in data (Deprecated)
			var oStore = this.store;
			fetchArgs = fetchArgs || {};

			if(oStore !== store){
				// Our store has changed, so cancel any listeners on old store (remove for 2.0)
				var h;
				while((h = this._notifyConnections.pop())){
					h.remove();
				}

				// For backwards-compatibility, accept dojo.data store in addition to dojo.store.store.  Remove in 2.0.
				if(!store.get){
					lang.mixin(store, {
						_oldAPI: true,
						get: function(id){
							// summary:
							//		Retrieves an object by it's identity. This will trigger a fetchItemByIdentity.
							//		Like dojo.store.DataStore.get() except returns native item.
							var deferred = new Deferred();
							this.fetchItemByIdentity({
								identity: id,
								onItem: function(object){
									deferred.resolve(object);
								},
								onError: function(error){
									deferred.reject(error);
								}
							});
							return deferred.promise;
						},
						query: function(query, options){
							// summary:
							//		Queries the store for objects.   Like dojo/store/DataStore.query()
							//		except returned Deferred contains array of native items.
							var deferred = new Deferred(function(){
								if(fetchHandle.abort){
									fetchHandle.abort();
								}
							});
							deferred.total = new Deferred();
							var fetchHandle = this.fetch(lang.mixin({
								query: query,
								onBegin: function(count){
									deferred.total.resolve(count);
								},
								onComplete: function(results){
									deferred.resolve(results);
								},
								onError: function(error){
									deferred.reject(error);
								}
							}, options));
							return new QueryResults(deferred);
						}
					});

					if(store.getFeatures()["dojo.data.api.Notification"]){
						this._notifyConnections = [
							aspect.after(store, "onNew", lang.hitch(this, "_onNewItem"), true),
							aspect.after(store, "onDelete", lang.hitch(this, "_onDeleteItem"), true),
							aspect.after(store, "onSet", lang.hitch(this, "_onSetItem"), true)
						];
					}
				}
				this._set("store", store);			// Our store has changed, so update our notifications
			}

			// Remove existing options (if there are any)
			if(this.options && this.options.length){
				this.removeOption(this.options);
			}

			// Cancel listener for updates to old (dojo.data) store
			if(this._queryRes && this._queryRes.close){
				this._queryRes.close();
			}

			// Cancel listener for updates to new (dojo.store) store
			if(this._observeHandle && this._observeHandle.remove){
				this._observeHandle.remove();
				this._observeHandle = null;
			}

			// If user has specified new query and query options along with this new store, then use them.
			if(fetchArgs.query){
				this._set("query", fetchArgs.query);
			}
			if(fetchArgs.queryOptions){
				this._set("queryOptions", fetchArgs.queryOptions);
			}

			// Add our new options
			if(store && store.query){
				this._loadingStore = true;
				this.onLoadDeferred = new Deferred();

				// Run query
				// Save result in this._queryRes so we can cancel the listeners we register below
				this._queryRes = store.query(this.query, this.queryOptions);
				when(this._queryRes, lang.hitch(this, function(items){

					if(this.sortByLabel && !fetchArgs.sort && items.length){
						if(store.getValue){
							// Old dojo.data API to access items, remove for 2.0
							items.sort(sorter.createSortFunction([
								{
									attribute: store.getLabelAttributes(items[0])[0]
								}
							], store));
						}else{
							// TODO: remove sortByLabel completely for 2.0?  It can be handled by queryOptions: {sort: ... }.
							var labelAttr = this.labelAttr;
							items.sort(function(a, b){
								return a[labelAttr] > b[labelAttr] ? 1 : b[labelAttr] > a[labelAttr] ? -1 : 0;
							});
						}
					}

					if(fetchArgs.onFetch){
						items = fetchArgs.onFetch.call(this, items, fetchArgs);
					}

					// TODO: Add these guys as a batch, instead of separately
					array.forEach(items, function(i){
						this._addOptionForItem(i);
					}, this);

					// Register listener for store updates
					if(this._queryRes.observe){
						// observe returns yet another handle that needs its own explicit gc
						this._observeHandle = this._queryRes.observe(lang.hitch(this, function(object, deletedFrom, insertedInto){
							if(deletedFrom == insertedInto){
								this._onSetItem(object);
							}else{
								if(deletedFrom != -1){
									this._onDeleteItem(object);
								}
								if(insertedInto != -1){
									this._onNewItem(object);
								}
							}
						}), true);
					}

					// Set our value (which might be undefined), and then tweak
					// it to send a change event with the real value
					this._loadingStore = false;
					this.set("value", "_pendingValue" in this ? this._pendingValue : selectedValue);
					delete this._pendingValue;

					if(!this.loadChildrenOnOpen){
						this._loadChildren();
					}else{
						this._pseudoLoadChildren(items);
					}
					this.onLoadDeferred.resolve(true);
					this.onSetStore();
				}), lang.hitch(this, function(err){
					console.error('dijit.form.Select: ' + err.toString());
					this.onLoadDeferred.reject(err);
				}));
			}
			return oStore;	// dojo/data/api/Identity
		},

		_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		set the value of the widget.
			//		If a string is passed, then we set our value from looking it up.
			if(!this._onChangeActive){
				priorityChange = null;
			}
			if(this._loadingStore){
				// Our store is loading - so save our value, and we'll set it when
				// we're done
				this._pendingValue = newValue;
				return;
			}
			if(newValue == null){
				return;
			}
			if(lang.isArrayLike(newValue)){
				newValue = array.map(newValue, function(value){
					return lang.isObject(value) ? value : { value: value };
				}); // __SelectOption[]
			}else if(lang.isObject(newValue)){
				newValue = [newValue];
			}else{
				newValue = [
					{ value: newValue }
				];
			}
			newValue = array.filter(this.getOptions(newValue), function(i){
				return i && i.value;
			});
			var opts = this.getOptions() || [];
			if(!this.multiple && (!newValue[0] || !newValue[0].value) && !!opts.length){
				newValue[0] = opts[0];
			}
			array.forEach(opts, function(opt){
				opt.selected = array.some(newValue, function(v){
					return v.value === opt.value;
				});
			});
			var val = array.map(newValue, function(opt){
				return opt.value;
			});

			if(typeof val == "undefined" || typeof val[0] == "undefined"){
				return;
			} // not fully initialized yet or a failed value lookup
			var disp = array.map(newValue, function(opt){
				return opt.label;
			});
			this._setDisplay(this.multiple ? disp : disp[0]);
			this.inherited(arguments, [ this.multiple ? val : val[0], priorityChange ]);
			this._updateSelection();
		},

		_getDisplayedValueAttr: function(){
			// summary:
			//		returns the displayed value of the widget
			var ret = array.map([].concat(this.get('selectedOptions')), function(v){
				if(v && "label" in v){
					return v.label;
				}else if(v){
					return v.value;
				}
				return null;
			}, this);
			return this.multiple ? ret : ret[0];
		},

		_setDisplayedValueAttr: function(label){
			// summary:
			//		Sets the displayed value of the widget
			this.set('value', this.getOptions(typeof label == "string" ? { label: label } : label));
		},

		_loadChildren: function(){
			// summary:
			//		Loads the children represented by this widget's options.
			//		reset the menu to make it populatable on the next click
			if(this._loadingStore){
				return;
			}
			array.forEach(this._getChildren(), function(child){
				child.destroyRecursive();
			});
			// Add each menu item
			array.forEach(this.options, this._addOptionItem, this);

			// Update states
			this._updateSelection();
		},

		_updateSelection: function(){
			// summary:
			//		Sets the "selected" class on the item for styling purposes
			this.focusedChild = null;
			this._set("value", this._getValueFromOpts());
			var val = [].concat(this.value);
			if(val && val[0]){
				var self = this;
				array.forEach(this._getChildren(), function(child){
					var isSelected = array.some(val, function(v){
						return child.option && (v === child.option.value);
					});
					if(isSelected && !self.multiple){
						self.focusedChild = child;
					}
					domClass.toggle(child.domNode, this.baseClass.replace(/\s+|$/g, "SelectedOption "), isSelected);
					child.domNode.setAttribute("aria-selected", isSelected ? "true" : "false");
				}, this);
			}
		},

		_getValueFromOpts: function(){
			// summary:
			//		Returns the value of the widget by reading the options for
			//		the selected flag
			var opts = this.getOptions() || [];
			if(!this.multiple && opts.length){
				// Mirror what a select does - choose the first one
				var opt = array.filter(opts, function(i){
					return i.selected;
				})[0];
				if(opt && opt.value){
					return opt.value;
				}else{
					opts[0].selected = true;
					return opts[0].value;
				}
			}else if(this.multiple){
				// Set value to be the sum of all selected
				return array.map(array.filter(opts, function(i){
					return i.selected;
				}), function(i){
					return i.value;
				}) || [];
			}
			return "";
		},

		// Internal functions to call when we have store notifications come in
		_onNewItem: function(/*item*/ item, /*Object?*/ parentInfo){
			if(!parentInfo || !parentInfo.parent){
				// Only add it if we are top-level
				this._addOptionForItem(item);
			}
		},
		_onDeleteItem: function(/*item*/ item){
			var store = this.store;
			this.removeOption({value: store.getIdentity(item) });
		},
		_onSetItem: function(/*item*/ item){
			this.updateOption(this._getOptionObjForItem(item));
		},

		_getOptionObjForItem: function(item){
			// summary:
			//		Returns an option object based off the given item.  The "value"
			//		of the option item will be the identity of the item, the "label"
			//		of the option will be the label of the item.

			// remove getLabel() call for 2.0 (it's to support the old dojo.data API)
			var store = this.store,
				label = (this.labelAttr && this.labelAttr in item) ? item[this.labelAttr] : store.getLabel(item),
				value = (label ? store.getIdentity(item) : null);
			return {value: value, label: label, item: item}; // __SelectOption
		},

		_addOptionForItem: function(/*item*/ item){
			// summary:
			//		Creates (and adds) the option for the given item
			var store = this.store;
			if(store.isItemLoaded && !store.isItemLoaded(item)){
				// We are not loaded - so let's load it and add later.
				// Remove for 2.0 (it's the old dojo.data API)
				store.loadItem({item: item, onItem: function(i){
					this._addOptionForItem(i);
				},
					scope: this});
				return;
			}
			var newOpt = this._getOptionObjForItem(item);
			this.addOption(newOpt);
		},

		constructor: function(params /*===== , srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree

			//		Saves off our value, if we have an initial one set so we
			//		can use it if we have a store as well (see startup())
			this._oValue = (params || {}).value || null;
			this._notifyConnections = [];	// remove for 2.0
		},

		buildRendering: function(){
			this.inherited(arguments);
			dom.setSelectable(this.focusNode, false);
		},

		_fillContent: function(){
			// summary:
			//		Loads our options and sets up our dropdown correctly.  We
			//		don't want any content, so we don't call any inherit chain
			//		function.
			if(!this.options){
				this.options =
					this.srcNodeRef
						? query("> *", this.srcNodeRef).map(
						function(node){
							if(node.getAttribute("type") === "separator"){
								return { value: "", label: "", selected: false, disabled: false };
							}
							return {
								value: (node.getAttribute("data-" + kernel._scopeName + "-value") || node.getAttribute("value")),
								label: String(node.innerHTML),
								// FIXME: disabled and selected are not valid on complex markup children (which is why we're
								// looking for data-dojo-value above.  perhaps we should data-dojo-props="" this whole thing?)
								// decide before 1.6
								selected: node.getAttribute("selected") || false,
								disabled: node.getAttribute("disabled") || false
							};
						},
						this)
						: [];
			}
			if(!this.value){
				this._set("value", this._getValueFromOpts());
			}else if(this.multiple && typeof this.value == "string"){
				this._set("value", this.value.split(","));
			}
		},

		postCreate: function(){
			// summary:
			//		sets up our event handling that we need for functioning
			//		as a select
			this.inherited(arguments);

			// Make our event connections for updating state
			aspect.after(this, "onChange", lang.hitch(this, "_updateSelection"));

			//		Connects in our store, if we have one defined
			var store = this.store;
			if(store && (store.getIdentity || store.getFeatures()["dojo.data.api.Identity"])){
				// Temporarily set our store to null so that it will get set
				// and connected appropriately
				this.store = null;
				this._deprecatedSetStore(store, this._oValue, {query: this.query, queryOptions: this.queryOptions});
			}

			this._storeInitialized = true;
		},

		startup: function(){
			// summary:
			this._loadChildren();
			this.inherited(arguments);
		},

		destroy: function(){
			// summary:
			//		Clean up our connections

			var h;
			while((h = this._notifyConnections.pop())){
				h.remove();
			}

			// Cancel listener for store updates
			if(this._queryRes && this._queryRes.close){
				this._queryRes.close();
			}

			// Cancel listener for updates to new (dojo.store) store
			if(this._observeHandle && this._observeHandle.remove){
				this._observeHandle.remove();
				this._observeHandle = null;
			}

			this.inherited(arguments);
		},

		_addOptionItem: function(/*__SelectOption*/ /*===== option =====*/){
			// summary:
			//		User-overridable function which, for the given option, adds an
			//		item to the select.  If the option doesn't have a value, then a
			//		separator is added in that place.  Make sure to store the option
			//		in the created option widget.
		},

		_removeOptionItem: function(/*__SelectOption*/ /*===== option =====*/){
			// summary:
			//		User-overridable function which, for the given option, removes
			//		its item from the select.
		},

		_setDisplay: function(/*String or String[]*/ /*===== newDisplay =====*/){
			// summary:
			//		Overridable function which will set the display for the
			//		widget.  newDisplay is either a string (in the case of
			//		single selects) or array of strings (in the case of multi-selects)
		},

		_getChildren: function(){
			// summary:
			//		Overridable function to return the children that this widget contains.
			return [];
		},

		_getSelectedOptionsAttr: function(){
			// summary:
			//		hooks into this.attr to provide a mechanism for getting the
			//		option items for the current value of the widget.
			return this.getOptions({ selected: true });
		},

		_pseudoLoadChildren: function(/*item[]*/ /*===== items =====*/){
			// summary:
			//		a function that will "fake" loading children, if needed, and
			//		if we have set to not load children until the widget opens.
			// items:
			//		An array of items that will be loaded, when needed
		},

		onSetStore: function(){
			// summary:
			//		a function that can be connected to in order to receive a
			//		notification that the store has finished loading and all options
			//		from that store are available
		}
	});

	/*=====
	_FormSelectWidget.__SelectOption = __SelectOption;
	=====*/

	return _FormSelectWidget;
});

},
'dijit/form/Select':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.add domClass.remove domClass.toggle
	"dojo/dom-geometry", // domGeometry.setMarginBox
	"dojo/i18n", // i18n.getLocalization
	"dojo/keys",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie")
	"./_FormSelectWidget",
	"../_HasDropDown",
	"../DropDownMenu",
	"../MenuItem",
	"../MenuSeparator",
	"../Tooltip",
	"../_KeyNavMixin",
	"../registry", // registry.byNode
	"dojo/text!./templates/Select.html",
	"dojo/i18n!./nls/validate"
], function(array, declare, domAttr, domClass, domGeometry, i18n, keys, lang, on, has,
			_FormSelectWidget, _HasDropDown, DropDownMenu, MenuItem, MenuSeparator, Tooltip, _KeyNavMixin, registry, template){

	// module:
	//		dijit/form/Select

	var _SelectMenu = declare("dijit.form._SelectMenu", DropDownMenu, {
		// summary:
		//		An internally-used menu for dropdown that allows us a vertical scrollbar

		// Override Menu.autoFocus setting so that opening a Select highlights the current value.
		autoFocus: true,

		buildRendering: function(){
			this.inherited(arguments);

			this.domNode.setAttribute("role", "listbox");
		},

		postCreate: function(){
			this.inherited(arguments);

			// stop mousemove from selecting text on IE to be consistent with other browsers
			this.own(on(this.domNode, "selectstart", function(evt){
				evt.preventDefault();
				evt.stopPropagation();
			}));
		},

		focus: function(){
			// summary:
			//		Overridden so that the previously selected value will be focused instead of only the first item
			var found = false,
				val = this.parentWidget.value;
			if(lang.isArray(val)){
				val = val[val.length - 1];
			}
			if(val){ // if focus selected
				array.forEach(this.parentWidget._getChildren(), function(child){
					if(child.option && (val === child.option.value)){ // find menu item widget with this value
						found = true;
						this.focusChild(child, false); // focus previous selection
					}
				}, this);
			}
			if(!found){
				this.inherited(arguments); // focus first item by default
			}
		}
	});

	var Select = declare("dijit.form.Select" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormSelectWidget, _HasDropDown, _KeyNavMixin], {
		// summary:
		//		This is a "styleable" select box - it is basically a DropDownButton which
		//		can take a `<select>` as its input.

		baseClass: "dijitSelect dijitValidationTextBox",

		templateString: template,

		_buttonInputDisabled: has("ie") ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events

		// required: Boolean
		//		Can be true or false, default is false.
		required: false,

		// state: [readonly] String
		//		"Incomplete" if this select is required but unset (i.e. blank value), "" otherwise
		state: "",

		// message: String
		//		Currently displayed error/prompt message
		message: "",

		// tooltipPosition: String[]
		//		See description of `dijit/Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		// emptyLabel: string
		//		What to display in an "empty" dropdown
		emptyLabel: "&#160;", // &nbsp;

		// _isLoaded: Boolean
		//		Whether or not we have been loaded
		_isLoaded: false,

		// _childrenLoaded: Boolean
		//		Whether or not our children have been loaded
		_childrenLoaded: false,

		// labelType: String
		//		Specifies how to interpret the labelAttr in the data store items.
		//		Can be "html" or "text".
		labelType: "html",

		_fillContent: function(){
			// summary:
			//		Set the value to be the first, or the selected index
			this.inherited(arguments);
			// set value from selected option
			if(this.options.length && !this.value && this.srcNodeRef){
				var si = this.srcNodeRef.selectedIndex || 0; // || 0 needed for when srcNodeRef is not a SELECT
				this._set("value", this.options[si >= 0 ? si : 0].value);
			}
			// Create the dropDown widget
			this.dropDown = new _SelectMenu({ id: this.id + "_menu", parentWidget: this });
			domClass.add(this.dropDown.domNode, this.baseClass.replace(/\s+|$/g, "Menu "));
		},

		_getMenuItemForOption: function(/*_FormSelectWidget.__SelectOption*/ option){
			// summary:
			//		For the given option, return the menu item that should be
			//		used to display it.  This can be overridden as needed
			if(!option.value && !option.label){
				// We are a separator (no label set for it)
				return new MenuSeparator({ownerDocument: this.ownerDocument});
			}else{
				// Just a regular menu option
				var click = lang.hitch(this, "_setValueAttr", option);
				var item = new MenuItem({
					option: option,
					label: (this.labelType === 'text' ? (option.label || '').toString()
						.replace(/&/g, '&amp;').replace(/</g, '&lt;') :
						option.label) || this.emptyLabel,
					onClick: click,
					ownerDocument: this.ownerDocument,
					dir: this.dir,
					textDir: this.textDir,
					disabled: option.disabled || false
				});
				item.focusNode.setAttribute("role", "option");
				return item;
			}
		},

		_addOptionItem: function(/*_FormSelectWidget.__SelectOption*/ option){
			// summary:
			//		For the given option, add an option to our dropdown.
			//		If the option doesn't have a value, then a separator is added
			//		in that place.
			if(this.dropDown){
				this.dropDown.addChild(this._getMenuItemForOption(option));
			}
		},

		_getChildren: function(){
			if(!this.dropDown){
				return [];
			}
			return this.dropDown.getChildren();
		},

		focus: function(){
			// Override _KeyNavMixin::focus(), which calls focusFirstChild().
			// We just want the standard form widget behavior.
			if(!this.disabled && this.focusNode.focus){
				try{
					this.focusNode.focus();
				}catch(e){
					/*squelch errors from hidden nodes*/
				}
			}
		},

		focusChild: function(/*dijit/_WidgetBase*/ widget){
			// summary:
			//		Sets the value to the given option, used during search by letter.
			// widget:
			//		Reference to option's widget
			// tags:
			//		protected
			if(widget){
				this.set('value', widget.option);
			}
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child widget.
			// tags:
			//		abstract extension
			var children = this._getChildren();
			return children.length ? children[0] : null;
		},

		_getLast: function(){
			// summary:
			//		Returns the last child widget.
			// tags:
			//		abstract extension
			var children = this._getChildren();
			return children.length ? children[children.length-1] : null;
		},

		childSelector: function(/*DOMNode*/ node){
			// Implement _KeyNavMixin.childSelector, to identify focusable child nodes.
			// If we allowed a dojo/query dependency from this module this could more simply be a string "> *"
			// instead of this function.

			var node = registry.byNode(node);
			return node && node.getParent() == this.dropDown;
		},

		onKeyboardSearch: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){
			// summary:
			//		When a key is pressed that matches a child item,
			//		this method is called so that a widget can take appropriate action is necessary.
			// tags:
			//		protected
			if(item){
				this.focusChild(item);
			}
		},

		_loadChildren: function(/*Boolean*/ loadMenuItems){
			// summary:
			//		Resets the menu and the length attribute of the button - and
			//		ensures that the label is appropriately set.
			// loadMenuItems: Boolean
			//		actually loads the child menu items - we only do this when we are
			//		populating for showing the dropdown.

			if(loadMenuItems === true){
				// this.inherited destroys this.dropDown's child widgets (MenuItems).
				// Avoid this.dropDown (Menu widget) having a pointer to a destroyed widget (which will cause
				// issues later in _setSelected). (see #10296)
				if(this.dropDown){
					delete this.dropDown.focusedChild;
					this.focusedChild = null;
				}
				if(this.options.length){
					this.inherited(arguments);
				}else{
					// Drop down menu is blank but add one blank entry just so something appears on the screen
					// to let users know that they are no choices (mimicing native select behavior)
					array.forEach(this._getChildren(), function(child){
						child.destroyRecursive();
					});
					var item = new MenuItem({
						ownerDocument: this.ownerDocument,
						label: this.emptyLabel
					});
					this.dropDown.addChild(item);
				}
			}else{
				this._updateSelection();
			}

			this._isLoaded = false;
			this._childrenLoaded = true;

			if(!this._loadingStore){
				// Don't call this if we are loading - since we will handle it later
				this._setValueAttr(this.value, false);
			}
		},

		_refreshState: function(){
			if(this._started){
				this.validate(this.focused);
			}
		},

		startup: function(){
			this.inherited(arguments);
			this._refreshState(); // after all _set* methods have run
		},

		_setValueAttr: function(value){
			this.inherited(arguments);
			domAttr.set(this.valueNode, "value", this.get("value"));
			this._refreshState();	// to update this.state
		},

		_setNameAttr: "valueNode",

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);
			this._refreshState();	// to update this.state
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this._set("required", value);
			this.focusNode.setAttribute("aria-required", value);
			this._refreshState();	// to update this.state
		},

		_setOptionsAttr: function(/*Array*/ options){
			this._isLoaded = false;
			this._set('options', options);
		},

		_setDisplay: function(/*String*/ newDisplay){
			// summary:
			//		sets the display for the given value (or values)

			var lbl = (this.labelType === 'text' ? (newDisplay || '')
					.replace(/&/g, '&amp;').replace(/</g, '&lt;') :
					newDisplay) || this.emptyLabel;
			this.containerNode.innerHTML = '<span role="option" aria-selected="true" class="dijitReset dijitInline ' + this.baseClass.replace(/\s+|$/g, "Label ") + '">' + lbl + '</span>';
		},

		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress, and whenever required/disabled state changes
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			//		Used when a select is initially set to no value and the user is required to
			//		set the value.

			var isValid = this.disabled || this.isValid(isFocused);
			this._set("state", isValid ? "" : (this._hasBeenBlurred ? "Error" : "Incomplete"));
			this.focusNode.setAttribute("aria-invalid", isValid ? "false" : "true");
			var message = isValid ? "" : this._missingMsg;
			if(message && this.focused && this._hasBeenBlurred){
				Tooltip.show(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
			}else{
				Tooltip.hide(this.domNode);
			}
			this._set("message", message);
			return isValid;
		},

		isValid: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Whether or not this is a valid value.  The only way a Select
			//		can be invalid is when it's required but nothing is selected.
			return (!this.required || this.value === 0 || !(/^\s*$/.test(this.value || ""))); // handle value is null or undefined
		},

		reset: function(){
			// summary:
			//		Overridden so that the state will be cleared.
			this.inherited(arguments);
			Tooltip.hide(this.domNode);
			this._refreshState();	// to update this.state
		},

		postMixInProperties: function(){
			// summary:
			//		set the missing message
			this.inherited(arguments);
			this._missingMsg = i18n.getLocalization("dijit.form", "validate", this.lang).missingMessage;
		},

		postCreate: function(){
			this.inherited(arguments);

			// stop mousemove from selecting text on IE to be consistent with other browsers
			this.own(on(this.domNode, "selectstart", function(evt){
				evt.preventDefault();
				evt.stopPropagation();
			}));

			this.domNode.setAttribute("aria-expanded", "false");

			// Prevent _KeyNavMixin from calling stopPropagation() on left and right arrow keys, thus breaking
			// navigation when Select inside Toolbar.
			var keyNavCodes = this._keyNavCodes;
			delete keyNavCodes[keys.LEFT_ARROW];
			delete keyNavCodes[keys.RIGHT_ARROW];
		},

		_setStyleAttr: function(/*String||Object*/ value){
			this.inherited(arguments);
			domClass.toggle(this.domNode, this.baseClass.replace(/\s+|$/g, "FixedWidth "), !!this.domNode.style.width);
		},

		isLoaded: function(){
			return this._isLoaded;
		},

		loadDropDown: function(/*Function*/ loadCallback){
			// summary:
			//		populates the menu
			this._loadChildren(true);
			this._isLoaded = true;
			loadCallback();
		},

		destroy: function(preserveDom){
			if(this.dropDown && !this.dropDown._destroyed){
				this.dropDown.destroyRecursive(preserveDom);
				delete this.dropDown;
			}
			Tooltip.hide(this.domNode);	// in case Select (or enclosing Dialog) destroyed while tooltip shown
			this.inherited(arguments);
		},

		_onFocus: function(){
			this.validate(true);	// show tooltip if second focus of required tooltip, but no selection
			// Note: not calling superclass _onFocus() to avoid _KeyNavMixin::_onFocus() setting tabIndex --> -1
		},

		_onBlur: function(){
			Tooltip.hide(this.domNode);
			this.inherited(arguments);
			this.validate(false);
		}
	});

	if(has("dojo-bidi")){
		Select = declare("dijit.form.Select", Select, {
			_setDisplay: function(/*String*/ newDisplay){
				this.inherited(arguments);
				this.applyTextDir(this.containerNode);
			}
		});
	}

	Select._Menu = _SelectMenu;	// for monkey patching

	// generic event helper to ensure the dropdown items are loaded before the real event handler is called
	function _onEventAfterLoad(method){
		return function(evt){
			if(!this._isLoaded){
				this.loadDropDown(lang.hitch(this, method, evt));
			}else{
				this.inherited(method, arguments);
			}
		};
	}
	Select.prototype._onContainerKeydown = _onEventAfterLoad("_onContainerKeydown");
	Select.prototype._onContainerKeypress = _onEventAfterLoad("_onContainerKeypress");

	return Select;
});

},
'dojo/json5/util':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	'./unicode'
], function (unicode) {
	return {
		isSpaceSeparator: function (c) {
			return typeof c === 'string' && unicode.Space_Separator.test(c);
		},
		isIdStartChar: function (c) {
			return typeof c === 'string' && ((c >= 'a' && c <= 'z') ||
				(c >= 'A' && c <= 'Z') ||
				(c === '$') || (c === '_') ||
				unicode.ID_Start.test(c));
		},
		isIdContinueChar: function (c) {
			return typeof c === 'string' && ((c >= 'a' && c <= 'z') ||
				(c >= 'A' && c <= 'Z') ||
				(c >= '0' && c <= '9') ||
				(c === '$') || (c === '_') ||
				(c === '\u200C') || (c === '\u200D') ||
				unicode.ID_Continue.test(c));
		},
		isDigit: function (c) {
			return typeof c === 'string' && /[0-9]/.test(c);
		},
		isHexDigit: function (c) {
			return typeof c === 'string' && /[0-9A-Fa-f]/.test(c);
		},
	};
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/QueryNearResources':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/toolbar/ext/_ComboTool,dijit/form/Button"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */


dojo.provide("ibm.tivoli.fwm.mxmap.toolbar.ext.QueryNearResources");

dojo.require("ibm.tivoli.fwm.mxmap.toolbar.ext._ComboTool");
dojo.require("dijit.form.Button");

/**
 * Query nearby resources tool
 */
dojo.declare("ibm.tivoli.fwm.mxmap.toolbar.ext.QueryNearResources", ibm.tivoli.fwm.mxmap.toolbar.ext._ComboTool, {
	label: "Nearby resources",
	iconClass: "basicMapToolbarBtn nearbyResourcesMapToolbarBtn",
	map: null,
	nearbyCrewsLabel: "",
	nearbyLaborsLabel: "",
	allLaborAndCrewsLabel: "",
	laborAndCrewsOnShiftLabel: "",
	constructor: function(params)
	{
		dojo.mixin(this, params);
		var _label = ibm.tivoli.fwm.i18n.getMaxMsg("map", "nearresourcestool");
		this.label = _label || this.label;
		this.nearbyCrewsLabel = ibm.tivoli.fwm.i18n.getMaxMsg("map", "nearbycrews");
		this.nearbyLaborsLabel = ibm.tivoli.fwm.i18n.getMaxMsg("map", "nearbylabors");
		this.laborAndCrewsOnShiftLabel = ibm.tivoli.fwm.i18n.getMaxMsg("map", "laborandcrewsonshift");
		this.allLaborAndCrewsLabel = ibm.tivoli.fwm.i18n.getMaxMsg("map", "alllaborandcrews");
		
		this._initMenuItems();

		this.addSubscription("onMapRefresh_" + this.map.getId(), dojo.hitch(this, this._onMapRefresh));
	},
	_initMenuItems: function()
	{
		this.addMenuItem("onSameShiftAsUser", this.laborAndCrewsOnShiftLabel, true);
		this.addMenuItem("all", this.allLaborAndCrewsLabel);
	},
	updateLayers: function(crewsData, laborsData, refreshOptions)
	{
		var isAutomaticRefresh = refreshOptions && refreshOptions.automatic;
		var avoidLayerEnabled = false;
		if (refreshOptions) // if this parameter exists, it's a refresh and we don't enable the layers
		{
			avoidLayerEnabled = true;
		}
		if (crewsData && crewsData.length > 0)
		{
			this._sendEventToLayer(this.nearbyCrewsLabel, crewsData, avoidLayerEnabled);
		}
		else
		{
			this._sendEventToRemoveLayer(this.nearbyCrewsLabel);
		}
		if (laborsData && laborsData.length > 0)
		{
			this._sendEventToLayer(this.nearbyLaborsLabel, laborsData, avoidLayerEnabled);
		}
		else
		{
			this._sendEventToRemoveLayer(this.nearbyLaborsLabel);
		}
		if (isAutomaticRefresh != true && laborsData.length == 0 && crewsData.length == 0)
		{
			this.setActive(false);
			this.map.getMaximo().showMessage("mapserver", "noresourcesinarea");
		}
	},
	disable: function()
	{

	},
	destroy: function()
	{
		this.destroyRecursive();
	},
	// util method - gets an array of lbs data to send to spatial for conversion
	// returns null if records is null or any record in records does not have
	// lbsdata.
	_getLBSData: function(records)
	{
		var array = [];
		if (records)
		{
			for ( var index in records)
			{
				if (records[index].lbsdata)
				{
					array.push(records[index].lbsdata);
				}
				else
				{
					console.warn("[QueryNearResouces] Records has a record without lbsdata.", records);
					return null;
				}
			}
		}
		else
		{
			console.warn("[QueryNearResouces] Records has a record without lbsdata.", records);
			return null;
		}
		return array;
	},

	// util function to add the records in the new layer.
	_sendEventToLayer: function(layerName, layerData, avoidLayerEnabled)
	{
		dojo.publish("addRecordsToLayer_" + this.map.getId(), [ layerName, layerData, true, null, null, avoidLayerEnabled ]);
	},
	_sendEventToRemoveLayer: function(layerName)
	{
		dojo.publish("removeLayer_" + this.map.getId(), [ layerName ]);
	},
	// Enables the Nearby Resources tool (show nearby resources)
	executeOn: function(params)
	{
		var fct = function(data)
		{
			if (data.status == "TOOMANYRECORDS")
			{
				this.setActive(false);
				this.map.getMaximo().showMessage(data.error.group, data.error.key, [data.error.params]);
				return;
			}
			var crewsData = data.crews;
			var laborsData = data.labors;

			/*
			 * just a small perf improvement to cache all the LBS points
			 * conversion to current coordsystem at once
			 */
			
			var toProject = [];
			if (crewsData != null)
				toProject.join(this._getLBSData(crewsData));
			if (laborsData != null)
				toProject.join(this._getLBSData(laborsData));
			if (toProject.length > 0)
			{
				this.map.getAllPointsFromWGS84(toProject, dojo.hitch(this, function()
				{
					/*
					 * do not update the crews/labor data. Map is aware these
					 * are WGS84 if we convert it here, it will get converted
					 * again later in the code, so we need to keep it in wgs84
					 */
					this.updateLayers(crewsData, laborsData, params.refreshOptions);
				}), dojo.hitch(this, function(error)
				{
					if (error && error.msgkey)
					{
						this.map.getMaximo().showMessage(error.msggroup, error.msgkey);
					}
				}));
			}
			else
			{
				this.updateLayers(crewsData, laborsData, params.refreshOptions);
			}
		};

		var fctErr = function(data)
		{
			console.warn("[QueryNearResources] Error querying nearby resources", data);
		};

		var bounds = this.map.getBounds();
		var auxFct = function(ps)
		{
			var xlatedBounds = this.map.getBoundingBoxFromPoints(ps);
			var queryOption = (params.menuItem != undefined) ? params.menuItem.id : "all";
			var queryParams = {"bounds": xlatedBounds, "filterOption": queryOption};
			this.map.getMaximo().getCrewLaborByQueryParams(dojo.hitch(this, fct), dojo.hitch(this, fctErr), queryParams);
		};
		// resources always use LBS that is in wgs84 so we need to convert the
		// boundaries to this coordinate system
		this.map.getAllPointsInWGS84([ bounds.sw, bounds.ne ], dojo.hitch(this, auxFct));
	},
	// Disables the Nearby Resources tool (hides nearby resources)
	executeOff: function()
	{
		this._sendEventToRemoveLayer(this.nearbyLaborsLabel);
		this._sendEventToRemoveLayer(this.nearbyCrewsLabel);
	},
	_onMapRefresh: function(refreshOpts)
	{
		if (this.isActive() == true)
		{
			this.executeOff();
			this.executeOn({refreshOptions: refreshOpts});
		}
	}
});

});

},
'dijit/_KeyNavMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/keys", // keys.END keys.HOME, keys.LEFT_ARROW etc.
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dijit/registry",
	"dijit/_FocusMixin"        // to make _onBlur() work
], function(array, declare, domAttr, keys, lang, on, registry, _FocusMixin){

	// module:
	//		dijit/_KeyNavMixin

	return declare("dijit._KeyNavMixin", _FocusMixin, {
		// summary:
		//		A mixin to allow arrow key and letter key navigation of child or descendant widgets.
		//		It can be used by dijit/_Container based widgets with a flat list of children,
		//		or more complex widgets like dijit/Tree.
		//
		//		To use this mixin, the subclass must:
		//
		//			- Implement  _getNext(), _getFirst(), _getLast(), _onLeftArrow(), _onRightArrow()
		//			  _onDownArrow(), _onUpArrow() methods to handle home/end/left/right/up/down keystrokes.
		//			  Next and previous in this context refer to a linear ordering of the descendants used
		//			  by letter key search.
		//			- Set all descendants' initial tabIndex to "-1"; both initial descendants and any
		//			  descendants added later, by for example addChild()
		//			- Define childSelector to a function or string that identifies focusable descendant widgets
		//
		//		Also, child widgets must implement a focus() method.

		/*=====
		 // focusedChild: [protected readonly] Widget
		 //		The currently focused child widget, or null if there isn't one
		 focusedChild: null,

		 // _keyNavCodes: Object
		 //		Hash mapping key code (arrow keys and home/end key) to functions to handle those keys.
		 //		Usually not used directly, as subclasses can instead override _onLeftArrow() etc.
		 _keyNavCodes: {},
		 =====*/

		// tabIndex: String
		//		Tab index of the container; same as HTML tabIndex attribute.
		//		Note then when user tabs into the container, focus is immediately
		//		moved to the first item in the container.
		tabIndex: "0",

		// childSelector: [protected abstract] Function||String
		//		Selector (passed to on.selector()) used to identify what to treat as a child widget.   Used to monitor
		//		focus events and set this.focusedChild.   Must be set by implementing class.   If this is a string
		//		(ex: "> *") then the implementing class must require dojo/query.
		childSelector: null,

		postCreate: function(){
			this.inherited(arguments);

			// Set tabIndex on this.domNode.  Will be automatic after #7381 is fixed.
			domAttr.set(this.domNode, "tabIndex", this.tabIndex);

			if(!this._keyNavCodes){
				var keyCodes = this._keyNavCodes = {};
				keyCodes[keys.HOME] = lang.hitch(this, "focusFirstChild");
				keyCodes[keys.END] = lang.hitch(this, "focusLastChild");
				keyCodes[this.isLeftToRight() ? keys.LEFT_ARROW : keys.RIGHT_ARROW] = lang.hitch(this, "_onLeftArrow");
				keyCodes[this.isLeftToRight() ? keys.RIGHT_ARROW : keys.LEFT_ARROW] = lang.hitch(this, "_onRightArrow");
				keyCodes[keys.UP_ARROW] = lang.hitch(this, "_onUpArrow");
				keyCodes[keys.DOWN_ARROW] = lang.hitch(this, "_onDownArrow");
			}

			var self = this,
				childSelector = typeof this.childSelector == "string"
					? this.childSelector
					: lang.hitch(this, "childSelector");
			this.own(
				on(this.domNode, "keypress", lang.hitch(this, "_onContainerKeypress")),
				on(this.domNode, "keydown", lang.hitch(this, "_onContainerKeydown")),
				on(this.domNode, "focus", lang.hitch(this, "_onContainerFocus")),
				on(this.containerNode, on.selector(childSelector, "focusin"), function(evt){
					self._onChildFocus(registry.getEnclosingWidget(this), evt);
				})
			);
		},

		_onLeftArrow: function(){
			// summary:
			//		Called on left arrow key, or right arrow key if widget is in RTL mode.
			//		Should go back to the previous child in horizontal container widgets like Toolbar.
			// tags:
			//		extension
		},

		_onRightArrow: function(){
			// summary:
			//		Called on right arrow key, or left arrow key if widget is in RTL mode.
			//		Should go to the next child in horizontal container widgets like Toolbar.
			// tags:
			//		extension
		},

		_onUpArrow: function(){
			// summary:
			//		Called on up arrow key. Should go to the previous child in vertical container widgets like Menu.
			// tags:
			//		extension
		},

		_onDownArrow: function(){
			// summary:
			//		Called on down arrow key. Should go to the next child in vertical container widgets like Menu.
			// tags:
			//		extension
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused.

			// Leverage _getNextFocusableChild() to skip disabled children
			return this._getNextFocusableChild(null, 1);	// dijit/_WidgetBase
		},

		_getLastFocusableChild: function(){
			// summary:
			//		Returns last child that can be focused.

			// Leverage _getNextFocusableChild() to skip disabled children
			return this._getNextFocusableChild(null, -1);	// dijit/_WidgetBase
		},

		focusFirstChild: function(){
			// summary:
			//		Focus the first focusable child in the container.
			// tags:
			//		protected

			this.focusChild(this._getFirstFocusableChild());
		},

		focusLastChild: function(){
			// summary:
			//		Focus the last focusable child in the container.
			// tags:
			//		protected

			this.focusChild(this._getLastFocusableChild());
		},

		focusChild: function(/*dijit/_WidgetBase*/ widget, /*Boolean*/ last){
			// summary:
			//		Focus specified child widget.
			// widget:
			//		Reference to container's child widget
			// last:
			//		If true and if widget has multiple focusable nodes, focus the
			//		last one instead of the first one
			// tags:
			//		protected

			if(!widget){
				return;
			}

			if(this.focusedChild && widget !== this.focusedChild){
				this._onChildBlur(this.focusedChild);	// used to be used by _MenuBase
			}
			widget.set("tabIndex", this.tabIndex);	// for IE focus outline to appear, must set tabIndex before focus
			widget.focus(last ? "end" : "start");

			// Don't set focusedChild here, because the focus event should trigger a call to _onChildFocus(), which will
			// set it.   More importantly, _onChildFocus(), which may be executed asynchronously (after this function
			// returns) needs to know the old focusedChild to set its tabIndex to -1.
		},

		_onContainerFocus: function(evt){
			// summary:
			//		Handler for when the container itself gets focus.
			// description:
			//		Initially the container itself has a tabIndex, but when it gets
			//		focus, switch focus to first child.
			//
			//		TODO for 2.0 (or earlier): Instead of having the container tabbable, always maintain a single child
			//		widget as tabbable, Requires code in startup(), addChild(), and removeChild().
			//		That would avoid various issues like #17347.
			// tags:
			//		private

			// Note that we can't use _onFocus() because switching focus from the
			// _onFocus() handler confuses the focus.js code
			// (because it causes _onFocusNode() to be called recursively).
			// Also, _onFocus() would fire when focus went directly to a child widget due to mouse click.

			// Ignore spurious focus events:
			//	1. focus on a child widget bubbles on FF
			//	2. on IE, clicking the scrollbar of a select dropdown moves focus from the focused child item to me
			if(evt.target !== this.domNode || this.focusedChild){
				return;
			}

			this.focus();
		},

		_onFocus: function(){
			// When the container gets focus by being tabbed into, or a descendant gets focus by being clicked,
			// set the container's tabIndex to -1 (don't remove as that breaks Safari 4) so that tab or shift-tab
			// will go to the fields after/before the container, rather than the container itself
			domAttr.set(this.domNode, "tabIndex", "-1");

			this.inherited(arguments);
		},

		_onBlur: function(evt){
			// When focus is moved away the container, and its descendant (popup) widgets,
			// then restore the container's tabIndex so that user can tab to it again.
			// Note that using _onBlur() so that this doesn't happen when focus is shifted
			// to one of my child widgets (typically a popup)

			// TODO: for 2.0 consider changing this to blur whenever the container blurs, to be truthful that there is
			// no focused child at that time.

			domAttr.set(this.domNode, "tabIndex", this.tabIndex);
			if(this.focusedChild){
				this.focusedChild.set("tabIndex", "-1");
				this.lastFocusedChild = this.focusedChild;
				this._set("focusedChild", null);
			}
			this.inherited(arguments);
		},

		_onChildFocus: function(/*dijit/_WidgetBase*/ child){
			// summary:
			//		Called when a child widget gets focus, either by user clicking
			//		it, or programatically by arrow key handling code.
			// description:
			//		It marks that the current node is the selected one, and the previously
			//		selected node no longer is.

			if(child && child != this.focusedChild){
				if(this.focusedChild && !this.focusedChild._destroyed){
					// mark that the previously focusable node is no longer focusable
					this.focusedChild.set("tabIndex", "-1");
				}

				// mark that the new node is the currently selected one
				child.set("tabIndex", this.tabIndex);
				this.lastFocused = child;		// back-compat for Tree, remove for 2.0
				this._set("focusedChild", child);
			}
		},

		_searchString: "",
		// multiCharSearchDuration: Number
		//		If multiple characters are typed where each keystroke happens within
		//		multiCharSearchDuration of the previous keystroke,
		//		search for nodes matching all the keystrokes.
		//
		//		For example, typing "ab" will search for entries starting with
		//		"ab" unless the delay between "a" and "b" is greater than multiCharSearchDuration.
		multiCharSearchDuration: 1000,

		onKeyboardSearch: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){
			// summary:
			//		When a key is pressed that matches a child item,
			//		this method is called so that a widget can take appropriate action is necessary.
			// tags:
			//		protected
			if(item){
				this.focusChild(item);
			}
		},

		_keyboardSearchCompare: function(/*dijit/_WidgetBase*/ item, /*String*/ searchString){
			// summary:
			//		Compares the searchString to the widget's text label, returning:
			//
			//			* -1: a high priority match  and stop searching
			//		 	* 0: not a match
			//		 	* 1: a match but keep looking for a higher priority match
			// tags:
			//		private

			var element = item.domNode,
				text = item.label || (element.focusNode ? element.focusNode.label : '') || element.innerText || element.textContent || "",
				currentString = text.replace(/^\s+/, '').substr(0, searchString.length).toLowerCase();

			return (!!searchString.length && currentString == searchString) ? -1 : 0; // stop searching after first match by default
		},

		_onContainerKeydown: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then it's handled here.
			// tags:
			//		private

			var func = this._keyNavCodes[evt.keyCode];
			if(func){
				func(evt, this.focusedChild);
				evt.stopPropagation();
				evt.preventDefault();
				this._searchString = ''; // so a DOWN_ARROW b doesn't search for ab
			}else if(evt.keyCode == keys.SPACE && this._searchTimer && !(evt.ctrlKey || evt.altKey || evt.metaKey)){
				evt.stopImmediatePropagation(); // stop a11yclick and _HasDropdown from seeing SPACE if we're doing keyboard searching
				evt.preventDefault(); // stop IE from scrolling, and most browsers (except FF) from sending keypress
				this._keyboardSearch(evt, ' ');
			}
		},

		_onContainerKeypress: function(evt){
			// summary:
			//		When a printable key is pressed, it's handled here, searching by letter.
			// tags:
			//		private

			// Ignore:
			// 		- duplicate events on firefox (ex: arrow key that will be handled by keydown handler)
			//		- control sequences like CMD-Q.
			//		- the SPACE key (only occurs on FF)
			//
			// Note: if there's no search in progress, then SPACE should be ignored.   If there is a search
			// in progress, then SPACE is handled in _onContainerKeyDown.
			if(evt.charCode <= keys.SPACE || evt.ctrlKey || evt.altKey || evt.metaKey){
				return;
			}

			evt.preventDefault();
			evt.stopPropagation();

			this._keyboardSearch(evt, String.fromCharCode(evt.charCode).toLowerCase());
		},

		_keyboardSearch: function(/*Event*/ evt, /*String*/ keyChar){
			// summary:
			//		Perform a search of the widget's options based on the user's keyboard activity
			// description:
			//		Called on keypress (and sometimes keydown), searches through this widget's children
			//		looking for items that match the user's typed search string.  Multiple characters
			//		typed within 1 sec of each other are combined for multicharacter searching.
			// tags:
			//		private
			var
				matchedItem = null,
				searchString,
				numMatches = 0,
				search = lang.hitch(this, function(){
					if(this._searchTimer){
						this._searchTimer.remove();
					}
					this._searchString += keyChar;
					var allSameLetter = /^(.)\1*$/.test(this._searchString);
					var searchLen = allSameLetter ? 1 : this._searchString.length;
					searchString = this._searchString.substr(0, searchLen);
					// commented out code block to search again if the multichar search fails after a smaller timeout
					//this._searchTimer = this.defer(function(){ // this is the "failure" timeout
					//	this._typingSlowly = true; // if the search fails, then treat as a full timeout
					//	this._searchTimer = this.defer(function(){ // this is the "success" timeout
					//		this._searchTimer = null;
					//		this._searchString = '';
					//	}, this.multiCharSearchDuration >> 1);
					//}, this.multiCharSearchDuration >> 1);
					this._searchTimer = this.defer(function(){ // this is the "success" timeout
						this._searchTimer = null;
						this._searchString = '';
					}, this.multiCharSearchDuration);
					var currentItem = this.focusedChild || null;
					if(searchLen == 1 || !currentItem){
						currentItem = this._getNextFocusableChild(currentItem, 1); // skip current
						if(!currentItem){
							return;
						} // no items
					}
					var stop = currentItem;
					do{
						var rc = this._keyboardSearchCompare(currentItem, searchString);
						if(!!rc && numMatches++ == 0){
							matchedItem = currentItem;
						}
						if(rc == -1){ // priority match
							numMatches = -1;
							break;
						}
						currentItem = this._getNextFocusableChild(currentItem, 1);
					}while(currentItem && currentItem != stop);
					// commented out code block to search again if the multichar search fails after a smaller timeout
					//if(!numMatches && (this._typingSlowly || searchLen == 1)){
					//	this._searchString = '';
					//	if(searchLen > 1){
					//		// if no matches and they're typing slowly, then go back to first letter searching
					//		search();
					//	}
					//}
				});

			search();
			// commented out code block to search again if the multichar search fails after a smaller timeout
			//this._typingSlowly = false;
			this.onKeyboardSearch(matchedItem, evt, searchString, numMatches);
		},

		_onChildBlur: function(/*dijit/_WidgetBase*/ /*===== widget =====*/){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			//		Used to be used by MenuBase.js (remove for 2.0)
			// tags:
			//		protected
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable descendant, compared to "child".
			//		Implements and extends _KeyNavMixin._getNextFocusableChild() for a _Container.
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension

			var wrappedValue = child;
			do{
				if(!child){
					child = this[dir > 0 ? "_getFirst" : "_getLast"]();
					if(!child){ break; }
				}else{
					child = this._getNext(child, dir);
				}
				if(child != null && child != wrappedValue && child.isFocusable()){
					return child;	// dijit/_WidgetBase
				}
			}while(child != wrappedValue);
			// no focusable child found
			return null;	// dijit/_WidgetBase
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child.
			// tags:
			//		abstract extension

			return null;	// dijit/_WidgetBase
		},

		_getLast: function(){
			// summary:
			//		Returns the last descendant.
			// tags:
			//		abstract extension

			return null;	// dijit/_WidgetBase
		},

		_getNext: function(child, dir){
			// summary:
			//		Returns the next descendant, compared to "child".
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension

			if(child){
				child = child.domNode;
				while(child){
					child = child[dir < 0 ? "previousSibling" : "nextSibling"];
					if(child  && "getAttribute" in child){
						var w = registry.byNode(child);
						if(w){
							return w; // dijit/_WidgetBase
						}
					}
				}
			}
			return null;	// dijit/_WidgetBase
		}
	});
});

},
'dojo/store/util/QueryResults':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["../../_base/array", "../../_base/lang", "../../when"
], function(array, lang, when){

// module:
//		dojo/store/util/QueryResults

var QueryResults = function(results){
	// summary:
	//		A function that wraps the results of a store query with additional
	//		methods.
	// description:
	//		QueryResults is a basic wrapper that allows for array-like iteration
	//		over any kind of returned data from a query.  While the simplest store
	//		will return a plain array of data, other stores may return deferreds or
	//		promises; this wrapper makes sure that *all* results can be treated
	//		the same.
	//
	//		Additional methods include `forEach`, `filter` and `map`.
	// results: Array|dojo/promise/Promise
	//		The result set as an array, or a promise for an array.
	// returns:
	//		An array-like object that can be used for iterating over.
	// example:
	//		Query a store and iterate over the results.
	//
	//	|	store.query({ prime: true }).forEach(function(item){
	//	|		//	do something
	//	|	});

	if(!results){
		return results;
	}

	var isPromise = !!results.then;
	// if it is a promise it may be frozen
	if(isPromise){
		results = lang.delegate(results);
	}
	function addIterativeMethod(method){
		// Always add the iterative methods so a QueryResults is
		// returned whether the environment is ES3 or ES5
		results[method] = function(){
			var args = arguments;
			var result = when(results, function(results){
				Array.prototype.unshift.call(args, results);
				return QueryResults(array[method].apply(array, args));
			});
			// forEach should only return the result of when()
			// when we're wrapping a promise
			if(method !== "forEach" || isPromise){
				return result;
			}
		};
	}

	addIterativeMethod("forEach");
	addIterativeMethod("filter");
	addIterativeMethod("map");
	if(results.total == null){
		results.total = when(results, function(results){
			return results.length;
		});
	}
	return results; // Object
};

lang.setObject("dojo.store.util.QueryResults", QueryResults);

return QueryResults;

});

},
'ibm/tivoli/fwm/mxmap/toolbar/ToolbarSeparator':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2014,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["dojo/_base/declare", "dijit/_Templated"], function(declare, _Templated) {
	return declare([_Templated], {
		// summary:
		//		A spacer between two `dijit.Toolbar` items
		templateString: '<div class="mapTbSep dijitInline" waiRole="presentation"></div>',
		postCreate: function(){ dojo.setSelectable(this.domNode, false); },
		isFocusable: function(){
			// summary:
			//		This widget isn't focusable, so pass along that fact.
			// tags:
			//		protected
			return false;
		}

	});

});

},
'dijit/form/_FormWidget':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/sniff", // has("dijit-legacy-requires"), has("msapp")
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/ready",
	"../_Widget",
	"../_CssStateMixin",
	"../_TemplatedMixin",
	"./_FormWidgetMixin"
], function(declare, has, kernel, ready, _Widget, _CssStateMixin, _TemplatedMixin, _FormWidgetMixin){

	// module:
	//		dijit/form/_FormWidget

	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/form/_FormValueWidget"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.form._FormWidget", [_Widget, _TemplatedMixin, _CssStateMixin, _FormWidgetMixin], {
		// summary:
		//		Base class for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,
		//		which can be children of a `<form>` node or a `dijit/form/Form` widget.
		//
		// description:
		//		Represents a single HTML element.
		//		All these widgets should have these attributes just like native HTML input elements.
		//		You can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.
		//
		//		They also share some common methods.

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.  Use set('disabled', ...) instead.
			kernel.deprecated("setDisabled(" + disabled + ") is deprecated. Use set('disabled'," + disabled + ") instead.", "", "2.0");
			this.set('disabled', disabled);
		},

		setValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('value', ...) instead.
			kernel.deprecated("dijit.form._FormWidget:setValue(" + value + ") is deprecated.  Use set('value'," + value + ") instead.", "", "2.0");
			this.set('value', value);
		},

		getValue: function(){
			// summary:
			//		Deprecated.  Use get('value') instead.
			kernel.deprecated(this.declaredClass + "::getValue() is deprecated. Use get('value') instead.", "", "2.0");
			return this.get('value');
		},

		postMixInProperties: function(){
			// Setup name=foo string to be referenced from the template (but only if a name has been specified).
			// Unfortunately we can't use _setNameAttr to set the name in IE due to IE limitations, see #8484, #8660.
			// But when IE6 and IE7 are desupported, then we probably don't need this anymore, so should remove it in 2.0.
			// Also, don't do this for Windows 8 Store Apps because it causes a security exception (see #16452).
			// Regarding escaping, see heading "Attribute values" in
			// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
			this.nameAttrSetting = (this.name && !has("msapp")) ? ('name="' + this.name.replace(/"/g, "&quot;") + '"') : '';
			this.inherited(arguments);
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/layers/Layer':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/_Base", 
	"ibm/tivoli/fwm/mxmap/ImageLibraryManager"
	], function(declare, _Base, ImageLibraryManager) {

	ibm.tivoli.fwm.mxmap.layers = {
			LayerType: {
				LAYER: 0,
				SYMBOLOGY: 1,
				LEGEND: 2,
				VIRTUAL_LAYER: 4
			}
	};
	return declare([_Base], {
		_layerName: null,
		_layerId: null,
		_records: null,
		_map: null,
		// Whether this layer is currently active or not
		_disabled: null,
		// Array with the sublayers
		_childLayers: null,
		// Pointer to the parent layer
		_parentLayer: null,
		_leftIconURL: null,
		_rightIconURL: null,
		_rightIconSet: false,
		_childrenTitle: null,
		layerRecords: null,
		_mboMarkerOptions: null,
		_isAddingRecord: false,
		_recordQueueParallel: null,
		// When a GISable record's lat/lng relies only on LBS (labors and crews),
		// both "gisdata" and "lbsdata" properties of the record contain the same lat/lng values.
		// However, some records (Assets) may have static lat/lng (gisdata) and dynamic lat/lng (lbsdata)
		// For the latter situations, the user may want to view either LBS position or static position,
		// so the variable below indicates whether records from this layer are to be displayed using LBS position
		// or static position. A Map tool can set this variable. Of course, this variable only makes sense if
		// this layer's records are based on LBS.
		_useLBSPosition: false,
		constructor: function(options)
		{
			dojo.mixin(this, options);
			this._childLayers = {};
			this._recordQueueParallel = [];
			this._layerId = options.layerId;

			this._mboMarkerOptions = new this.MboMarkerOptionsTable();

			this._map = options.map;
			this.layerRecords = [];
			this._disabled = true;
			this._layerName = this.layerName;
			this._childrenTitle = options.childrenTitle;
			this._parentLayer = options.parentLayer;
			var libraryManager = ImageLibraryManager.getImageLibraryManager();
			this._rightIconURL = libraryManager.getLayerDetailsOffImageInfo().getImageURL();
			if (this.layerType == ibm.tivoli.fwm.mxmap.layers.LayerType.LAYER)
			{
				this.layerConf = this.symbManager.getLayerConfigById(this._layerId);
				if (!this.layerConf)
				{
					console.warn("[Layer] No conf for ", this._layerId);
					// TODO Return others Layer
					this.layerConf = this.symbManager.getDefaultLayerConfigFor(this._layerId);
					// return;
				}
				this._layerName = this.layerConf.label;
				this._childrenTitle = this.layerConf.symbologyTitle;
				// Get the array of symbology configurations for this layer
				var symbologyConfigArray = this.symbManager.getSymbologyConfigArrayByLayer(this.layerConf);
				var firstSymbology = true;
				for ( var symbologyId in symbologyConfigArray)
				{
					// For each symbology configuration in the array, build a
					// symbology for this layer (a child layer)
					var symbologyConfig = symbologyConfigArray[symbologyId];
					var symbologyType = symbologyConfig.type;
					var symbologyLabel = symbologyConfig.label;
					var symbologyChildrenTitle = symbologyConfig.legendTitle;
					var symbology = this.createNewChildLayer({
						layerName: symbologyLabel,
						layerId: symbologyId.toLowerCase(),
						layerConf: symbologyConfig,
						map: this._map,
						layerType: ibm.tivoli.fwm.mxmap.layers.LayerType.SYMBOLOGY,
						symbologyType: symbologyType,
						childrenTitle: symbologyChildrenTitle
					});
					if (firstSymbology == true)
					{
						// At least one symbology must be enabled, so enable the
						// first symbology in each layer
						symbology.enable();
						symbology.setDefault();
						this.symbManager.setActiveSymbology(this.layerConf.id, symbologyConfig);
						firstSymbology = false;
					}

					// Get the array of legend configurations for the symbology
					var legendConfigArray = this.symbManager.getLegendConfigArrayBySymbology(symbologyConfig);
					for ( var legendId in legendConfigArray)
					{
						var legendConfig = legendConfigArray[legendId];

						var legendLabel = legendConfig.label;
						var legendSymbol = this.symbManager.fixSymbolUrl(legendConfig.symbol);
						var legend = symbology.createNewChildLayer({
							layerConf: legendConfig,
							layerName: legendLabel,
							layerId: legendId.toLowerCase(),
							map: this._map,
							layerType: ibm.tivoli.fwm.mxmap.layers.LayerType.LEGEND,
							symbol: legendSymbol
						});
					}
				}
				// Checks if there is a default symbology configured for this layer
				// If so, enable this symbology
				var defaultSymbology = this.symbManager.getDefaultSymbologyForLayer(this.layerConf.id);
				if (defaultSymbology != null)
				{
					var symbology = null;
					symbology = dojo.filter(this.getChildren(), function(child)
							{
						return (child.layerId == defaultSymbology);
							});
					if (symbology.length > 0)
					{
						symbology[0].toggleState();
						symbology[0].setDefault();
						this.symbManager.setActiveSymbology(this.layerConf.id, symbologyConfigArray[defaultSymbology]);
					}
				}
			}

			this.init();
		},
		/**
		 * Sets the left icon (on/off icon)
		 */
		init: function()
		{
			this._setLeftIconURL();
		},
		/**
		 * Sets the left icon (on/off icon)
		 */
		_setLeftIconURL: function()
		{
			var libraryManager = ImageLibraryManager.getImageLibraryManager();
			if (this.isDisabled())
			{
				this._leftIconURL = libraryManager.getLayerOffImageInfo().getImageURL();
			}
			else
			{
				this._leftIconURL = libraryManager.getLayerOnImageInfo().getImageURL();
			}
		},
		/**
		 * Sets the right icon (submenu icon)
		 */
		_setRightIconURL: function()
		{
			var libraryManager = ImageLibraryManager.getImageLibraryManager();
			this._rightIconURL = libraryManager.getLayerDetailsImageInfo().getImageURL();
			this._rightIconSet = true;
		},
		getLeftIconURL: function()
		{
			return this._leftIconURL;
		},
		getRightIconURL: function()
		{
			return this._rightIconURL;
		},
		/**
		 * Retrieves the layer name
		 */
		getLayerName: function()
		{
			return this._layerName;
		},
		getLayerId: function()
		{
			return this._layerId;
		},
		getLayerConfig: function()
		{
			return this.layerConf;
		},
		getMXRecordSet: function()
		{
			return this._records;
		},
		/**
		 * Enables or disables this layer
		 */
		toggleState: function()
		{
			if (this.isDisabled())
			{
				this.enable();
			}
			else
			{
				this.disable();
			}
		},
		/**
		 * Shows records on the map - should be used to show a brand new set of
		 * records. this method is called to show records for the first time.
		 */
		show: function()
		{
			this._disabled = false;
			if (this._records != null)
			{
				this._records.showMXRecordsOnMap();
			}
		},
		addRecord: function(mboInfo, markerOptions)
		{
			// There cannot be reentrancy here, so we stack the calls and
			// execute addRecord with the queued parameters in the end
			if (this._isAddingRecord == true)
			{
				// Put the parameters in the queue and return
				// When the current execution finishes, the queued data will be processed
				this._recordQueueParallel.push({
					mboInfo: mboInfo,
					markerOptions: markerOptions
				});
				return;
			}

			this._isAddingRecord = true;
			var _exists = this._getRecordIndex(mboInfo);
			if (_exists!=null)
			{				
				console.log("conta",this.layerRecords[_exists].counter);
				mboInfo.counter=this.layerRecords[_exists].counter;
				this.map.removeMboMarkerFromMap(this.layerRecords[_exists], this._layerId);
				mboInfo.counter++;
				this.layerRecords[_exists]=mboInfo;

			}
			else
			{
				mboInfo.counter = 1;
				this.layerRecords.push(mboInfo);
			}

			if (!this.isDisabled())
			{
				// Add the marker first and only then check if it should be there or removed
				// This is because the marker must be created at least once so that it exists in the record cache
				// If a record is part of the current query, it must always exist. It can be hidden though, but it must always exist.
				this.map.addMboMarker(mboInfo, markerOptions, this._layerId);
				// Hide marker if legend it disabled
				var layersManager = this._map.getLayersManager();
				var legend = layersManager.getLegendForRecord(mboInfo, this);
				if(layersManager.isLegendEnabledForRecord(legend) == false)
				{
					this._map.removeMboMarkerFromMap(mboInfo, this._layerId);
				}
			}
			this._isAddingRecord = false;
			// Run queued calls, if any
			this.executeQueuedParallel();
		},
		removeRecord: function(mboInfo)
		{
			var recordIndex = this._getRecordIndex(mboInfo);
			if(recordIndex != null)
			{
				var counter = --this.layerRecords[recordIndex].counter;
				if (counter == 0)
				{
					this.layerRecords.splice(recordIndex, 1);
					this.map.removeMboMarkerFromMap(mboInfo, this._layerId);
				}
				return counter;
			}
		},
		_getRecordIndex: function(mboInfo)
		{
			var layersManager = this._map.getLayersManager();
			for ( var i = 0; i < this.layerRecords.length; ++i)
			{
				if (layersManager.areMboInfosEqual(this.layerRecords[i], mboInfo))
				{
					return i;
				}
			}
			return null;
		},
		hasRecord: function(mboInfo)
		{
			return (this._getRecordIndex(mboInfo) != null) ? true : false;
		},
		hasRecords: function()
		{
			return this.layerRecords.length > 0;
		},
		isVisibleInUI: function()
		{
			if (this.layerType == ibm.tivoli.fwm.mxmap.layers.LayerType.LAYER)
			{
				return this.hasRecords();
			}
			else
			{
				return true;
			}
		},
		/**
		 * Adds records to the layer
		 */
		addMXRecordSet: function(anotherMXRecordSet)
		{
			if (this._records != null)
			{
				this._records.addMXRecordSet(anotherMXRecordSet);
			}

		},
		/**
		 * Removes records from the layer
		 */
		removeMXRecordSetData: function()
		{
			if (this._records != null)
			{
				this._records.removeMXRecordsFromMap();
			}
			else
			{
				if (dojo.config.fwm.debug == true)
				{
					console.log("[Layer] _records is null");
				}
			}
			if (this.layerRecords != null)
			{
				for (var i = 0; i < this.layerRecords.length; i++)
				{
					var mboInfo = this.layerRecords[i];
					this._map.removeMboMarker(mboInfo, this._layerId);
				}
				this.layerRecords = [];
			}
		},
		/**
		 * Checks whether this layer is currently disabled
		 */
		isDisabled: function()
		{
			return (this._disabled == true);
		},
		/**
		 * Removes records by ID
		 */
		removeMXRecordByUid: function(uidData)
		{
			if (this._records != null)
			{
				this._records.removeRecordFromMap(uidData);
			}
			else
			{
				if (dojo.config.fwm.debug == true)
				{
					console.log("[Layer] _records is null");
				}
			}
		},
		/**
		 * Creates a new child layer based on its type
		 */
		createNewChildLayer: function(options)
		{

			var layer = null;
			options.parentLayer = this;

			// Create the child layer according to its type
			switch (options.layerType)
			{
			case ibm.tivoli.fwm.mxmap.layers.LayerType.SYMBOLOGY:
				require(["ibm/tivoli/fwm/mxmap/layers/SymbologyLayer"], function(SymbologyLayer) {
					layer = new SymbologyLayer(options);
				});
				break;
			case ibm.tivoli.fwm.mxmap.layers.LayerType.LEGEND:
				require(["ibm/tivoli/fwm/mxmap/layers/LegendLayer"], function(LegendLayer) {
					layer = new LegendLayer(options);
				});
				break;
			default:
				layer = new Layer(options);
			break;
			}
			;

			// Add the layer to the array of child layers
			if (layer != null)
			{
				this.addChildLayer(layer);
			}

			return layer;
		},
		/**
		 * Adds the child layer to the array
		 */
		addChildLayer: function(layer, cleanBeforeAdd)
		{
			var layerName = layer.getLayerName();
			var _layer = this.getChildLayer(layerName);
			if (_layer == null)
			{
				this._childLayers[layerName] = layer;
			}
			// If this layer has at least one child, set the submenu icon
			if (this._rightIconSet == false)
			{
				this._setRightIconURL();
			}
		},
		/*
		 * Retrieves the child layer by name
		 */
		getChildLayer: function(layerName)
		{
			if (this._childLayers.hasOwnProperty(layerName) == true)
			{
				return this._childLayers[layerName];
			}
			return null;
		},
		/**
		 * Returns an array with all the existing layers
		 */
		getChildren: function()
		{
			var array = [];
			for ( var key in this._childLayers)
			{
				array.push(this._childLayers[key]);
			}
			return array;
		},
		/**
		 * Retrieves the parent layer
		 */
		getParentLayer: function()
		{
			return this._parentLayer;
		},
		/**
		 * Retrieves sibling layers
		 */
		getSiblings: function()
		{
			return this.isRoot() ? null : this._parentLayer.getChildren();

		},
		/**
		 * Checks if this layer has children
		 */
		hasChildren: function()
		{
			var hasChildren = false;
			for ( var key in this._childLayers)
			{
				hasChildren = true;
				break;
			}
			return hasChildren;
		},
		/**
		 * Checks if this layer is a root layer
		 */
		isRoot: function()
		{
			return (this._parentLayer == null);
		},
		/**
		 * Enables this layer making its records visible
		 */
		enable: function()
		{
			this._disabled = false;

			if (this.layerRecords != null)
			{
				for (var i = 0; i < this.layerRecords.length; i++)
				{
					var mboInfo = this.layerRecords[i];
					var layersManager = this._map.getLayersManager();
					var legend = layersManager.getLegendForRecord(mboInfo, this);
					if(layersManager.isLegendEnabledForRecord(legend) == true)
					{
						this._map.showMboMarker(mboInfo, this._layerId);
					}
				}
			}
			this._setLeftIconURL();
		},
		/**
		 * Disables this layer making its records invisible
		 */
		disable: function()
		{
			this._disabled = true;

			if (this.layerRecords != null)
			{
				for (var i = 0; i < this.layerRecords.length; i++)
				{
					var mboInfo = this.layerRecords[i];
					this._map.removeMboMarkerFromMap(mboInfo, this._layerId);
				}
			}
			this._setLeftIconURL();

		},
		redrawMarkers: function()
		{
			if (this.layerRecords != null && !this.isDisabled())
			{
				for (var i = 0; i < this.layerRecords.length; i++)
				{
					var mboInfo = this.layerRecords[i];
					this._map.removeMboMarkerFromMap(mboInfo, this._layerId);
					var layersManager = this._map.getLayersManager();
					var legend = layersManager.getLegendForRecord(mboInfo, this);
					if(layersManager.isLegendEnabledForRecord(legend) == true)
					{
						this._map.showMboMarker(mboInfo, this._layerId);
					}
				}
			}
		},
		getChildrenTitle: function()
		{
			return this._childrenTitle;
		},
		setMboMarkerInfo: function(mboInfo, opt)
		{
			return this._mboMarkerOptions.setMboMarkerInfo(mboInfo, opt);
		},
		getMboMarkerInfo: function(mboInfo)
		{
			return this._mboMarkerOptions.getMboMarkerInfo(mboInfo);
		},
		executeQueuedParallel: function()
		{
			while (this._recordQueueParallel.length > 0)
			{
				var obj = this._recordQueueParallel.pop();
				this.addRecord(obj.mboInfo, obj.markerOptions);
			}
		},
		getRecords: function()
		{
			return this.layerRecords;
		},
		setUseLBSPosition: function(useLBSPosition)
		{
			this._useLBSPosition = useLBSPosition;
		},
		useLBSPosition: function()
		{
			return (this._useLBSPosition == true);
		},
		MboMarkerOptionsTable: function()
		{
			this.mbosOnMap = {};
			/*
			 * Stores a reference for the given MBO with the given options. If a
			 * reference already exists, updates all of its properties with the given
			 * ones.
			 */
			this.setMboMarkerInfo = function(mboInfo, opt)
			{
				this._createMboMarkerHashRecord(mboInfo);
				var extraKey = ((mboInfo.extrakey != undefined) && (mboInfo.extrakey != null)) ? mboInfo.extrakey : 0;
				for ( var propName in opt)
				{
					this.mbosOnMap[mboInfo.mxdata.mboName][mboInfo.mxdata.uid.value][extraKey][propName] = opt[propName];
				}

			};
			/*
			 * Creates a reference for the given MBO in the map's MBO marker map. The
			 * reference count is initialized to 0.
			 */
			this._createMboMarkerHashRecord = function(mboInfo)
			{
				if (!this.mbosOnMap[mboInfo.mxdata.mboName])
				{
					this.mbosOnMap[mboInfo.mxdata.mboName] = {};
				}
				if (!this.mbosOnMap[mboInfo.mxdata.mboName][mboInfo.mxdata.uid.value])
				{
					this.mbosOnMap[mboInfo.mxdata.mboName][mboInfo.mxdata.uid.value] = {};
				}
				// If extrakey exists in mboInfo, it is always > 0
				var extraKey = ((mboInfo.extrakey != undefined) && (mboInfo.extrakey != null)) ? mboInfo.extrakey : 0;
				if (!this.mbosOnMap[mboInfo.mxdata.mboName][mboInfo.mxdata.uid.value][extraKey])
				{
					this.mbosOnMap[mboInfo.mxdata.mboName][mboInfo.mxdata.uid.value][extraKey] = {};
					this.mbosOnMap[mboInfo.mxdata.mboName][mboInfo.mxdata.uid.value][extraKey]["layerCount"] = 0;
				}
			};
			/*
			 * Returns the stored info for the given MBO.
			 */
			this.getMboMarkerInfo = function(mboInfo)
			{
				if (!mboInfo.mxdata)
				{
					return null;
				}
				if (!this.mbosOnMap[mboInfo.mxdata.mboName])
				{
					return null;
				}
				if (!this.mbosOnMap[mboInfo.mxdata.mboName][mboInfo.mxdata.uid.value])
				{
					return null;
				}
				var extraKey = ((mboInfo.extrakey != undefined) && (mboInfo.extrakey != null)) ? mboInfo.extrakey : 0;
				if (!this.mbosOnMap[mboInfo.mxdata.mboName][mboInfo.mxdata.uid.value][extraKey])
				{
					return null;
				}
				return this.mbosOnMap[mboInfo.mxdata.mboName][mboInfo.mxdata.uid.value][extraKey];
			};
		}
	});
});



},
'ibm/tivoli/fwm/mxmap/toolbar/ext/FindLocationTool':function(){
/* IBM Confidential
 *
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define( ["dojo/_base/declare", 
		"dojo/dom-construct",
		"ibm/tivoli/fwm/mxmap/findlocation/FindLocationPanelWidget",
		"ibm/tivoli/fwm/mxmap/toolbar/ext/_ToggleTool"], function (declare, domConstruct, FindLocationBar, _ToggleTool ) {

	return declare( [_ToggleTool], {
		
		/* The label that will be shown as a tooltip for the tool */
		label: ibm.tivoli.fwm.i18n.getMaxMsg("map", "findLocation")	,
		
		iconClass: "basicMapToolbarBtn findLocationToolbarBtn",
		
		toolName: "findLocationTool",
		/* Tool initialization. The params argument,
		 * by default, contains only the Map reference */
		constructor: function(params)
		{
			dojo.mixin(this, params);
		},
		executeOn: function()
		{		
			this.map.getMaximo().isCurrentMboAddressable(dojo.hitch(this, function(data) {
				if (data) {
					if (data.result == "success") {
						if (!data.isAddressable) {
							this.map.getMaximo().showMessage("map", "ServiceAddressNotAvailable");
							return;
						}
						if (!data.isAddressEditable) {
							this.map.getMaximo().showMessage("map", "ServiceAddressNotEditable");
							return;
						}	
						if (!this.findLocationBar) {
							this.findLocationBar = new FindLocationBar({
								map: this.map, 
								tool: this,
								toolName: this.toolName
							});
							this.findLocationBar.createBar();
						}
						this.findLocationBar.show();
					} else if (data.result == "fail") {
						this.getMaximo().showMessage(data.group, data.key, data.params);
					}
				}
				
				
			}));
			
			
			
		},
		executeOff: function() {
			if (this.findLocationBar) {
				this.findLocationBar.hide();
			}
		},
		saveToolConfiguration: function() {

		},
		disable: function()
		{
					
		},
		destroy: function()
		{
			if (this.findLocationBar) {
				this.findLocationBar.destroy();
			}
		}
	})
});

},
'ibm/tivoli/fwm/mxmap/impl/polyline/BingPolyline':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/_Polyline"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

dojo.require("ibm.tivoli.fwm.mxmap._Polyline");
dojo.provide("ibm.tivoli.fwm.mxmap.impl.polyline.BingPolyline");

/**
 * BingPolyline
 */
dojo.declare("ibm.tivoli.fwm.mxmap.impl.polyline.BingPolyline", ibm.tivoli.fwm.mxmap._Polyline, {
	
	toProprietary: function() 
	{
		var mpoints = [];
	
		for ( var i = 0; i < this.points.length; i++)
		{
			mpoints.push(this.points[i].toProprietary('microsoftv8'));
		}
		var mpolyline = null;
		var opacity = this.opacity ? Math.round(this.opacity * 255) : 255;
		var color = Microsoft.Maps.Color.fromHex(this.color);
		// 12-13693. Using the correct stroke width for route lines.
		var strokeWidth = this.width || 3;
		var borderOpacity = this.borderOpacity ? Math.round(this.borderOpacity * 255) : 255;

		// 12-10633
		if (this.fillColor)
		{
			var fillColor = Microsoft.Maps.Color.fromHex(this.fillColor);
			var fillColorWithOpacity = new Microsoft.Maps.Color(opacity, fillColor.r, fillColor.g, fillColor.b);
		}
	
		/* if it is closed, created a polygon */
		if (this.closed && this.closed == true)
		{
			color.a = borderOpacity;
			mpolyline = new Microsoft.Maps.Polygon(mpoints, {
				fillColor: fillColorWithOpacity || "#000000",
				strokeColor: color,
				strokeThickness: strokeWidth,
				visible: true
			});
		}
		else
		{
			// 12-13693. Using the correct stroke opacity for route lines.
			color.a = opacity;
			mpolyline = new Microsoft.Maps.Polyline(mpoints, {
				strokeColor: color,
				strokeThickness: strokeWidth,
				visible: true
			});
		}
		this.proprietary_polyline = mpolyline;
		return mpolyline;
	},
	/**
	 * Shows the polyline.
	 */
	show: function()
	{
		this.proprietary_polyline.setOptions({
			visible: true
		});
	},

	/**
	 * Hide the polyline.
	 */
	hide: function()
	{
		this.proprietary_polyline.setOptions({
			visible: false
		});
	}

});

});

},
'dojo/dnd/common':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["../sniff", "../_base/kernel", "../_base/lang", "../dom"],
	function(has, kernel, lang, dom){

// module:
//		dojo/dnd/common

var exports = lang.getObject("dojo.dnd", true);
/*=====
// TODO: for 2.0, replace line above with this code.
var exports = {
	// summary:
	//		TODOC
};
=====*/

exports.getCopyKeyState = function(evt){
	return evt[has("mac") ? "metaKey" : "ctrlKey"]
};

exports._uniqueId = 0;
exports.getUniqueId = function(){
	// summary:
	//		returns a unique string for use with any DOM element
	var id;
	do{
		id = kernel._scopeName + "Unique" + (++exports._uniqueId);
	}while(dom.byId(id));
	return id;
};

exports._empty = {};

exports.isFormElement = function(/*Event*/ e){
	// summary:
	//		returns true if user clicked on a form element
	var t = e.target;
	if(t.nodeType == 3 /*TEXT_NODE*/){
		t = t.parentNode;
	}
	return " a button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
};

return exports;
});

},
'dijit/CheckedMenuItem':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"./MenuItem",
	"dojo/text!./templates/CheckedMenuItem.html",
	"./hccss"
], function(declare, domClass, MenuItem, template){

	// module:
	//		dijit/CheckedMenuItem

	return declare("dijit.CheckedMenuItem", MenuItem, {
		// summary:
		//		A checkbox-like menu item for toggling on and off

		// Use both base classes so we get styles like dijitMenuItemDisabled
		baseClass: "dijitMenuItem dijitCheckedMenuItem",

		templateString: template,

		// checked: Boolean
		//		Our checked state
		checked: false,
		_setCheckedAttr: function(/*Boolean*/ checked){
			this.domNode.setAttribute("aria-checked", checked ? "true" : "false");
			this._set("checked", checked);	// triggers CSS update via _CssStateMixin
		},

		iconClass: "",	// override dijitNoIcon

		role: "menuitemcheckbox",

		// checkedChar: String
		//		Character (or string) used in place of checkbox icon when display in high contrast mode
		checkedChar: "&#10003;",

		onChange: function(/*Boolean*/ /*===== checked =====*/){
			// summary:
			//		User defined function to handle check/uncheck events
			// tags:
			//		callback
		},

		_onClick: function(evt){
			// summary:
			//		Clicking this item just toggles its state
			// tags:
			//		private
			if(!this.disabled){
				this.set("checked", !this.checked);
				this.onChange(this.checked);
			}
			this.onClick(evt);
		}
	});
});

},
'dijit/Viewport':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/Evented",
	"dojo/on",
	"dojo/domReady",
	"dojo/sniff",	// has("ie"), has("ios")
	"dojo/window" // getBox()
], function(Evented, on, domReady, has, winUtils){

	// module:
	//		dijit/Viewport

	/*=====
	return {
		// summary:
		//		Utility singleton to watch for viewport resizes, avoiding duplicate notifications
		//		which can lead to infinite loops.
		// description:
		//		Usage: Viewport.on("resize", myCallback).
		//
		//		myCallback() is called without arguments in case it's _WidgetBase.resize(),
		//		which would interpret the argument as the size to make the widget.
	};
	=====*/

	var Viewport = new Evented();

	var focusedNode;

	domReady(function(){
		var oldBox = winUtils.getBox();
		Viewport._rlh = on(window, "resize", function(){
			var newBox = winUtils.getBox();
			if(oldBox.h == newBox.h && oldBox.w == newBox.w){ return; }
			oldBox = newBox;
			Viewport.emit("resize");
		});

		// Also catch zoom changes on IE8, since they don't naturally generate resize events
		if(has("ie") == 8){
			var deviceXDPI = screen.deviceXDPI;
			setInterval(function(){
				if(screen.deviceXDPI != deviceXDPI){
					deviceXDPI = screen.deviceXDPI;
					Viewport.emit("resize");
				}
			}, 500);
		}

		// On iOS, keep track of the focused node so we can guess when the keyboard is/isn't being displayed.
		if(has("ios")){
			on(document, "focusin", function(evt){
				focusedNode = evt.target;
			});
			on(document, "focusout", function(evt){
				focusedNode = null;
			});
		}
	});

	Viewport.getEffectiveBox = function(/*Document*/ doc){
		// summary:
		//		Get the size of the viewport, or on mobile devices, the part of the viewport not obscured by the
		//		virtual keyboard.

		var box = winUtils.getBox(doc);

		// Account for iOS virtual keyboard, if it's being shown.  Unfortunately no direct way to check or measure.
		var tag = focusedNode && focusedNode.tagName && focusedNode.tagName.toLowerCase();
		if(has("ios") && focusedNode && !focusedNode.readOnly && (tag == "textarea" || (tag == "input" &&
			/^(color|email|number|password|search|tel|text|url)$/.test(focusedNode.type)))){

			// Box represents the size of the viewport.  Some of the viewport is likely covered by the keyboard.
			// Estimate height of visible viewport assuming viewport goes to bottom of screen, but is covered by keyboard.
			box.h *= (orientation == 0 || orientation == 180 ? 0.66 : 0.40);

			// Above measurement will be inaccurate if viewport was scrolled up so far that it ends before the bottom
			// of the screen.   In this case, keyboard isn't covering as much of the viewport as we thought.
			// We know the visible size is at least the distance from the top of the viewport to the focused node.
			var rect = focusedNode.getBoundingClientRect();
			box.h = Math.max(box.h, rect.top + rect.height);
		}

		return box;
	};

	return Viewport;
});

},
'ibm/tivoli/fwm/mxmap/actions/SetRecordLocation':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/actions/Actions,ibm/tivoli/fwm/mxmap/_Base,ibm/tivoli/fwm/mxmap/ImageLibraryManager"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.actions.SetRecordLocation");
dojo.require("ibm.tivoli.fwm.mxmap.actions.Actions");
dojo.require("ibm.tivoli.fwm.mxmap._Base");
dojo.require("ibm.tivoli.fwm.mxmap.ImageLibraryManager");

/**
 * Action to set the location of the current record.
 */
dojo.declare("ibm.tivoli.fwm.mxmap.actions.SetRecordLocation", [ ibm.tivoli.fwm.mxmap.actions.Actions, ibm.tivoli.fwm.mxmap._Base ], {

	constructor : function(params) {
		dojo.mixin(this, params);
		this.label = ibm.tivoli.fwm.i18n.getMaxMsg("map","set_recloc_label");//"Set record Location";
		/* used to remove the temp pushpin */
		this.addSubscription("onCurrentLocationUpdated_"+this.map.getId(), dojo.hitch(this, this._clearMarker));
		this.addSubscription("onServerException_"+this.map.getId(), dojo.hitch(this, this._clearMarker));
	},
	mapstraction : null,
	/**
	 * Removes the temp marker after the current record location was updated.
	 */
	_clearMarker : function() {
		
		if (this.marker != null) {
			if (dojo.config.fwm.debug == true)
			{
				console.log("[SetRecordLocation] Clearing Temporary Marker", this.marker);
			}
			this.map.removeMarker(this.marker);
		}
	},
	/**
	 * Returns the image path to be used. Checks for a custom path or returns the default.
	 * */
	_getPushPinImagePath: function(){
		var defaultImagePath = ibm.tivoli.fwm.mxmap.ImageLibraryManager.getImageLibraryManager().getDefaultReadOnlyMarkerImageInfo().getImageURL();
		var custom = this.map.mapConf.markerimgurl;
		if(custom != null && custom.trim().length > 0){
			return custom;
		}
		return defaultImagePath;
		 
	},
	/**
	 * Load the current right click position and updates server's current record
	 * data
	 * 
	 * @Override Action method
	 */
	execute : function(args) {
		if (this.marker != null) {
			this.map.removeMarker(this.marker);
		}
		var tempPushPin = this._getPushPinImagePath();
		var markerData = {
			draggable : true,
			icon : tempPushPin,
			iconSize : [ 36, 36 ],
			iconAnchor : [ 18, 36 ],
			hover : true
		};
		
		// middle and not bottom right.
		this.marker = this.map.addMarker(args.mapLocation, markerData);
		// adds are only allowed if we have the mainrecord as DS, so we use the first record
		this.map.currentRecordMgr.reverseGeocodeCurrentRecord(args.mapLocation);		
	}

});

});

},
'dojo/json5':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	'./json5/parse'
], function (parse) {
	return {
		parse: parse
	};
});

},
'ibm/tivoli/fwm/mxmap/impl/BingMaps':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/Map,ibm/tivoli/fwm/mxmap/impl/marker/BingMarker,ibm/tivoli/fwm/mxmap/impl/point/BingLatLonPoint,ibm/tivoli/fwm/mxmap/impl/polyline/BingPolyline,ibm/tivoli/fwm/mxmap/impl/boundingbox/BingBoundingBox,ibm/tivoli/fwm/mxmap/impl/geocoder/BingGeocoder,ibm/tivoli/fwm/mxmap/InfoWindow"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */
dojo.provide("ibm.tivoli.fwm.mxmap.impl.BingMaps");
dojo.require("ibm.tivoli.fwm.mxmap.Map");
dojo.require("ibm.tivoli.fwm.mxmap.impl.marker.BingMarker");
dojo.require("ibm.tivoli.fwm.mxmap.impl.point.BingLatLonPoint");
dojo.require("ibm.tivoli.fwm.mxmap.impl.polyline.BingPolyline");
dojo.require("ibm.tivoli.fwm.mxmap.impl.boundingbox.BingBoundingBox");
dojo.require("ibm.tivoli.fwm.mxmap.impl.geocoder.BingGeocoder");

dojo.declare("ibm.tivoli.fwm.mxmap.impl.BingMaps", ibm.tivoli.fwm.mxmap.Map, {

	constructor: function(options)
	{
		this.providerName = "microsoftv8";
	},
	/**
	 * These options will refine maps UI. See their descriptions at:
	 * http://msdn.microsoft.com/en-us/library/gg427603.aspx
	 */
	_getInitOptions: function()
	{
		var options = {};
		
		options.fixedMapPosition = false;
		options.useInertia = true;
		options.showScalebar = true;
		options.disableTouchInput = false;// allows user to touch screen.
		options.enableClickableLogo = false;
		options.enableSearchLogo = false;
		options.showCopyright = true;
		options.mapTypeId = Microsoft.Maps.MapTypeId.road;
		/* FWM opts */
		options.isIE = dojo.isIE;
		
		if (this.isMobile == true)
		{
			// 12-12979 Commenting out the line below because this option was making
			// the repositioning of maptips fail when resizing the mapcontrol div
			// options.fixedMapPosition = true;
			options.showScalebar = false;
		}
		
		options.initialLocation=this._getInitialLocation();
		
		
		return options;

	},
	_getCustomInitOptions: function()
	{
		if (this.customInitialMapOptions)
		{
			return this.customInitialMapOptions.bingmaps;
		}
		log.info("no custom configuration");
		return {};
	},
	destroyMap: function()
	{
		console.log("Destroying map!");
		try
		{
			var map = this.getProviderMap();

			if (typeof (map) != 'undefined' && map != null)
			{
				this._destroyProviderMap();
			}
			if (dojo.config.fwm.debug == true)
			{
				console.log("map was destroyed!");
			}
		}
		catch (e)
		{
			console.error("cannot destroy bing maps ", e.message);
		}

	},
	/**
	 * Initializes the map and all the initial setup for it. Also the
	 * handlers are added to the map in this map. Special attention in Bing
	 * maps for this method because it doesn't support changes of map
	 * components on demand and we create the map instance in this method.
	 * Therefore many of unchangeable stuff is set up here in this method.
	 */
	_init:function(element, options)
	{
		function _overrideBingMapConf(mapConf) {
			var isHttps = mapConf.https || location.protocol === 'https:';
	
			if (isHttps) {
				mapConf.https = true;
				
				if (mapConf.route && !mapConf.route.includes('https')) {
					mapConf.route = mapConf.route.replace('http', 'https');
				}
	
				if (mapConf.geocode && !mapConf.geocode.includes('https')) {
					mapConf.geocode = mapConf.geocode.replace('http', 'https');
				}
			}
		}
		_overrideBingMapConf(this.mapConf);

		this.element = element;

		var me = this;
		dojo.require("ibm.tivoli.fwm.mxmap.InfoWindow");
		if (!Microsoft || !Microsoft.Maps)
		{
			throw api + ' map script not imported';
		}

		options.credentials = this.mapConf.key;
		
		if (options.isIE && (!options.width || !options.height))
		{
			var width = 600;
			var height = 800;
			/**
			 * must not have px in the value
			 */
			if (element.style && element.style.width)
			{
				width = element.style.width;
				if (width.substr(width.length - 2) == 'px')
				{
					width = width.substr(0, width.length - 2);
				}
			}
			if (element.style && element.style.height)
			{
				height = element.style.height;
				if (height.substr(height.length - 2) == 'px')
				{
					height = height.substr(0, height.length - 2);
				}
			}
			options.width = width;// 'inherit';
			options.height = height;// 'inherit';
		}

		if (options.initialLocation && options.initialLocation.lat != null)
		{
			options.center = new Microsoft.Maps.Location(options.initialLocation.lat, options.initialLocation.lng);
		}
		if (options.initialLocation && options.initialLocation.level != null)
		{
			options.zoom = options.initialLocation.level;
		}
		// options.center=Location
		// zoom

		this.map = new Microsoft.Maps.Map(element, options);

		if (options.isIE)
		{
			/**
			 * ALL THIS CODE IS FOR INTERNET EXPLORER WINDOW RESIZE LOGIC IE
			 * doesn't update the map div width/height correctly in bingmaps
			 * so it doesn't fit in the available space. This logic listens
			 * to window.resize event to update the map width/height based
			 * on it's parent node and the view port available.
			 * 
			 * **IT DEPENDS ON DIJIT **
			 */

			var addEvent = function(elem, type, eventHandle)
			{
				if (elem == null || elem == undefined)
					return;
				if (elem.addEventListener)
				{
					elem.addEventListener(type, eventHandle, false);
				}
				else if (elem.attachEvent)
				{
					elem.attachEvent("on" + type, eventHandle);
				}
			};

			var mapDivElement = element.childNodes[0];

			var ieBingMapsResize = function()
			{
				try
				{
					// Issue 12-12453. The _resize() method in Map.js takes
					// care of the Map's parent div,
					// so I think that there is no need to calculate the
					// dimensions of this div.
					// var availableHorRegion =
					// parseInt(dijit.getViewport().h -
					// mapDivElement.parentNode.offsetTop - 20);
					// mapDivElement.style.height = (availableHorRegion) +
					// "px";
					mapDivElement.style.height = "100%";
					// var availableVerRegion =
					// parseInt(dijit.getViewport().w -
					// mapDivElement.offsetLeft - 20);
					// mapDivElement.style.width = (availableVerRegion) +
					// "px";
					mapDivElement.style.width = "100%";
				}
				catch (e)
				{
					console.error("Could not resize map element.", e.message);
				}
			};
			addEvent(window, "resize", ieBingMapsResize);

		}
		// dojo.create("div", {
		// id: "infoCustom",
		// style: {
		// top: 0,
		// left: 0,
		// width: '100px',
		// height: '150px',
		// zIndex: 1000000,
		// position: "absolute",
		// backgroundColor: "white",
		// display: "none"
		// }
		// }, dojo.body());

		var clickHandler = function(e)
		{
			var map = me.map;
			switch (e.targetType)
			{
				case 'map':
					var msLatLng = e.location;
					var latLng = me.latLng(msLatLng.latitude, msLatLng.longitude);
					me.fireMapEvent(me.Events.click, {
						'location': latLng
					});
					break;
				case 'pushpin':
				{
					break;
				}
				default:
					break;
			}

		};
		Microsoft.Maps.Events.addHandler(this.map, 'click', clickHandler);
		var rclickHandler = function(event)
		{
			if (event.targetType && event.targetType == 'map')
			{

				var point = new Microsoft.Maps.Point(event.getX(), event.getY());
				var msLatLng = me.map.tryPixelToLocation(point);
				var latLng = me.latLng(msLatLng.latitude, msLatLng.longitude);
				var pixel = {
					x: event.pageX - event.target.getPageX(),
					y: event.pageY - event.target.getPageY()
				};
				me.fireMapEvent(me.Events.rightclick,{
					'location': latLng,
					'pixel': pixel
				});

			}

			me.stopEventPropagation(event);
			return true;
		};
		// deal with mouse right click
		Microsoft.Maps.Events.addHandler(this.map, 'rightclick', rclickHandler);
		// deal with zoom change
		Microsoft.Maps.Events.addHandler(this.map, 'viewchange', function()
		{
			me.fireMapEvent(me.Events.changeZoom);
		});

		// deal with map movement
		Microsoft.Maps.Events.addHandler(this.map, 'viewchangeend', function()
		{
			me.fireMapEvent(me.Events.endPan);
		});

		this.loaded = true;
	},
	
	/**
	 * disposes map
	 */
	_destroyProviderMap: function()
	{
		var map = this.getProviderMap();
		console.log("[Bingv8] Going to dispose");
		map.dispose();
		console.log("[Bingv8] Disposed");
		this.loaded = false;
		map = null;

	},
	
	
	/**
	 * Resizes the map.
	 */
	resizeTo: function(nWidth, nHeight)
	{
		
		var mapCtrl = dojo.byId( this.divId );
		var height = mapCtrl.offsetHeight;
		dojo.style( this.divId , {"height": height-1+"px"});
		if (dojo.isIE)
		{
			if (this.getElement().childNodes)
			{
				this.getElement().childNodes[0].style.width = nWidth;
				this.getElement().childNodes[0].style.height = nHeight;
			}
			var map = this.getProviderMap();

			map.setOptions({
				width: "0px"
			});
		} 
	},

	/**
	 * Reset to small controls. ** Bing provider only accept options set in
	 * map contructor ***
	 */
	addSmallControls: function()
	{
		// not implemented
	},
	/*
	 * Always in WGS84
	 */
	getAllPointsFromWGS84: function(points, callback)
	{
		callback(points);
	},
	getAllPointsInWGS84: function(points, callback)
	{
		callback(points);
	},
	/**
	 * reset to large controls ** Bing provider only accept options set in
	 * map contructor ***
	 */
	addLargeControls: function()
	{
		// not implemented
	},

	/**
	 * Enable map type control (ROAD, MAP, etc) ** Bing provider only accept
	 * options set in map contructor ***
	 */
	addMapTypeControls: function()
	{
		// not implemented
	},

	/**
	 * Set map center point and zoom level.
	 */
	setCenterAndZoom: function(nPoint, nZoom)
	{
		var map = this.getProviderMap();
		var options = {
			zoom: nZoom,
			center: nPoint.toProprietary()
		};
		map.setView(options);
	},

	/**
	 * Add a marker (Microsoft.Maps.Pushpin) to the map. Also the event
	 * handlers are added using the specific code of Bing provider.
	 */
	createProviderMarker: function(point, markerData)
	{
		var marker = null;
		if(point)
		{
			var params = {point: point, map: this.getProviderMap(), compId: this.compId, isMobile: this.isMobile};
			var marker = new ibm.tivoli.fwm.mxmap.impl.marker.BingMarker(params);
			if(marker && markerData)
			{
				marker.addData(markerData);
			}
			var map = this.getProviderMap();
			marker.pinID = "ms7pin-" + new Date().getTime() + '-' + (Math.floor(Math.random() * Math.pow(2, 16)));// TODO
			// why
			// is
			// it
			// needed?
			var propMarker = marker.toProprietary();
			var len = map.entities.getLength();
			map.entities.push(propMarker);

			// If this is a multi marker, we need to reorder the list of entities in order to show multi markers on top of all 
			// the other markers displayed in the same position.
			if (markerData.isMultiMarker == true)
			{
				propMarker.isMultiMarker = true;
				for (var i = 0; i < len; i++)
				{
					var pushpin = map.entities.get(i);
					if (pushpin instanceof Microsoft.Maps.Pushpin)
					{
						// If x/y coordinates for existing push pins are the same as the multi marker lat/lng
						// and the existing push pin is not a multi marker itself, then we remove it and push it to the end
						// of the list.
						if (pushpin.geometry.x == point.lng && pushpin.geometry.y == point.lat && !pushpin.isMultiMarker)
						{
							map.entities.removeAt(i);
							map.entities.push(pushpin);
						}
					}
				}
			}	

			// This line ensures that the "mxmapMarker" property is added to the marker
			// and it is required when displaying the map tip
			marker.setChild(propMarker);
		}
		return marker;

	},
	
	/**
	 * Remove the marker (Microsoft.Maps.Pushpin) from the map.
	 * 
	 * Not sure why but map.entities.remove doesn't work correctly. So we
	 * need to iterate over all entities in order to remove them correctly.
	 */
	removeProviderMarker: function(marker)
	{
		var map = this.getProviderMap();
		marker.closeBubble();
		var msPushPin = marker.proprietary_marker;

		var ppIndex = map.entities.indexOf(msPushPin);
		var found = false;
		for ( var i = 0; i < map.entities.getLength(); i++)
		{

			var pushpin = map.entities.get(i);

			if (pushpin instanceof Microsoft.Maps.Pushpin)
			{
				if (msPushPin == pushpin)
				{
					var ii = map.entities.indexOf(pushpin);
					map.entities.removeAt(i);
					found = true;
					break;
				}

			}
		}
		try
		{
			map.entities.remove(msPushPin);

		}
		catch (e)
		{
			console.warn("failed to remove pushpin", e);
		}
		return;

	},

	/**
	 * Not supported.
	 */
	declutterMarkers: function(opts)
	{
		throw 'Not supported';
	},
	
	polyline: function(params)
	{
		return new ibm.tivoli.fwm.mxmap.impl.polyline.BingPolyline(params);
	},


	/**
	 * Add polyline (Microsoft.Map.Polyline) to the map.
	 */
	createProviderPolyline: function(polyline, polylineData)
	{
		var propPolyline = null;
		if(polyline)
		{
			if(polyline.points)
			{
				if(polylineData)
				{
					polyline.addData(polylineData);
				}
				
				var map = this.getProviderMap();
				propPolyline = polyline.toProprietary();
				map.entities.push(propPolyline);
			}
		}
		return propPolyline;

	},

	/**
	 * Remove polyline (Microsoft.Map.Polyline) from the map.
	 */
	removeProviderPolyline: function(polyline)
	{
		var map = this.getProviderMap();
		map.entities.remove(polyline.proprietary_polyline);
	},

	/**
	 * Returns center point of the map.
	 */
	getCenter: function()
	{
		var map = this.getProviderMap();
		var pt = map.getCenter();
		return this.latLng(pt.latitude, pt.longitude);
	},

	/**
	 * Set center point in the map.
	 */
	setCenter: function(point, options)
	{
		// var options ={zoom: nZoom, center:
		// nPoint.toProprietary(this.api)};
		var map = this.getProviderMap();
		this.setCenterAndZoom(point, map.getZoom());

		// var pt = point.toProprietary(this.api);
		// var options = map.getOptions();
		// options.center = pt;
		// map.setView(options);
	},

	/**
	 * Set zoom level in the map.
	 */
	setZoom: function(zoom)
	{
		var map = this.getProviderMap();
		var options = {};
		options.zoom = zoom;
		map.setView(options);
	},

	/**
	 * Returns zoom level of the map.
	 */
	getZoom: function()
	{
		var map = this.getProviderMap();
		return map.getZoom();
	},

	/**
	 * Returns the zoom level of specific rectangle.
	 */
	getZoomLevelForBoundingBox: function(bbox)
	{
		var map = this.getProviderMap();			
		var se = bbox.getSoutheast().toProprietary();
		var nw = bbox.getNorthwest().toProprietary();
		var latLongBounds = Microsoft.Maps.LocationRect.fromCorners(se, nw);
		map.setView({
			bounds: latLongBounds
		});
		return map.getZoom();
	},

	/**
	 * Set the map type according to Microsoft.Maps.MapTypeId enumeration.
	 */
	setMapType: function(type)
	{
		var map = this.getProviderMap();
		switch (type)
		{
			case this.MapType.ROAD:
				map.setMapType(Microsoft.Maps.MapTypeId.road);
				break;
			case this.MapType.SATELLITE:
				map.setMapType(Microsoft.Maps.MapTypeId.aerial);
				break;
			case this.MapType.HYBRID:
				map.setMapType(Microsoft.Maps.MapTypeId.birdseye);
				break;
			default:
				map.setMapType(Microsoft.Maps.MapTypeId.road);
		}
	},

	/**
	 * Returns the map type according to Microsoft.Maps.MapTypeId
	 * enumeration.
	 */
	getMapType: function()
	{
		var map = this.getProviderMap();
		var mode = map.GetMapStyle();
		switch (mode)
		{
			case Microsoft.Maps.MapTypeId.aerial:
				return MapType.SATELLITE;
			case Microsoft.Maps.MapTypeId.road:
				return MapType.ROAD;
			case Microsoft.Maps.MapTypeId.birdseye:
				return MapType.HYBRID;
			default:
				return null;
		}
	},

	getBoundingBox: function(swLat, swLng, neLat, neLng)
	{
		return new ibm.tivoli.fwm.mxmap.impl.boundingbox.BingBoundingBox(swLat, swLng, neLat, neLng);
	},


	/**
	 * Returns the rectancgle of current view.
	 */
	getBounds: function()
	{
		var map = this.getProviderMap();
		var view = map.getBounds();
		var bottomright = view.getSoutheast();
		var topleft = view.getNorthwest();
		
		return this.getBoundingBox(bottomright.latitude,topleft.longitude, topleft.latitude,  bottomright.longitude);
	},

	/**
	 * Set the rectangle of current view.
	 */
	setBounds: function(bounds)
	{
		var map = this.getProviderMap();
		var ne = bounds.getNorthEast();
		var sw = bounds.getSouthWest();
		var nw = new Microsoft.Maps.Location(ne.lat, sw.lon);
		var se = new Microsoft.Maps.Location(sw.lat, ne.lon);
		var rec = Microsoft.Maps.LocationRect.fromCorners(nw, se);

		var vopt = map.getOptions();

		// Set the zoom level of the map
		vopt.bounds = rec;
		map.setView(vopt);

	},

	/**
	 * TODO update comment. check if it is possible to overlay image on map
	 */
	addImageOverlay: function(id, src, nOpacity, west, south, east, north, oContext)
	{
		var map = this.getProviderMap();
		// TODO Rafael, no consegu entender como usar as cordenadas para
		// image overlay, as options do bing no possuem propriedades para
		// coordeanadas.
		// var imageBounds =
		// Microsoft.Maps.LocationRect.fromEdges(north,west,south,east)
		var tileSource = new Microsoft.Maps.TileSource({
			uriConstructor: src
		});
		var tileLayer = new Microsoft.Maps.TileLayer({
			mercator: tileSource,
			opacity: nOpacity,
			visible: true
		});
		map.entities.push(tileLayer);
	},

	/*
	 * TODO to be investigated
	 */
	setImagePosition: function(id, oContext)
	{
		var map = this.getProviderMap();
		var topLeftPoint;
		var bottomRightPoint;
		throw "not implemented";
	},

	/*
	 * TODO to be investigated
	 */
	addOverlay: function(url, autoCenterAndZoom)
	{
		var map = this.getProviderMap();;
		// Create the tile layer source
		var tileSource = new Microsoft.Maps.TileSource({
			uriConstructor: url
		});

		// Construct the layer using the tile source
		var tilelayer = new Microsoft.Maps.TileLayer({
			mercator: tileSource
		});

		// Push the tile layer to the map
		map.entities.push(tilelayer);

	},

	/*
	 * TODO to be investigated
	 */
	addTileLayer: function(tile_url, opacity, copyright_text, min_zoom, max_zoom)
	{
		var map = this.getProviderMap();;
		// Create the tile layer source
		var tileSource = new Microsoft.Maps.TileSource({
			uriConstructor: tile_url
		});

		// Construct the layer using the tile source
		var tilelayer = new Microsoft.Maps.TileLayer({
			mercator: tileSource,
			opacity: opacity,
			visible: true
		});

		// Push the tile layer to the map
		map.entities.push(tilelayer);
	},

	/*
	 * TODO to be implemented.
	 */
	toggleTileLayer: function(tile_url)
	{
		throw 'Not implemented';
	},

	trafficLayer: null,

	setShowTraffic: function(state)
	{
		var map = this.getProviderMap();
		if (state == true)
		{
			if (this.trafficLayer != null)
			{
				this.trafficLayer.show();
			}
			else
			{

				var me = this;
				var enableTraffic = function()
				{
					me.trafficManager = new Microsoft.Maps.Traffic.TrafficManager(map);
					if (me.trafficLayer != null)
					{
						me.trafficLayer.show();
					}
				};
				if (!Microsoft.Maps.Traffic)
				{
					Microsoft.Maps.loadModule('Microsoft.Maps.Traffic', {
						callback: enableTraffic
					});
				}
				else
				{
					enableTraffic();
				}

			}
		}
		else
		{
			if (this.trafficLayer != null)
			{
				this.trafficLayer.hide();
			}
		}
	},

	/*
	 * TODO to be investigated.
	 */
	getPixelRatio: function()
	{
		throw 'Not implemented';
	},

	/**
	 * Returns the mouse position based on an element. The 'mousemove' event
	 * listener has been registered to get the current mouse point.
	 */
	mousePosition: function(element)
	{
		var locDisp = document.getElementById(element);
		if (locDisp !== null)
		{
			var map = this.getProviderMap();
			Microsoft.Maps.Events.addHandler(map, 'mousemove', function(eventArgs)
			{
				var point = new Microsoft.Maps.Point(eventArgs.pageX, eventArgs.pageY);
				var _location = map.tryPixelToLocation(point);
				var loc = _location.latitude.toFixed(4) + " / " + _location.longitude.toFixed(4);
				locDisp.textContent = loc;
			});
			locDisp.textContent = "0.0000 / 0.0000";
		}
	},
	
	latLng: function(lat, lng, sr)
	{
		var params = {lat: lat, lng: lng, sr: sr};
		return new ibm.tivoli.fwm.mxmap.impl.point.BingLatLonPoint(params);
	},
	providerGeocode: function(callback, errorCallback, key, address)
	{
		var geocoder = new ibm.tivoli.fwm.mxmap.impl.geocoder.BingGeocoder(callback, errorCallback,
		{
			key : key,
			map : this,
			customParams : this.getGeoCoderConf() 
		});
		geocoder.geocode({
			address : address
		});
	},
	providerReverseGeocode: function(callback, errorCallback, key, lat, lng)
	{
		var geocoder = new ibm.tivoli.fwm.mxmap.impl.geocoder.BingGeocoder(callback, errorCallback,
		{
			key : key,
			map : this,
			customParams : this.getGeoCoderConf() 
		});
		geocoder.geocode({
			lat : lat,
			lng : lng
		});
	},
	/**
	 * Returns the geocode configuration url
	 */
	getGeoCoderConf: function()
	{
		var options = {
			url: this.mapConf.geocode
		};
		return options;
	}
});

});

},
'dijit/MenuSeparator':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"./_WidgetBase",
	"./_TemplatedMixin",
	"./_Contained",
	"dojo/text!./templates/MenuSeparator.html"
], function(declare, dom, _WidgetBase, _TemplatedMixin, _Contained, template){

	// module:
	//		dijit/MenuSeparator

	return declare("dijit.MenuSeparator", [_WidgetBase, _TemplatedMixin, _Contained], {
		// summary:
		//		A line between two menu items

		templateString: template,

		buildRendering: function(){
			this.inherited(arguments);
			dom.setSelectable(this.domNode, false);
		},

		isFocusable: function(){
			// summary:
			//		Override to always return false
			// tags:
			//		protected

			return false; // Boolean
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/impl/GMaps':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/fwm/mxmap/Map,ibm/tivoli/fwm/mxmap/impl/marker/GmapsMarker,ibm/tivoli/fwm/mxmap/impl/point/GmapsLatLonPoint,ibm/tivoli/fwm/mxmap/impl/polyline/GmapsPolyline,ibm/tivoli/fwm/mxmap/impl/boundingbox/GmapsBoundingBox,ibm/tivoli/fwm/mxmap/impl/geocoder/GmapsGeocoder"], function(dijit,dojo,dojox){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

dojo.provide("ibm.tivoli.fwm.mxmap.impl.GMaps");
dojo.require("ibm.tivoli.fwm.mxmap.Map");
dojo.require("ibm.tivoli.fwm.mxmap.impl.marker.GmapsMarker");
dojo.require("ibm.tivoli.fwm.mxmap.impl.point.GmapsLatLonPoint");
dojo.require("ibm.tivoli.fwm.mxmap.impl.polyline.GmapsPolyline");
dojo.require("ibm.tivoli.fwm.mxmap.impl.boundingbox.GmapsBoundingBox");
dojo.require("ibm.tivoli.fwm.mxmap.impl.geocoder.GmapsGeocoder");

dojo.declare("ibm.tivoli.fwm.mxmap.impl.GMaps", ibm.tivoli.fwm.mxmap.Map, {
	
	constructor : function(options) {
		this.providerName="googlev3";
		// This zoom is used only when trying to setCenter before setting a zoom level
		this._defaultZoom = 10;
	},
	_getCustomInitOptions:function(){
		
		if(this.customInitialMapOptions){
			return this.customInitialMapOptions.gmaps;
		}
		log.info("no custom configuration");
		return {};
	},
	_getInitOptions : function() {
		var options = {
			panControl : true,
			mapTypeControl : true,
			scaleControl : true,
			overviewMapControl : true,
			streetViewControl : true,
			scaleControlOptions : {
				style : google.maps.ScaleControlStyle.DEFAULT
			},
			mapTypeId : google.maps.MapTypeId.ROADMAP
		};

		if (this.isMobile == true) {
			options.panControl = false; //does not work and looks bad on native android browser
			options.overviewMapControl = false;
			options.scaleControl = false; //looks bad on native android browser and takes space from map
		}

		return options;
	},
	
	_init:function(element, options)
	{
		this.element = element;

		if (options.zoom)
		{
			options.navigationControl = true;
			if (options.zoom == 'small')
			{
				options.navigationControlOptions = {
					style: google.maps.NavigationControlStyle.SMALL
				};
			}
			if (options.zoom == 'large')
			{
				options.navigationControlOptions = {
					style: google.maps.NavigationControlStyle.ZOOM_PAN
				};
			}
			delete options.zoom;
		}
		if (options.map_type)
		{
			options.mapTypeControl = true;
			options.mapTypeControlOptions = {
				style: google.maps.MapTypeControlStyle.DEFAULT
			};
			delete options.map_type;
		}
		
		var map = new google.maps.Map(element, options);
		
		var fireOnNextIdle = [];
		
		var me = this;
		/**
		 * This event is fired after a zoom or pan operation ands, so
		 * it's necessary to handle those events.
		 */
		google.maps.event.addListener(map, 'idle', function()
		{
			var fireListCount = fireOnNextIdle.length;
			if (fireListCount > 0)
			{
				var fireList = fireOnNextIdle.splice(0, fireListCount);
				var handler;
				while ((handler = fireList.shift()))
				{
					handler();
				}
			}
		});
		google.maps.event.addListener(map, 'rightclick', function(location)
		{
			me.fireMapEvent(me.Events.rightclick, {
				'location': me.latLng(location.latLng.lat(), location.latLng.lng()),
				'pixel': location.pixel,
				'point': location.point
			});
		});
		// deal with click
		google.maps.event.addListener(map, 'click', function(location)
		{
			me.fireMapEvent(me.Events.click, {
				'location': me.latLng(location.latLng.lat(), location.latLng.lng())
			});
		});

		// deal with zoom change
		google.maps.event.addListener(map, 'zoom_changed', function()
		{
			// zoom_changed fires before the
			// zooming has finished so we
			// wait for the next idle event
			// before firing our changezoom
			// so that method calls report the
			// correct values
			fireOnNextIdle.push(function()
			{
				me.fireMapEvent(me.Events.changeZoom);
			});
		});

		// deal with map movement
		google.maps.event.addListener(map, 'center_changed', function()
		{
			// TODO: Understand what the line below does
			//me.moveendHandler(me);
			me.fireMapEvent(me.Events.endPan);
		});

		// deal with initial tile loading
		var loadListener = google.maps.event.addListener(map, 'tilesloaded', function()
		{
			me.fireMapEvent(me.Events.load);

			// Some elements might be added on map
			// Configure their positions
			me.mapZIndexHandler.configureMapElements();
			
			google.maps.event.removeListener(loadListener);
		});


		map.LabelMarkerOverlay = function LabelMarkerOverlay(labelText, latLong, _map, marker, icon, iconAnchor, iconSize)
		{
			this.labelText = ((labelText != null) ? labelText : "");
			this.labelLatLong = latLong;
			this.labelDiv = null;
			this.icon = icon;
			this.iconAnchor = iconAnchor;
			this.iconSize = iconSize;

			this.marker = marker;
			this.setMap(_map);

			var me = this;
			google.maps.event.addListener(this.marker, "zindex_changed", function()
			{
				me.setZIndex();
			});
		};
		map.LabelMarkerOverlay.prototype = new google.maps.OverlayView();
		map.LabelMarkerOverlay.prototype.onAdd = function()
		{
			var div = document.createElement('div');
			div.style.position = "absolute";

			var ax = (this.iconAnchor && this.iconAnchor[0]) ? this.iconAnchor[0] : 0; // anchor
			// x
			var ay = (this.iconAnchor && this.iconAnchor[1]) ? this.iconAnchor[1] : 0; // anchor
			// y
			var img = document.createElement("img");
			img.style.position = "absolute";
			img.style.left = "-22px";// ax + 'px';
			img.style.top = "-10px";// ay + 'px';
			if (dojo.isIE)
			{
				img.style.left = "-19px";// ax + 'px';
				img.style.top = "-9px";// ay + 'px';
			}
			img.style.width = this.iconSize[0] + "px";
			img.style.zIndex = "0";
			img.src = this.icon;
			div.appendChild(img);

			var textDiv = document.createElement('div');
			textDiv.style.position = "absolute";
			textDiv.style.left = '-20px';
			if (dojo.isIE)
			{
				textDiv.style.left = "-19px";// ax + 'px';
			}
			
			textDiv.style.top = '0px';
			textDiv.style.width = this.iconSize[0] + 'px';
			textDiv.style.zIndex = "1";
			textDiv.style.color = "white";
			textDiv.style.fontSize = "12px";
			textDiv.style.textAlign = "center";
			textDiv.style.className = "fwmMarkerLabelGoogle";
			div.appendChild(textDiv);
			var txt = document.createTextNode(this.labelText);
			textDiv.appendChild(txt);

			this.labelDiv = div;

			this.getPanes().overlayImage.appendChild(div);
		};
		map.LabelMarkerOverlay.prototype.draw = function()
		{
			var sw = this.getProjection().fromLatLngToDivPixel(this.labelLatLong);

			var div = this.labelDiv;
			// FIXME Ideally we shouldn't have hard-coded offsets...
			div.style.left = (sw.x - 3) + 'px';
			div.style.top = (sw.y - 27) + 'px';
			div.style.width = this.iconSize[0] + "px";

			this.setZIndex();
		};
		map.LabelMarkerOverlay.prototype.setZIndex = function()
		{
			if (typeof this.marker.getZIndex() === "undefined")
			{
				this.labelDiv.style.zIndex = parseInt(this.labelDiv.style.top, 10) + 1;
			}
			else
			{
				this.labelDiv.style.zIndex = this.marker.getZIndex() + 1;
			}
		};
		map.LabelMarkerOverlay.prototype.onRemove = function()
		{
			if (this.labelDiv && this.labelDiv.parentNode)
			{
				this.labelDiv.parentNode.removeChild(this.labelDiv);
				this.labelDiv = null;
			}
		};
		
		this.map = map;
		this.loaded = true;
	},
	destroyMap: function(){},
	
	getMapType: function()
	{
		var type = this.getProviderMap().getMapTypeId();
		switch (type)
		{
			case google.maps.MapTypeId.ROADMAP:
				return MapType.ROAD;
			case google.maps.MapTypeId.SATELLITE:
				return MapType.SATELLITE;
			case google.maps.MapTypeId.HYBRID:
				return MapType.HYBRID;
			case google.maps.MapTypeId.TERRAIN:
				return MapType.PHYSICAL;
			default:
				return null;
		}
	},
	setMapType: function(type)
	{
		switch (type)
		{
			case this.MapType.ROAD:
				this.getProviderMap().setMapTypeId(google.maps.MapTypeId.ROADMAP);
				break;
			case this.MapType.SATELLITE:
				this.getProviderMap().setMapTypeId(google.maps.MapTypeId.SATELLITE);
				break;
			case this.MapType.HYBRID:
				this.getProviderMap().setMapTypeId(google.maps.MapTypeId.HYBRID);
				break;
			case this.MapType.PHYSICAL:
				this.getProviderMap().setMapTypeId(google.maps.MapTypeId.TERRAIN);
				break;
			default:
				this.getProviderMap().setMapTypeId(google.maps.MapTypeId.ROADMAP);
		}
	},

	getCenter:function()
	{
		var pt = this.getProviderMap().getCenter();
		return this.latLng(pt.lat(), pt.lng());
	},
	setCenter: function(point, options)
	{
		this.getProviderMap().setCenter(this.pointToProprietary(point));
		if(this.getZoom() == undefined)
		{
			// If there is no zoom set yet, use a default one, otherwise the map won't show up
			this.setZoom(this._defaultZoom);
		}
	},
	
	getZoom: function()
	{
		return this.getProviderMap().getZoom();
	},
	setZoom: function(zoom)
	{
		this.getProviderMap().setZoom(zoom);
	},
	
	getBoundingBox: function(swLat, swLng, neLat, neLng)
	{
		return new ibm.tivoli.fwm.mxmap.impl.boundingbox.GmapsBoundingBox(swLat, swLng, neLat, neLng);
	},


	getBounds: function()
	{
		var bounds = this.getProviderMap().getBounds();

		var sw = bounds.getSouthWest();
		var ne = bounds.getNorthEast();
		
		var swLatLng = {lat: sw.lat(), lng: sw.lng(), lon: sw.lng()};
		var neLatLng = {lat: ne.lat(), lng: ne.lng(), lon: ne.lng()};

		return this.getBoundingBoxFromSwAndNe(swLatLng, neLatLng);
	},
	setBounds: function(bounds)
	{
		if(bounds)
		{
			var sw = new google.maps.LatLng(bounds.sw.lat, bounds.sw.lng);
			var ne = new google.maps.LatLng(bounds.ne.lat, bounds.ne.lng);
			var gBounds = new google.maps.LatLngBounds(sw, ne);
			this.getProviderMap().fitBounds(gBounds);
		}
	},
	
	/*
	 * Always in WGS84
	 */
	getAllPointsFromWGS84: function(points, callback)
	{
		callback(points);
	},
	getAllPointsInWGS84: function(points, callback)
	{
		callback(points);
	},

	resizeTo: function(width, height)
	{
		var mapCtrl = dojo.byId( this.divId );
		var height = mapCtrl.offsetHeight;
		dojo.style( this.divId , {"height": height-1+"px"});
		
		this.getElement().style.width = width;
		this.getElement().style.height = height;
		google.maps.event.trigger(this.getProviderMap(), 'resize');
	},
	
	createProviderMarker: function(point, markerData)
	{
		var marker = null;
		if(point)
		{
			var params = {point: point, map: this.getProviderMap(), compId: this.compId};
			var marker = new ibm.tivoli.fwm.mxmap.impl.marker.GmapsMarker(params);
			if(marker && markerData)
			{
				marker.addData(markerData);
			}
			var propMarker = marker.toProprietary();
			// This line ensures that the "mxmapMarker" property is added to the marker
			// and it is required when displaying the map tip
			marker.setChild(propMarker);
		}
		return marker;
	},
	removeProviderMarker: function(marker)
	{
		marker.closeBubble();
		marker.remove();
	},
	
	polyline: function(params)
	{
		return new ibm.tivoli.fwm.mxmap.impl.polyline.GmapsPolyline(params);
	},
	
	createProviderPolyline: function(polyline, polylineData)
	{
		var propPolyline = null;
		if(polyline)
		{
			if(polyline.points)
			{
				if(polylineData)
				{
					polyline.addData(polylineData);
				}
				
				propPolyline = polyline.toProprietary();
				propPolyline.setMap(this.getProviderMap());
			}
		}
		return propPolyline;
	},

	
	removeProviderPolyline: function(polyline)
	{
		polyline.proprietary_polyline.setMap(null);
	},
	
	/* enables or disables the traffic layer */
	trafficLayer: null,
	setShowTraffic: function(state)
	{
		var map = this.getProviderMap();
		if (state == true)
		{
			if (this.trafficLayer == null)
			{
				this.trafficLayer = new google.maps.TrafficLayer();
				this.trafficLayer.setMap(map);
			}
		}
		else
		{
			if (this.trafficLayer != null)
			{
				this.trafficLayer.setMap(null);
				this.trafficLayer = null;
			}
		}
	},
	
	pointToProprietary: function(point)
	{
		return new google.maps.LatLng(point.lat, point.lng);
	},

	pointFromProprietary: function(point)
	{
		if(!point)
		{
			return null;
		}
		return this.latLng(point.lat(), point.lng(), null);
	},
	latLng: function(lat, lng, sr)
	{
		var params = {lat: lat, lng: lng, sr: sr};
		return new ibm.tivoli.fwm.mxmap.impl.point.GmapsLatLonPoint(params);
	},
	
	providerGeocode: function(callback, errorCallback, key, address)
	{
		var geocoder = new ibm.tivoli.fwm.mxmap.impl.geocoder.GmapsGeocoder(callback, errorCallback,
		{
			key : key,
			map : this,
			customParams : this.getGeoCoderConf() 
		});
		geocoder.geocode({
			address : address
		});
	},
	providerReverseGeocode: function(callback, errorCallback, key, lat, lng)
	{
		var geocoder = new ibm.tivoli.fwm.mxmap.impl.geocoder.GmapsGeocoder(callback, errorCallback,
		{
			key : key,
			map : this,
			customParams : this.getGeoCoderConf() 
		});
		geocoder.geocode({
			lat : lat,
			lng : lng
		});
	}
});

});

},
'dojo/require':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["./_base/loader"], function(loader){
	return {
		dynamic:0,
		normalize:function(id){return id;},
		load:loader.require
	};
});

},
'ibm/tivoli/fwm/mxmap/_Geocoder':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/_base/declare"], 
		function(declare) {
	return declare(null, {
		geocoder: null,

		constructor: function(callback, error_callback, optParams)
		{
			this.callback = callback;
			this.error_callback = error_callback || function(){};
			this.optParams = optParams;
			this._init();
		},
		_init: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},
		geocode: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},
		geocode_callback: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		}
	});
});

},
'ibm/tivoli/fwm/mxmap/toolbar/ext/_ComboTool':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2012,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */


define(["dojo/main","dijit/main", "dojox/main",
	"dojo/_base/declare", 
	"ibm/tivoli/fwm/mxmap/_Base",
	"dijit/Menu",
	"dijit/MenuItem",
	"dijit/form/ComboButton",
	"ibm/tivoli/fwm/mxmap/toolbar/ext/_ToggleTool",
	"ibm/tivoli/fwm/mxmap/toolbar/ext/ToggleComboButton"], 
	function(dojo, dijit, dojox, declare, _Base, Menu, MenuItem, ComboButton, _ToggleTool, ToggleComboButton ) {
	return declare([_ToggleTool], {
		_menu: null,
		_selectedOption: null,
		constructor: function(params)
		{
			dojo.mixin(this, params);
			this._menu = new dijit.Menu();
		},
		// All menu items must be added prior to button creation
		addMenuItem: function(menuItemId, menuItemLabel, defaultMenuItem)
		{
			if(menuItemId != undefined && menuItemLabel != undefined)
			{
				var existingItem = dijit.byId(menuItemId);
				if (existingItem) {
					existingItem.destroyRecursive(true);
				}
				var menuItem = new dijit.MenuItem({
					id: menuItemId,
					iconClass: defaultMenuItem == true ? "menuItemSelected" : "menuItemUnselected",
							label: menuItemLabel
				});
				if(defaultMenuItem == true)
				{
					this._selectedOption = menuItem;
				}

				this._menu.addChild(menuItem);
			}
			else
			{
				console.error("[_ComboTool] Menu items must have an ID and a label");
			}
		},
		createToolbarButton: function()
		{
			this._button = new ToggleComboButton({
				label: this.label,
				showLabel: false,
				iconClass: this.iconClass,
				"class": "mapComboTool",
				dropDown: this._menu,
				onClick: dojo.hitch(this, function()
						{
					this.execute({menuItem: this.getSelectedOption()});
						})

			});
			this.addConnection("onItemClick", dojo.hitch(this,this._onMenuItemClick), this._menu, this);
			return this._button;
		},
		_onMenuItemClick: function(evt)
		{
			var menuItems = this._menu.getChildren();
			for(var i = 0; i < menuItems.length; i++)
			{
				if(menuItems[i] == evt)
				{
					this._selectedOption = evt;
					this._selectedOption.set("iconClass", "menuItemSelected"); 
				}
				else
				{
					menuItems[i].set("iconClass", "menuItemUnselected"); 
				}
			}
			this.setActive(true);
			this.executeOn({menuItem: this.getSelectedOption()});
		},
		getSelectedOption: function()
		{
			return this._selectedOption;
		},
		destroyRecursive: function()
		{
			this._menu.destroyRecursive();
			this.inherited(arguments);
		}

	});
});

},
'dijit/Dialog':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"require",
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/Deferred", // Deferred
	"dojo/dom", // dom.isDescendant
	"dojo/dom-class", // domClass.add domClass.contains
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/_base/fx", // fx.fadeIn fx.fadeOut
	"dojo/i18n", // i18n.getLocalization
	"dojo/keys",
	"dojo/_base/lang", // lang.mixin lang.hitch
	"dojo/on",
	"dojo/ready",
	"dojo/sniff", // has("ie") has("opera") has("dijit-legacy-requires")
	"dojo/touch",
	"dojo/window", // winUtils.getBox, winUtils.get
	"dojo/dnd/Moveable", // Moveable
	"dojo/dnd/TimedMoveable", // TimedMoveable
	"./focus",
	"./_base/manager", // manager.defaultDuration
	"./_Widget",
	"./_TemplatedMixin",
	"./_CssStateMixin",
	"./form/_FormMixin",
	"./_DialogMixin",
	"./DialogUnderlay",
	"./layout/ContentPane",
	"./layout/utils",
	"dojo/text!./templates/Dialog.html",
	"./a11yclick",	// template uses ondijitclick
	"dojo/i18n!./nls/common"
], function(require, array, aspect, declare, Deferred,
			dom, domClass, domGeometry, domStyle, fx, i18n, keys, lang, on, ready, has, touch, winUtils,
			Moveable, TimedMoveable, focus, manager, _Widget, _TemplatedMixin, _CssStateMixin, _FormMixin, _DialogMixin,
			DialogUnderlay, ContentPane, utils, template){

	// module:
	//		dijit/Dialog

	var resolvedDeferred = new Deferred();
	resolvedDeferred.resolve(true);

	function nop(){}

	var _DialogBase = declare("dijit._DialogBase" + (has("dojo-bidi") ? "_NoBidi" : ""), [_TemplatedMixin, _FormMixin, _DialogMixin, _CssStateMixin], {
		templateString: template,

		baseClass: "dijitDialog",

		cssStateNodes: {
			closeButtonNode: "dijitDialogCloseIcon"
		},

		// Map widget attributes to DOMNode attributes.
		_setTitleAttr: { node: "titleNode", type: "innerHTML" },

		// open: [readonly] Boolean
		//		True if Dialog is currently displayed on screen.
		open: false,

		// duration: Integer
		//		The time in milliseconds it takes the dialog to fade in and out
		duration: manager.defaultDuration,

		// refocus: Boolean
		//		A Toggle to modify the default focus behavior of a Dialog, which
		//		is to re-focus the element which had focus before being opened.
		//		False will disable refocusing. Default: true
		refocus: true,

		// autofocus: Boolean
		//		A Toggle to modify the default focus behavior of a Dialog, which
		//		is to focus on the first dialog element after opening the dialog.
		//		False will disable autofocusing. Default: true
		autofocus: true,

		// _firstFocusItem: [private readonly] DomNode
		//		The pointer to the first focusable node in the dialog.
		//		Set by `dijit/_DialogMixin._getFocusItems()`.
		_firstFocusItem: null,

		// _lastFocusItem: [private readonly] DomNode
		//		The pointer to which node has focus prior to our dialog.
		//		Set by `dijit/_DialogMixin._getFocusItems()`.
		_lastFocusItem: null,

		// draggable: Boolean
		//		Toggles the movable aspect of the Dialog. If true, Dialog
		//		can be dragged by it's title. If false it will remain centered
		//		in the viewport.
		draggable: true,
		_setDraggableAttr: function(/*Boolean*/ val){
			// Avoid _WidgetBase behavior of copying draggable attribute to this.domNode,
			// as that prevents text select on modern browsers (#14452)
			this._set("draggable", val);
		},

		// maxRatio: Number
		//		Maximum size to allow the dialog to expand to, relative to viewport size
		maxRatio: 0.9,

		// closable: Boolean
		//		Dialog show [x] icon to close itself, and ESC key will close the dialog.
		closable: true,
		_setClosableAttr: function(val){
			this.closeButtonNode.style.display = val ? "" : "none";
			this._set("closable", val);
		},

		postMixInProperties: function(){
			var _nlsResources = i18n.getLocalization("dijit", "common");
			lang.mixin(this, _nlsResources);
			this.inherited(arguments);
		},

		postCreate: function(){
			domStyle.set(this.domNode, {
				display: "none",
				position: "absolute"
			});
			this.ownerDocumentBody.appendChild(this.domNode);

			this.inherited(arguments);

			aspect.after(this, "onExecute", lang.hitch(this, "hide"), true);
			aspect.after(this, "onCancel", lang.hitch(this, "hide"), true);
			on(this.closeButtonNode, touch.press, function(e){
				e.stopPropagation();
			});

			this._modalconnects = [];
		},

		onLoad: function(){
			// summary:
			//		Called when data has been loaded from an href.
			//		Unlike most other callbacks, this function can be connected to (via `dojo.connect`)
			//		but should *not* be overridden.
			// tags:
			//		callback

			// when href is specified we need to reposition the dialog after the data is loaded
			// and find the focusable elements
			this.resize();
			this._position();

			if(this.autofocus && DialogLevelManager.isTop(this)){
				this._getFocusItems();
				focus.focus(this._firstFocusItem);
			}

			this.inherited(arguments);
		},

		focus: function(){
			this._getFocusItems();
			focus.focus(this._firstFocusItem);
		},

		_endDrag: function(){
			// summary:
			//		Called after dragging the Dialog. Saves the position of the dialog in the viewport,
			//		and also adjust position to be fully within the viewport, so user doesn't lose access to handle
			var nodePosition = domGeometry.position(this.domNode),
				viewport = winUtils.getBox(this.ownerDocument);
			nodePosition.y = Math.min(Math.max(nodePosition.y, 0), (viewport.h - nodePosition.h));
			nodePosition.x = Math.min(Math.max(nodePosition.x, 0), (viewport.w - nodePosition.w));
			this._relativePosition = nodePosition;
			this._position();
		},

		_setup: function(){
			// summary:
			//		Stuff we need to do before showing the Dialog for the first
			//		time (but we defer it until right beforehand, for
			//		performance reasons).
			// tags:
			//		private

			var node = this.domNode;

			if(this.titleBar && this.draggable){
				this._moveable = new ((has("ie") == 6) ? TimedMoveable // prevent overload, see #5285
					: Moveable)(node, { handle: this.titleBar });
				aspect.after(this._moveable, "onMoveStop", lang.hitch(this, "_endDrag"), true);
			}else{
				domClass.add(node, "dijitDialogFixed");
			}

			this.underlayAttrs = {
				dialogId: this.id,
				"class": array.map(this["class"].split(/\s/),function(s){
					return s + "_underlay";
				}).join(" "),
				_onKeyDown: lang.hitch(this, "_onKey"),
				ownerDocument: this.ownerDocument
			};
		},

		_size: function(){
			// TODO: remove for 2.0
			this.resize();
		},

		_position: function(){
			// summary:
			//		Position the dialog in the viewport.  If no relative offset
			//		in the viewport has been determined (by dragging, for instance),
			//		center the dialog.  Otherwise, use the Dialog's stored relative offset,
			//		clipped to fit inside the viewport (which may have been shrunk).
			//		Finally, adjust position according to viewport's scroll.

			if(!domClass.contains(this.ownerDocumentBody, "dojoMove")){    // don't do anything if called during auto-scroll
				var node = this.domNode,
					viewport = winUtils.getBox(this.ownerDocument),
					p = this._relativePosition,
					bb = domGeometry.position(node),
					l = Math.floor(viewport.l + (p ? Math.min(p.x, viewport.w - bb.w) : (viewport.w - bb.w) / 2)),
					t = Math.floor(viewport.t + (p ? Math.min(p.y, viewport.h - bb.h) : (viewport.h - bb.h) / 2));

				domStyle.set(node, {
					left: l + "px",
					top: t + "px"
				});
			}
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles the keyboard events for accessibility reasons
			// tags:
			//		private

			if(evt.keyCode == keys.TAB){
				this._getFocusItems();
				var node = evt.target;
				if(this._firstFocusItem == this._lastFocusItem){
					// don't move focus anywhere, but don't allow browser to move focus off of dialog either
					evt.stopPropagation();
					evt.preventDefault();
				}else if(node == this._firstFocusItem && evt.shiftKey){
					// if we are shift-tabbing from first focusable item in dialog, send focus to last item
					focus.focus(this._lastFocusItem);
					evt.stopPropagation();
					evt.preventDefault();
				}else if(node == this._lastFocusItem && !evt.shiftKey){
					// if we are tabbing from last focusable item in dialog, send focus to first item
					focus.focus(this._firstFocusItem);
					evt.stopPropagation();
					evt.preventDefault();
				}
			}else if(this.closable && evt.keyCode == keys.ESCAPE){
				this.onCancel();
				evt.stopPropagation();
				evt.preventDefault();
			}
		},

		show: function(){
			// summary:
			//		Display the dialog
			// returns: dojo/promise/Promise
			//		Promise object that resolves when the display animation is complete

			if(this.open){
				return resolvedDeferred.promise;
			}

			if(!this._started){
				this.startup();
			}

			// first time we show the dialog, there's some initialization stuff to do
			if(!this._alreadyInitialized){
				this._setup();
				this._alreadyInitialized = true;
			}

			if(this._fadeOutDeferred){
				// There's a hide() operation in progress, so cancel it, but still call DialogLevelManager.hide()
				// as though the hide() completed, in preparation for the DialogLevelManager.show() call below.
				this._fadeOutDeferred.cancel();
				DialogLevelManager.hide(this);
			}

			// Recenter Dialog if user scrolls browser.  Connecting to document doesn't work on IE, need to use window.
			// Be sure that event object doesn't get passed to resize() method, because it's expecting an optional
			// {w: ..., h:...} arg.
			var win = winUtils.get(this.ownerDocument);
			this._modalconnects.push(on(win, "scroll", lang.hitch(this, "resize", null)));

			this._modalconnects.push(on(this.domNode, "keydown", lang.hitch(this, "_onKey")));

			domStyle.set(this.domNode, {
				opacity: 0,
				display: ""
			});

			this._set("open", true);
			this._onShow(); // lazy load trigger

			this.resize();
			this._position();

			// fade-in Animation object, setup below
			var fadeIn;

			this._fadeInDeferred = new Deferred(lang.hitch(this, function(){
				fadeIn.stop();
				delete this._fadeInDeferred;
			}));
			this._fadeInDeferred.then(undefined, nop);	// avoid spurious CancelError message to console

			// If delay is 0, code below will delete this._fadeInDeferred instantly, so grab promise while we can.
			var promise = this._fadeInDeferred.promise;

			fadeIn = fx.fadeIn({
				node: this.domNode,
				duration: this.duration,
				beforeBegin: lang.hitch(this, function(){
					DialogLevelManager.show(this, this.underlayAttrs);
				}),
				onEnd: lang.hitch(this, function(){
					if(this.autofocus && DialogLevelManager.isTop(this)){
						// find focusable items each time dialog is shown since if dialog contains a widget the
						// first focusable items can change
						this._getFocusItems();
						focus.focus(this._firstFocusItem);
					}
					this._fadeInDeferred.resolve(true);
					delete this._fadeInDeferred;
				})
			}).play();

			return promise;
		},

		hide: function(){
			// summary:
			//		Hide the dialog
			// returns: dojo/promise/Promise
			//		Promise object that resolves when the display animation is complete

			// If we haven't been initialized yet then we aren't showing and we can just return.
			// Likewise if we are already hidden, or are currently fading out.
			if(!this._alreadyInitialized || !this.open){
				return resolvedDeferred.promise;
			}
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}

			// fade-in Animation object, setup below
			var fadeOut;

			this._fadeOutDeferred = new Deferred(lang.hitch(this, function(){
				fadeOut.stop();
				delete this._fadeOutDeferred;
			}));
			this._fadeOutDeferred.then(undefined, nop);	// avoid spurious CancelError message to console

			// fire onHide when the promise resolves.
			this._fadeOutDeferred.then(lang.hitch(this, 'onHide'));

			// If delay is 0, code below will delete this._fadeOutDeferred instantly, so grab promise while we can.
			var promise = this._fadeOutDeferred.promise;

			fadeOut = fx.fadeOut({
				node: this.domNode,
				duration: this.duration,
				onEnd: lang.hitch(this, function(){
					this.domNode.style.display = "none";
					DialogLevelManager.hide(this);
					this._fadeOutDeferred.resolve(true);
					delete this._fadeOutDeferred;
				})
			}).play();

			if(this._scrollConnected){
				this._scrollConnected = false;
			}
			var h;
			while(h = this._modalconnects.pop()){
				h.remove();
			}

			if(this._relativePosition){
				delete this._relativePosition;
			}
			this._set("open", false);

			return promise;
		},

		resize: function(dim){
			// summary:
			//		Called with no argument when viewport scrolled or viewport size changed.  Adjusts Dialog as
			//		necessary to keep it visible.
			//
			//		Can also be called with an argument (by dojox/layout/ResizeHandle etc.) to explicitly set the
			//		size of the dialog.
			// dim: Object?
			//		Optional dimension object like {w: 200, h: 300}

			if(this.domNode.style.display != "none"){

				this._checkIfSingleChild();

				if(!dim){
					if(this._shrunk){
						// If we earlier shrunk the dialog to fit in the viewport, reset it to its natural size
						if(this._singleChild){
							if(typeof this._singleChildOriginalStyle != "undefined"){
								this._singleChild.domNode.style.cssText = this._singleChildOriginalStyle;
								delete this._singleChildOriginalStyle;
							}
						}
						array.forEach([this.domNode, this.containerNode, this.titleBar, this.actionBarNode], function(node){
							if(node){	// because titleBar may not be defined
								domStyle.set(node, {
									position: "static",
									width: "auto",
									height: "auto"
								});
							}
						});
						this.domNode.style.position = "absolute";
					}

					// If necessary, shrink Dialog to fit in viewport and have some space around it
					// to indicate that it's a popup.  This will also compensate for possible scrollbars on viewport.
					var viewport = winUtils.getBox(this.ownerDocument);
					viewport.w *= this.maxRatio;
					viewport.h *= this.maxRatio;

					var bb = domGeometry.position(this.domNode);
					this._shrunk = false;
					// First check and limit width, because limiting the width may increase the height due to word wrapping.
					if(bb.w >= viewport.w){
						dim = {
							w: viewport.w
						};
						domGeometry.setMarginBox(this.domNode, dim);
						bb = domGeometry.position(this.domNode);
						this._shrunk = true;
					}
					// Now check and limit the height
					if(bb.h >= viewport.h){
						if(!dim){
							dim = {
								w: bb.w
							};
						}
						dim.h = viewport.h;
						this._shrunk = true;
					}
					if(dim){
						if(!dim.w){
							dim.w = bb.w;
						}
						if(!dim.h){
							dim.h = bb.h;
						}
					}
				}

				// Code to run if user has requested an explicit size, or the shrinking code above set an implicit size
				if(dim){
					// Set this.domNode to specified size
					domGeometry.setMarginBox(this.domNode, dim);

					// And then size this.containerNode
					var layoutNodes = [];
					if(this.titleBar){
						layoutNodes.push({domNode: this.titleBar, region: "top"});
					}
					if(this.actionBarNode){
						layoutNodes.push({domNode: this.actionBarNode, region: "bottom"});
					}
					var centerSize = {domNode: this.containerNode, region: "center"};
					layoutNodes.push(centerSize);

					var contentDim = utils.marginBox2contentBox(this.domNode, dim);
					utils.layoutChildren(this.domNode, contentDim, layoutNodes);

					// And then if this.containerNode has a single layout widget child, size it too.
					// Otherwise, make this.containerNode show a scrollbar if it's overflowing.
					if(this._singleChild){
						var cb = utils.marginBox2contentBox(this.containerNode, centerSize);
						// note: if containerNode has padding singleChildSize will have l and t set,
						// but don't pass them to resize() or it will doubly-offset the child
						this._singleChild.resize({w: cb.w, h: cb.h});
						// TODO: save original size for restoring it on another show()?
					}else{
						this.containerNode.style.overflow = "auto";
						this._layoutChildren();		// send resize() event to all child widgets
					}
				}else{
					this._layoutChildren();		// send resize() event to all child widgets
				}

				if(!has("touch") && !dim){
					// If the user has scrolled the viewport then reposition the Dialog.  But don't do it for touch
					// devices, because it will counteract when a keyboard pops up and then the browser auto-scrolls
					// the focused node into view.
					this._position();
				}
			}
		},

		_layoutChildren: function(){
			// Override _ContentPaneResizeMixin._layoutChildren because even when there's just a single layout child
			// widget, sometimes we don't want to size it explicitly (i.e. to pass a dim argument to resize())

			array.forEach(this.getChildren(), function(widget){
				if(widget.resize){
					widget.resize();
				}
			});
		},

		destroy: function(){
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}
			if(this._fadeOutDeferred){
				this._fadeOutDeferred.cancel();
			}
			if(this._moveable){
				this._moveable.destroy();
			}
			var h;
			while(h = this._modalconnects.pop()){
				h.remove();
			}

			DialogLevelManager.hide(this);

			this.inherited(arguments);
		}
	});

	if(has("dojo-bidi")){
		_DialogBase = declare("dijit._DialogBase", _DialogBase, {
			_setTitleAttr: function(/*String*/ title){
				this._set("title", title);
				this.titleNode.innerHTML = title;
				this.applyTextDir(this.titleNode);
			},

			_setTextDirAttr: function(textDir){
				if(this._created && this.textDir != textDir){
					this._set("textDir", textDir);
					this.set("title", this.title);
				}
			}
		});
	}

	var Dialog = declare("dijit.Dialog", [ContentPane, _DialogBase], {
		// summary:
		//		A modal dialog Widget.
		// description:
		//		Pops up a modal dialog window, blocking access to the screen
		//		and also graying out the screen Dialog is extended from
		//		ContentPane so it supports all the same parameters (href, etc.).
		// example:
		// |	<div data-dojo-type="dijit/Dialog" data-dojo-props="href: 'test.html'"></div>
		// example:
		// |	var foo = new Dialog({ title: "test dialog", content: "test content" });
		// |	foo.placeAt(win.body());
		// |	foo.startup();
	});
	Dialog._DialogBase = _DialogBase;	// for monkey patching and dojox/widget/DialogSimple

	var DialogLevelManager = Dialog._DialogLevelManager = {
		// summary:
		//		Controls the various active "levels" on the page, starting with the
		//		stuff initially visible on the page (at z-index 0), and then having an entry for
		//		each Dialog shown.

		_beginZIndex: 950,

		show: function(/*dijit/_WidgetBase*/ dialog, /*Object*/ underlayAttrs){
			// summary:
			//		Call right before fade-in animation for new dialog.
			//		Saves current focus, displays/adjusts underlay for new dialog,
			//		and sets the z-index of the dialog itself.
			//
			//		New dialog will be displayed on top of all currently displayed dialogs.
			//
			//		Caller is responsible for setting focus in new dialog after the fade-in
			//		animation completes.

			// Save current focus
			ds[ds.length - 1].focus = focus.curNode;

			// Set z-index a bit above previous dialog
			var zIndex = ds[ds.length - 1].dialog ? ds[ds.length - 1].zIndex + 2 : Dialog._DialogLevelManager._beginZIndex;
			domStyle.set(dialog.domNode, 'zIndex', zIndex);

			// Display the underlay, or if already displayed then adjust for this new dialog
			DialogUnderlay.show(underlayAttrs, zIndex - 1);

			ds.push({dialog: dialog, underlayAttrs: underlayAttrs, zIndex: zIndex});
		},

		hide: function(/*dijit/_WidgetBase*/ dialog){
			// summary:
			//		Called when the specified dialog is hidden/destroyed, after the fade-out
			//		animation ends, in order to reset page focus, fix the underlay, etc.
			//		If the specified dialog isn't open then does nothing.
			//
			//		Caller is responsible for either setting display:none on the dialog domNode,
			//		or calling dijit/popup.hide(), or removing it from the page DOM.

			if(ds[ds.length - 1].dialog == dialog){
				// Removing the top (or only) dialog in the stack, return focus
				// to previous dialog

				ds.pop();

				var pd = ds[ds.length - 1];	// the new active dialog (or the base page itself)

				// Adjust underlay
				if(ds.length == 1){
					// Returning to original page.  Hide the underlay.
					DialogUnderlay.hide();
				}else{
					// Popping back to previous dialog, adjust underlay.
					DialogUnderlay.show(pd.underlayAttrs, pd.zIndex - 1);
				}

				// Adjust focus.
				// TODO: regardless of setting of dialog.refocus, if the exeucte() method set focus somewhere,
				// don't shift focus back to button.  Note that execute() runs at the start of the fade-out but
				// this code runs later, at the end of the fade-out.  Menu has code like this.
				if(dialog.refocus){
					// If we are returning control to a previous dialog but for some reason
					// that dialog didn't have a focused field, set focus to first focusable item.
					// This situation could happen if two dialogs appeared at nearly the same time,
					// since a dialog doesn't set it's focus until the fade-in is finished.
					var focus = pd.focus;
					if(pd.dialog && (!focus || !dom.isDescendant(focus, pd.dialog.domNode))){
						pd.dialog._getFocusItems();
						focus = pd.dialog._firstFocusItem;
					}

					if(focus){
						// Refocus the button that spawned the Dialog.   This will fail in corner cases including
						// page unload on IE, because the dijit/form/Button that launched the Dialog may get destroyed
						// before this code runs.  (#15058)
						try{
							focus.focus();
						}catch(e){
						}
					}
				}
			}else{
				// Removing a dialog out of order (#9944, #10705).
				// Don't need to mess with underlay or z-index or anything.
				var idx = array.indexOf(array.map(ds, function(elem){
					return elem.dialog;
				}), dialog);
				if(idx != -1){
					ds.splice(idx, 1);
				}
			}
		},

		isTop: function(/*dijit/_WidgetBase*/ dialog){
			// summary:
			//		Returns true if specified Dialog is the top in the task
			return ds[ds.length - 1].dialog == dialog;
		}
	};

	// Stack representing the various active "levels" on the page, starting with the
	// stuff initially visible on the page (at z-index 0), and then having an entry for
	// each Dialog shown.
	// Each element in stack has form {
	//		dialog: dialogWidget,
	//		focus: returnFromGetFocus(),
	//		underlayAttrs: attributes to set on underlay (when this widget is active)
	// }
	var ds = Dialog._dialogStack = [
		{dialog: null, focus: null, underlayAttrs: null}    // entry for stuff at z-index: 0
	];

	// If focus was accidentally removed from the dialog, such as if the user clicked a blank
	// area of the screen, or clicked the browser's address bar and then tabbed into the page,
	// then refocus.   Won't do anything if focus was removed because the Dialog was closed, or
	// because a new Dialog popped up on top of the old one, or when focus moves to popups
	focus.watch("curNode", function(attr, oldNode, node){
 		// Note: if no dialogs, ds.length==1 but ds[ds.length-1].dialog is null
		var topDialog = ds[ds.length - 1].dialog;

		// If a node was focused, and there's a Dialog currently showing, and not in the process of fading out...
		// Ignore focus events on other document though because it's likely an Editor inside of the Dialog.
		if(node && topDialog && !topDialog._fadeOutDeferred && node.ownerDocument == topDialog.ownerDocument){
			// If the node that was focused is inside the dialog or in a popup, even a context menu that isn't
			// technically a descendant of the the dialog, don't do anything.
			do{
				if(node == topDialog.domNode || domClass.contains(node, "dijitPopup")){ return; }
			}while(node = node.parentNode);

			// Otherwise, return focus to the dialog.  Use a delay to avoid confusing dijit/focus code's
			// own tracking of focus.
			topDialog.focus();
		}
	});

	// Back compat w/1.6, remove for 2.0
	if(has("dijit-legacy-requires")){
		ready(0, function(){
			var requires = ["dijit/TooltipDialog"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return Dialog;
});

},
'dijit/a11y':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/dom",			// dom.byId
	"dojo/dom-attr", // domAttr.attr domAttr.has
	"dojo/dom-style", // domStyle.style
	"dojo/_base/lang", // lang.mixin()
	"dojo/sniff", // has("ie")  1 
	"./main"	// for exporting methods to dijit namespace
], function(array, dom, domAttr, domStyle, lang, has, dijit){

	// module:
	//		dijit/a11y

	var undefined;

	var a11y = {
		// summary:
		//		Accessibility utility functions (keyboard, tab stops, etc.)

		_isElementShown: function(/*Element*/ elem){
			var s = domStyle.get(elem);
			return (s.visibility != "hidden")
				&& (s.visibility != "collapsed")
				&& (s.display != "none")
				&& (domAttr.get(elem, "type") != "hidden");
		},

		hasDefaultTabStop: function(/*Element*/ elem){
			// summary:
			//		Tests if element is tab-navigable even without an explicit tabIndex setting

			// No explicit tabIndex setting, need to investigate node type
			switch(elem.nodeName.toLowerCase()){
				case "a":
					// An <a> w/out a tabindex is only navigable if it has an href
					return domAttr.has(elem, "href");
				case "area":
				case "button":
				case "input":
				case "object":
				case "select":
				case "textarea":
					// These are navigable by default
					return true;
				case "iframe":
					// If it's an editor <iframe> then it's tab navigable.
					var body;
					try{
						// non-IE
						var contentDocument = elem.contentDocument;
						if("designMode" in contentDocument && contentDocument.designMode == "on"){
							return true;
						}
						body = contentDocument.body;
					}catch(e1){
						// contentWindow.document isn't accessible within IE7/8
						// if the iframe.src points to a foreign url and this
						// page contains an element, that could get focus
						try{
							body = elem.contentWindow.document.body;
						}catch(e2){
							return false;
						}
					}
					return body && (body.contentEditable == 'true' ||
						(body.firstChild && body.firstChild.contentEditable == 'true'));
				default:
					return elem.contentEditable == 'true';
			}
		},

		effectiveTabIndex: function(/*Element*/ elem){
			// summary:
			//		Returns effective tabIndex of an element, either a number, or undefined if element isn't focusable.

			if(domAttr.get(elem, "disabled")){
				return undefined;
			}else if(domAttr.has(elem, "tabIndex")){
				// Explicit tab index setting
				return +domAttr.get(elem, "tabIndex");// + to convert string --> number
			}else{
				// No explicit tabIndex setting, so depends on node type
				return a11y.hasDefaultTabStop(elem) ? 0 : undefined;
			}
		},

		isTabNavigable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is tab-navigable

			return a11y.effectiveTabIndex(elem) >= 0;
		},

		isFocusable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is focusable by tabbing to it, or clicking it with the mouse.

			return a11y.effectiveTabIndex(elem) >= -1;
		},

		_getTabNavigable: function(/*DOMNode*/ root){
			// summary:
			//		Finds descendants of the specified root node.
			// description:
			//		Finds the following descendants of the specified root node:
			//
			//		- the first tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the last tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the first element in document order with the lowest
			//		  positive tabIndex value
			//		- the last element in document order with the highest
			//		  positive tabIndex value
			var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};

			function radioName(node){
				// If this element is part of a radio button group, return the name for that group.
				return node && node.tagName.toLowerCase() == "input" &&
					node.type && node.type.toLowerCase() == "radio" &&
					node.name && node.name.toLowerCase();
			}

			var shown = a11y._isElementShown, effectiveTabIndex = a11y.effectiveTabIndex;
			var walkTree = function(/*DOMNode*/ parent){
				for(var child = parent.firstChild; child; child = child.nextSibling){
					// Skip text elements, hidden elements, and also non-HTML elements (those in custom namespaces) in IE,
					// since show() invokes getAttribute("type"), which crash on VML nodes in IE.
					if(child.nodeType != 1 || (has("ie") <= 9 && child.scopeName !== "HTML") || !shown(child)){
						continue;
					}

					var tabindex = effectiveTabIndex(child);
					if(tabindex >= 0){
						if(tabindex == 0){
							if(!first){
								first = child;
							}
							last = child;
						}else if(tabindex > 0){
							if(!lowest || tabindex < lowestTabindex){
								lowestTabindex = tabindex;
								lowest = child;
							}
							if(!highest || tabindex >= highestTabindex){
								highestTabindex = tabindex;
								highest = child;
							}
						}
						var rn = radioName(child);
						if(domAttr.get(child, "checked") && rn){
							radioSelected[rn] = child;
						}
					}
					if(child.nodeName.toUpperCase() != 'SELECT'){
						walkTree(child);
					}
				}
			};
			if(shown(root)){
				walkTree(root);
			}
			function rs(node){
				// substitute checked radio button for unchecked one, if there is a checked one with the same name.
				return radioSelected[radioName(node)] || node;
			}

			return { first: rs(first), last: rs(last), lowest: rs(lowest), highest: rs(highest) };
		},

		getFirstInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is first in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.lowest ? elems.lowest : elems.first; // DomNode
		},

		getLastInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is last in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.last ? elems.last : elems.highest; // DomNode
		}
	};

	 1  && lang.mixin(dijit, a11y);

	return a11y;
});

},
'dijit/form/_ToggleButtonMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/dom-attr" // domAttr.set
], function(declare, domAttr){

	// module:
	//		dijit/form/_ToggleButtonMixin

	return declare("dijit.form._ToggleButtonMixin", null, {
		// summary:
		//		A mixin to provide functionality to allow a button that can be in two states (checked or not).

		// checked: Boolean
		//		Corresponds to the native HTML `<input>` element's attribute.
		//		In markup, specified as "checked='checked'" or just "checked".
		//		True if the button is depressed, or the checkbox is checked,
		//		or the radio button is selected, etc.
		checked: false,

		// aria-pressed for toggle buttons, and aria-checked for checkboxes
		_aria_attr: "aria-pressed",

		_onClick: function(/*Event*/ evt){
			var original = this.checked;
			this._set('checked', !original); // partially set the toggled value, assuming the toggle will work, so it can be overridden in the onclick handler
			var ret = this.inherited(arguments); // the user could reset the value here
			this.set('checked', ret ? this.checked : original); // officially set the toggled or user value, or reset it back
			return ret;
		},

		_setCheckedAttr: function(/*Boolean*/ value, /*Boolean?*/ priorityChange){
			this._set("checked", value);
			var node = this.focusNode || this.domNode;
			if(this._created){ // IE is not ready to handle checked attribute (affects tab order)
				// needlessly setting "checked" upsets IE's tab order
				if(domAttr.get(node, "checked") != !!value){
					domAttr.set(node, "checked", !!value); // "mixed" -> true
				}
			}
			node.setAttribute(this._aria_attr, String(value)); // aria values should be strings
			this._handleOnChange(value, priorityChange);
		},

		postCreate: function(){ // use postCreate instead of startup so users forgetting to call startup are OK
			this.inherited(arguments);
			var node = this.focusNode || this.domNode;
			if(this.checked){
				// need this here instead of on the template so IE8 tab order works
				node.setAttribute('checked', 'checked');
			}

			// Update our reset value if it hasn't yet been set (because this.set()
			// is only called when there *is* a value)
			if(this._resetValue === undefined){
				this._lastValueReported = this._resetValue = this.checked;
			}
		},

		reset: function(){
			// summary:
			//		Reset the widget's value to what it was at initialization time

			this._hasBeenBlurred = false;

			// set checked state to original setting
			this.set('checked', this.params.checked || false);
		}
	});
});

},
'dijit/_Widget':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/aspect",	// aspect.around
	"dojo/_base/config",	// config.isDebug
	"dojo/_base/connect",	// connect.connect
	"dojo/_base/declare", // declare
	"dojo/has",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch
	"dojo/query",
	"dojo/ready",
	"./registry",	// registry.byNode
	"./_WidgetBase",
	"./_OnDijitClickMixin",
	"./_FocusMixin",
	"dojo/uacss",		// browser sniffing (included for back-compat; subclasses may be using)
	"./hccss"		// high contrast mode sniffing (included to set CSS classes on <body>, module ret value unused)
], function(aspect, config, connect, declare, has, kernel, lang, query, ready,
			registry, _WidgetBase, _OnDijitClickMixin, _FocusMixin){


// module:
//		dijit/_Widget


function connectToDomNode(){
	// summary:
	//		If user connects to a widget method === this function, then they will
	//		instead actually be connecting the equivalent event on this.domNode
}

// Trap dojo.connect() calls to connectToDomNode methods, and redirect to _Widget.on()
function aroundAdvice(originalConnect){
	return function(obj, event, scope, method){
		if(obj && typeof event == "string" && obj[event] == connectToDomNode){
			return obj.on(event.substring(2).toLowerCase(), lang.hitch(scope, method));
		}
		return originalConnect.apply(connect, arguments);
	};
}
aspect.around(connect, "connect", aroundAdvice);
if(kernel.connect){
	aspect.around(kernel, "connect", aroundAdvice);
}

var _Widget = declare("dijit._Widget", [_WidgetBase, _OnDijitClickMixin, _FocusMixin], {
	// summary:
	//		Old base class for widgets.   New widgets should extend `dijit/_WidgetBase` instead
	// description:
	//		Old Base class for Dijit widgets.
	//
	//		Extends _WidgetBase, adding support for:
	//
	//		- declaratively/programatically specifying widget initialization parameters like
	//			onMouseMove="foo" that call foo when this.domNode gets a mousemove event
	//		- ondijitclick:
	//			Support new data-dojo-attach-event="ondijitclick: ..." that is triggered by a mouse click or a SPACE/ENTER keypress
	//		- focus related functions:
	//			In particular, the onFocus()/onBlur() callbacks.   Driven internally by
	//			dijit/_base/focus.js.
	//		- deprecated methods
	//		- onShow(), onHide(), onClose()
	//
	//		Also, by loading code in dijit/_base, turns on:
	//
	//		- browser sniffing (putting browser class like `dj_ie` on `<html>` node)
	//		- high contrast mode sniffing (add `dijit_a11y` class to `<body>` if machine is in high contrast mode)


	////////////////// DEFERRED CONNECTS ///////////////////

	onClick: connectToDomNode,
	/*=====
	onClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: connectToDomNode,
	/*=====
	onDblClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: connectToDomNode,
	/*=====
	onKeyDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: connectToDomNode,
	/*=====
	onKeyPress: function(event){
		// summary:
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: connectToDomNode,
	/*=====
	onKeyUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: connectToDomNode,
	/*=====
	onMouseDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: connectToDomNode,
	/*=====
	onMouseMove: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: connectToDomNode,
	/*=====
	onMouseOut: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: connectToDomNode,
	/*=====
	onMouseOver: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: connectToDomNode,
	/*=====
	onMouseLeave: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: connectToDomNode,
	/*=====
	onMouseEnter: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: connectToDomNode,
	/*=====
	onMouseUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	constructor: function(params /*===== ,srcNodeRef =====*/){
		// summary:
		//		Create the widget.
		// params: Object|null
		//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
		//		and functions, typically callbacks like onClick.
		//		The hash can contain any of the widget's properties, excluding read-only properties.
		// srcNodeRef: DOMNode|String?
		//		If a srcNodeRef (DOM node) is specified:
		//
		//		- use srcNodeRef.innerHTML as my contents
		//		- if this is a behavioral widget then apply behavior to that srcNodeRef
		//		- otherwise, replace srcNodeRef with my generated DOM tree

		// extract parameters like onMouseMove that should connect directly to this.domNode
		this._toConnect = {};
		for(var name in params){
			if(this[name] === connectToDomNode){
				this._toConnect[name.replace(/^on/, "").toLowerCase()] = params[name];
				delete params[name];
			}
		}
	},

	postCreate: function(){
		this.inherited(arguments);

		// perform connection from this.domNode to user specified handlers (ex: onMouseMove)
		for(var name in this._toConnect){
			this.on(name, this._toConnect[name]);
		}
		delete this._toConnect;
	},

	on: function(/*String|Function*/ type, /*Function*/ func){
		if(this[this._onMap(type)] === connectToDomNode){
			// Use connect.connect() rather than on() to get handling for "onmouseenter" on non-IE,
			// normalization of onkeypress/onkeydown to behave like firefox, etc.
			// Also, need to specify context as "this" rather than the default context of the DOMNode
			// Remove in 2.0.
			return connect.connect(this.domNode, type.toLowerCase(), this, func);
		}
		return this.inherited(arguments);
	},

	_setFocusedAttr: function(val){
		// Remove this method in 2.0 (or sooner), just here to set _focused == focused, for back compat
		// (but since it's a private variable we aren't required to keep supporting it).
		this._focused = val;
		this._set("focused", val);
	},

	////////////////// DEPRECATED METHODS ///////////////////

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use set() instead.
		// tags:
		//		deprecated
		kernel.deprecated(this.declaredClass+"::setAttribute(attr, value) is deprecated. Use set() instead.", "", "2.0");
		this.set(attr, value);
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		// summary:
		//		This method is deprecated, use get() or set() directly.
		// name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		// value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		// tags:
		//		deprecated

		var args = arguments.length;
		if(args >= 2 || typeof name === "object"){ // setter
			return this.set.apply(this, arguments);
		}else{ // getter
			return this.get(name);
		}
	},

	getDescendants: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		This method should generally be avoided as it returns widgets declared in templates, which are
		//		supposed to be internal/hidden, but it's left here for back-compat reasons.

		kernel.deprecated(this.declaredClass+"::getDescendants() is deprecated. Use getChildren() instead.", "", "2.0");
		return this.containerNode ? query('[widgetId]', this.containerNode).map(registry.byNode) : []; // dijit/_WidgetBase[]
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	_onShow: function(){
		// summary:
		//		Internal method called when this widget is made visible.
		//		See `onShow` for details.
		this.onShow();
	},

	onShow: function(){
		// summary:
		//		Called when this widget becomes the selected pane in a
		//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
		//		`dijit/layout/AccordionContainer`, etc.
		//
		//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onHide: function(){
		// summary:
		//		Called when another widget becomes the selected pane in a
		//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
		//		`dijit/layout/AccordionContainer`, etc.
		//
		//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onClose: function(){
		// summary:
		//		Called when this widget is being displayed as a popup (ex: a Calendar popped
		//		up from a DateTextBox), and it is hidden.
		//		This is called from the dijit.popup code, and should not be called directly.
		//
		//		Also used as a parameter for children of `dijit/layout/StackContainer` or subclasses.
		//		Callback if a user tries to close the child.   Child will be closed if this function returns true.
		// tags:
		//		extension

		return true;		// Boolean
	}
});

// For back-compat, remove in 2.0.
if(has("dijit-legacy-requires")){
	ready(0, function(){
		var requires = ["dijit/_base"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}
return _Widget;
});

},
'dojo/touch':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define(["./_base/kernel", "./aspect", "./dom", "./dom-class", "./_base/lang", "./on", "./has", "./mouse", "./domReady", "./_base/window"],
function(dojo, aspect, dom, domClass, lang, on, has, mouse, domReady, win){

	// module:
	//		dojo/touch

	var ios4 = has("ios") < 5;

	// Detect if platform supports Pointer Events, and if so, the names of the events (pointerdown vs. MSPointerDown).
	var hasPointer = has("pointer-events") || has("MSPointer"),
		pointer = (function () {
			var pointer = {};
			for (var type in { down: 1, move: 1, up: 1, cancel: 1, over: 1, out: 1 }) {
				pointer[type] = has("MSPointer") ?
					"MSPointer" + type.charAt(0).toUpperCase() + type.slice(1) :
					"pointer" + type;
			}
			return pointer;
		})();

	// Detect if platform supports the webkit touchstart/touchend/... events
	var hasTouch = has("touch-events");

	// Click generation variables
	var clicksInited, clickTracker, useTarget = false, clickTarget, clickX, clickY, clickDx, clickDy, clickTime;

	// Time of most recent touchstart, touchmove, or touchend event
	var lastTouch;

	function dualEvent(mouseType, touchType, pointerType){
		// Returns synthetic event that listens for both the specified mouse event and specified touch event.
		// But ignore fake mouse events that were generated due to the user touching the screen.
		if(hasPointer && pointerType){
			// IE10+: MSPointer* events are designed to handle both mouse and touch in a uniform way,
			// so just use that regardless of hasTouch.
			return function(node, listener){
				return on(node, pointerType, listener);
			};
		}else if(hasTouch){
			return function(node, listener){
				var handle1 = on(node, touchType, function(evt){
						listener.call(this, evt);

						// On slow mobile browsers (see https://bugs.dojotoolkit.org/ticket/17634),
						// a handler for a touch event may take >1s to run.  That time shouldn't
						// be included in the calculation for lastTouch.
						lastTouch = (new Date()).getTime();
					}),
					handle2 = on(node, mouseType, function(evt){
						if(!lastTouch || (new Date()).getTime() > lastTouch + 1000){
							listener.call(this, evt);
						}
					});
				return {
					remove: function(){
						handle1.remove();
						handle2.remove();
					}
				};
			};
		}else{
			// Avoid creating listeners for touch events on performance sensitive older browsers like IE6
			return function(node, listener){
				return on(node, mouseType, listener);
			};
		}
	}

	function marked(/*DOMNode*/ node){
		// Search for node ancestor has been marked with the dojoClick property to indicate special processing.
		// Returns marked ancestor.
		do{
			if(node.dojoClick !== undefined){ return node; }
		}while(node = node.parentNode);
	}

	function doClicks(e, moveType, endType){
		// summary:
		//		Setup touch listeners to generate synthetic clicks immediately (rather than waiting for the browser
		//		to generate clicks after the double-tap delay) and consistently (regardless of whether event.preventDefault()
		//		was called in an event listener. Synthetic clicks are generated only if a node or one of its ancestors has
		//		its dojoClick property set to truthy. If a node receives synthetic clicks because one of its ancestors has its
		//      dojoClick property set to truthy, you can disable synthetic clicks on this node by setting its own dojoClick property
		//      to falsy.

		if(mouse.isRight(e)){
			return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
		}

		var markedNode = marked(e.target);
		clickTracker  = !e.target.disabled && markedNode && markedNode.dojoClick; // click threshold = true, number, x/y object, or "useTarget"
		if(clickTracker){
			useTarget = (clickTracker == "useTarget");
			clickTarget = (useTarget?markedNode:e.target);
			if(useTarget){
				// We expect a click, so prevent any other
				// default action on "touchpress"
				e.preventDefault();
			}
			clickX = e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX;
			clickY = e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY;
			clickDx = (typeof clickTracker == "object" ? clickTracker.x : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;
			clickDy = (typeof clickTracker == "object" ? clickTracker.y : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;

			// add move/end handlers only the first time a node with dojoClick is seen,
			// so we don't add too much overhead when dojoClick is never set.
			if(!clicksInited){
				clicksInited = true;

				var updateClickTracker = function updateClickTracker(e){
					if(useTarget){
						clickTracker = dom.isDescendant(
							win.doc.elementFromPoint(
								(e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX),
								(e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY)),
							clickTarget);
					}else{
						clickTracker = clickTracker &&
							(e.changedTouches ? e.changedTouches[0].target : e.target) == clickTarget &&
							Math.abs((e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX) - clickX) <= clickDx &&
							Math.abs((e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY) - clickY) <= clickDy;
					}
				};

				win.doc.addEventListener(moveType, function(e){
					if(mouse.isRight(e)){
						return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
					}
					updateClickTracker(e);
					if(useTarget){
						// prevent native scroll event and ensure touchend is
						// fire after touch moves between press and release.
						e.preventDefault();
					}
				}, true);

				win.doc.addEventListener(endType, function(e){
					if(mouse.isRight(e)){
						return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
					}
					updateClickTracker(e);
					if(clickTracker){
						clickTime = (new Date()).getTime();
						var target = (useTarget?clickTarget:e.target);
						if(target.tagName === "LABEL"){
							// when clicking on a label, forward click to its associated input if any
							target = dom.byId(target.getAttribute("for")) || target;
						}
						//some attributes can be on the Touch object, not on the Event:
						//http://www.w3.org/TR/touch-events/#touch-interface
						var src = (e.changedTouches) ? e.changedTouches[0] : e;
						var createMouseEvent = function createMouseEvent(type){
							//create the synthetic event.
							//http://www.w3.org/TR/DOM-Level-3-Events/#widl-MouseEvent-initMouseEvent
							var evt = document.createEvent("MouseEvents");
							evt._dojo_click = true;
							evt.initMouseEvent(type,
								true, //bubbles
								true, //cancelable
								e.view,
								e.detail,
								src.screenX,
								src.screenY,
								src.clientX,
								src.clientY,
								e.ctrlKey,
								e.altKey,
								e.shiftKey,
								e.metaKey,
								0, //button
								null //related target
							);
							return evt;
						};
						var mouseDownEvt = createMouseEvent("mousedown");
						var mouseUpEvt = createMouseEvent("mouseup");
						var clickEvt = createMouseEvent("click");

						setTimeout(function(){
							on.emit(target, "mousedown", mouseDownEvt);
							on.emit(target, "mouseup", mouseUpEvt);
							on.emit(target, "click", clickEvt);

							// refresh clickTime in case app-defined click handler took a long time to run
							clickTime = (new Date()).getTime();
						}, 0);
					}
				}, true);

				var stopNativeEvents = function stopNativeEvents(type){
					win.doc.addEventListener(type, function(e){
						// Stop native events when we emitted our own click event.  Note that the native click may occur
						// on a different node than the synthetic click event was generated on.  For example,
						// click on a menu item, causing the menu to disappear, and then (~300ms later) the browser
						// sends a click event to the node that was *underneath* the menu.  So stop all native events
						// sent shortly after ours, similar to what is done in dualEvent.
						// The INPUT.dijitOffScreen test is for offscreen inputs used in dijit/form/Button, on which
						// we call click() explicitly, we don't want to stop this event.
						var target = e.target;
						if(clickTracker && !e._dojo_click &&
								(new Date()).getTime() <= clickTime + 1000 &&
								!(target.tagName == "INPUT" && domClass.contains(target, "dijitOffScreen"))){
							e.stopPropagation();
							e.stopImmediatePropagation && e.stopImmediatePropagation();
							if(type == "click" &&
								(target.tagName != "INPUT" ||
								(target.type == "radio" &&
									// #18352 Do not preventDefault for radios that are not dijit or
									// dojox/mobile widgets.
									// (The CSS class dijitCheckBoxInput holds for both checkboxes and radio buttons.)
									(domClass.contains(target, "dijitCheckBoxInput") ||
										domClass.contains(target, "mblRadioButton"))) ||
								(target.type == "checkbox" &&
									// #18352 Do not preventDefault for checkboxes that are not dijit or
									// dojox/mobile widgets.
									(domClass.contains(target, "dijitCheckBoxInput") ||
										domClass.contains(target, "mblCheckBox")))) &&
								target.tagName != "TEXTAREA" && target.tagName != "AUDIO" && target.tagName != "VIDEO"){
								// preventDefault() breaks textual <input>s on android, keyboard doesn't popup,
								// but it is still needed for checkboxes and radio buttons, otherwise in some cases
								// the checked state becomes inconsistent with the widget's state
								e.preventDefault();
							}
						}
					}, true);
				};

				stopNativeEvents("click");

				// We also stop mousedown/up since these would be sent well after with our "fast" click (300ms),
				// which can confuse some dijit widgets.
				stopNativeEvents("mousedown");
				stopNativeEvents("mouseup");
			}
		}
	}

	var hoveredNode;

	if(has("touch")){
		if(hasPointer){
			// MSPointer (IE10+) already has support for over and out, so we just need to init click support
			domReady(function(){
				win.doc.addEventListener(pointer.down, function(evt){
					doClicks(evt, pointer.move, pointer.up);
				}, true);
			});
		}else{
			domReady(function(){
				// Keep track of currently hovered node
				hoveredNode = win.body();	// currently hovered node

				win.doc.addEventListener("touchstart", function(evt){
						lastTouch = (new Date()).getTime();

					// Precede touchstart event with touch.over event.  DnD depends on this.
					// Use addEventListener(cb, true) to run cb before any touchstart handlers on node run,
					// and to ensure this code runs even if the listener on the node does event.stop().
					var oldNode = hoveredNode;
					hoveredNode = evt.target;
					on.emit(oldNode, "dojotouchout", {
						relatedTarget: hoveredNode,
						bubbles: true
					});
					on.emit(hoveredNode, "dojotouchover", {
						relatedTarget: oldNode,
						bubbles: true
					});

					doClicks(evt, "touchmove", "touchend"); // init click generation
				}, true);

				function copyEventProps(evt){
					// Make copy of event object and also set bubbles:true.  Used when calling on.emit().
					var props = lang.delegate(evt, {
						bubbles: true
					});

					if(has("ios") >= 6){
						// On iOS6 "touches" became a non-enumerable property, which
						// is not hit by for...in.  Ditto for the other properties below.
						props.touches = evt.touches;
						props.altKey = evt.altKey;
						props.changedTouches = evt.changedTouches;
						props.ctrlKey = evt.ctrlKey;
						props.metaKey = evt.metaKey;
						props.shiftKey = evt.shiftKey;
						props.targetTouches = evt.targetTouches;
					}

					return props;
				}

				on(win.doc, "touchmove", function(evt){
					lastTouch = (new Date()).getTime();

					var newNode = win.doc.elementFromPoint(
						evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
						evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
					);

					if(newNode){
						// Fire synthetic touchover and touchout events on nodes since the browser won't do it natively.
						if(hoveredNode !== newNode){
							// touch out on the old node
							on.emit(hoveredNode, "dojotouchout", {
								relatedTarget: newNode,
								bubbles: true
							});

							// touchover on the new node
							on.emit(newNode, "dojotouchover", {
								relatedTarget: hoveredNode,
								bubbles: true
							});

							hoveredNode = newNode;
						}

						// Unlike a listener on "touchmove", on(node, "dojotouchmove", listener) fires when the finger
						// drags over the specified node, regardless of which node the touch started on.
						if(!on.emit(newNode, "dojotouchmove", copyEventProps(evt))){
							// emit returns false when synthetic event "dojotouchmove" is cancelled, so we prevent the
							// default behavior of the underlying native event "touchmove".
							evt.preventDefault();
						}
					}
				});

				// Fire a dojotouchend event on the node where the finger was before it was removed from the screen.
				// This is different than the native touchend, which fires on the node where the drag started.
				on(win.doc, "touchend", function(evt){
						lastTouch = (new Date()).getTime();
					var node = win.doc.elementFromPoint(
						evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
						evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
					) || win.body(); // if out of the screen

					on.emit(node, "dojotouchend", copyEventProps(evt));
				});
			});
		}
	}

	//device neutral events - touch.press|move|release|cancel/over/out
	var touch = {
		press: dualEvent("mousedown", "touchstart", pointer.down),
		move: dualEvent("mousemove", "dojotouchmove", pointer.move),
		release: dualEvent("mouseup", "dojotouchend", pointer.up),
		cancel: dualEvent(mouse.leave, "touchcancel", hasPointer ? pointer.cancel : null),
		over: dualEvent("mouseover", "dojotouchover", pointer.over),
		out: dualEvent("mouseout", "dojotouchout", pointer.out),
		enter: mouse._eventHandler(dualEvent("mouseover","dojotouchover", pointer.over)),
		leave: mouse._eventHandler(dualEvent("mouseout", "dojotouchout", pointer.out))
	};

	/*=====
	touch = {
		// summary:
		//		This module provides unified touch event handlers by exporting
		//		press, move, release and cancel which can also run well on desktop.
		//		Based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
		//      Also, if the dojoClick property is set to truthy on a DOM node, dojo/touch generates
		//      click events immediately for this node and its descendants (except for descendants that
		//      have a dojoClick property set to falsy), to avoid the delay before native browser click events,
		//      and regardless of whether evt.preventDefault() was called in a touch.press event listener.
		//
		// example:
		//		Used with dojo/on
		//		|	define(["dojo/on", "dojo/touch"], function(on, touch){
		//		|		on(node, touch.press, function(e){});
		//		|		on(node, touch.move, function(e){});
		//		|		on(node, touch.release, function(e){});
		//		|		on(node, touch.cancel, function(e){});
		// example:
		//		Used with touch.* directly
		//		|	touch.press(node, function(e){});
		//		|	touch.move(node, function(e){});
		//		|	touch.release(node, function(e){});
		//		|	touch.cancel(node, function(e){});
		// example:
		//		Have dojo/touch generate clicks without delay, with a default move threshold of 4 pixels
		//		|	node.dojoClick = true;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 10 pixels horizontally and vertically
		//		|	node.dojoClick = 10;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 50 pixels horizontally and 10 pixels vertically
		//		|	node.dojoClick = {x:50, y:5};
		// example:
		//		Disable clicks without delay generated by dojo/touch on a node that has an ancestor with property dojoClick set to truthy
		//		|  node.dojoClick = false;

		press: function(node, listener){
			// summary:
			//		Register a listener to 'touchstart'|'mousedown' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		move: function(node, listener){
			// summary:
			//		Register a listener that fires when the mouse cursor or a finger is dragged over the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		release: function(node, listener){
			// summary:
			//		Register a listener to releasing the mouse button while the cursor is over the given node
			//		(i.e. "mouseup") or for removing the finger from the screen while touching the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		cancel: function(node, listener){
			// summary:
			//		Register a listener to 'touchcancel'|'mouseleave' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		over: function(node, listener){
			// summary:
			//		Register a listener to 'mouseover' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		out: function(node, listener){
			// summary:
			//		Register a listener to 'mouseout' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		enter: function(node, listener){
			// summary:
			//		Register a listener to mouse.enter or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		leave: function(node, listener){
			// summary:
			//		Register a listener to mouse.leave or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		}
	};
	=====*/

	 1  && (dojo.touch = touch);

	return touch;
});

},
'ibm/tivoli/fwm/mxmap/_LatLonPoint':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */


define(["dojo/_base/declare"], 
		function(declare) {
	var _LatLonPoint =  declare(null, {

		lat: null,
		lon: null,
		lng: null, // lets be lon/lng agnostic
		sr: null,

		/**
		 * LatLonPoint is a point containing a latitude and longitude with helper
		 * methods
		 * 
		 * @name mxn.LatLonPoint
		 * @constructor
		 * @param {double}
		 *            lat is the latitude
		 * @param {double}
		 *            lon (or lng) is the longitude
		 * @param {int}
		 *            sr is the spatial reference, if any
		 */
		constructor: function(params)
		{
			// TODO error if undefined?
			// if (lat == undefined) alert('undefined lat');
			// if (lon == undefined) alert('undefined lon');
			dojo.mixin(this, params);
			if(params.lon != undefined && params.lon != null)
			{
				this.lng = params.lon; // lets be lon/lng agnostic
			} else if(params.lng != undefined && params.lng != null)
			{
				this.lon = params.lng; // lets be lon/lng agnostic
			}
			// TODO: Check to see if this Invoker is needed.
			//this.invoker = new mxn.Invoker(this, 'LatLonPoint');
		},


		/**
		 * Retrieve the lat and lon values from a proprietary point.
		 * 
		 * @name mxn.LatLonPoint#fromProprietary
		 * @function
		 * @param {String}
		 *            apiId The API ID of the proprietary point.
		 * @param {Object}
		 *            point The proprietary point.
		 */
		fromProprietary: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		/**
		 * Converts the current LatLonPoint to a proprietary one for the API
		 * specified by apiId.
		 * 
		 * @name mxn.LatLonPoint#toProprietary
		 * @function
		 * @param {String}
		 *            apiId The API ID of the proprietary point.
		 * @returns A proprietary point.
		 */
		toProprietary: function()
		{
			console.error("Method " + arguments.callee.nom + " be implemented by the derived class");
		},

		/**
		 * toString returns a string represntation of a point
		 * 
		 * @returns a string like '51.23, -0.123'
		 * @type String
		 */
		toString: function()
		{
			return this.lat + ', ' + this.lon;
		},
		isWGS84: function()
		{
			return this.sr == 4326;
		},
		/*
		 * LatLonPoint.prototype.toWGS84 = function(callback,errCallback){ //on most
		 * of the providers it's the same coordinate system try{
		 * this.invoker.go('toWGS84', arguments); }catch(e){ console.log("using
		 * default code for toWGS84"); callback(this); } };
		 */
		// LatLonPoint.prototype.fromWGS84 = function(callback,errCallback){
		// //on most of the providers it's the same coordinate system
		// try{
		// this.invoker.go('fromWGS84', arguments);
		// }catch(e){
		// console.log("using default code for fromWGS84");
		// callback(this);
		// }
		// };
		/**
		 * distance returns the distance in kilometers between two points
		 * 
		 * @param {LatLonPoint}
		 *            otherPoint The other point to measure the distance from to
		 *            this one
		 * @returns the distance between the points in kilometers
		 * @type double
		 */
		distance: function(otherPoint)
		{
			// Uses Haversine formula from http://www.movable-type.co.uk
			var rads = Math.PI / 180;
			var diffLat = (this.lat - otherPoint.lat) * rads;
			var diffLon = (this.lon - otherPoint.lon) * rads;
			var a = Math.sin(diffLat / 2) * Math.sin(diffLat / 2) + Math.cos(this.lat * rads) * Math.cos(otherPoint.lat * rads) * Math.sin(diffLon / 2) * Math.sin(diffLon / 2);
			return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) * 6371; // Earth's
			// mean
			// radius
			// in km
		},

		/**
		 * equals tests if this point is the same as some other one
		 * 
		 * @param {LatLonPoint}
		 *            otherPoint The other point to test with
		 * @returns true or false
		 * @type boolean
		 */
		equals: function(otherPoint)
		{
			return this.lat == otherPoint.lat && this.lon == otherPoint.lon;
		},

		/**
		 * Returns latitude conversion based on current projection
		 * 
		 * @returns {Float} conversion
		 */
		latConv: function()
		{
			return this.distance(new _LatLonPoint({lat: this.lat + 0.1, lon: this.lon})) * 10;
		},

		/**
		 * Returns longitude conversion based on current projection
		 * 
		 * @returns {Float} conversion
		 */
		lonConv: function()
		{
			return this.distance(new _LatLonPoint({lat: this.lat, lon: this.lon + 0.1})) * 10;
		}
	});
	
	return _LatLonPoint;
});

},
'ibm/tivoli/fwm/mxmap/InfoSummaryWidget':function(){
/* IBM Confidential
 *
 * OCO Source Materials
 *
 * 5724-U18, 5737-M66
 *
 * (C) COPYRIGHT IBM CORP. 2011,2024
 *
 * The source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright Office.
 */

define(["dojo/_base/declare",
	"ibm/tivoli/fwm/mxmap/_Base",
	"dijit/_Widget",
	"dijit/_Templated"],
	function(declare, _Base,_Widget, _Templated) {
	return declare([_Widget, _Templated], {
		templateString: dojo.cache("ibm.tivoli.fwm.mxmap", "templates/InfoSummaryWidget.html", "<div>\n<table style=\"height:35px;\">\n\t<tbody>\n\t\t<tr>\n\t\t\t<td style=\"width: 90%;\">\n\t\t\t\t<div dojoAttachPoint=\"infoSummary\"></div>\n\t\t\t</td>\n\t\t\t<td style=\"padding: 0px 4px 0px 12px; height: 35px;\">\n\t\t\t\t<div dojoAttachPoint=\"rightArrow\"></div>\n\t\t\t</td>\n\t\t</tr>\n\t</tbody>\n</table>\n</div>"),
		_openBubbleFunction: null,
		constructor:function(params)
		{
			dojo.mixin(this, params);				
		},
		postCreate:function()
		{	
			var me = this;
			this._setArrowIcon();
			// Defect 66953: Cannot use dojoAttachEvent in the html template to attach more than one event
			// to the same dojoAttachPoint (maybe a bug in dojo?), so the solution is to make 2 connections
			// for each dojoAttachPoint.
			// The "touchend" connections are for mobile devices
			dojo.connect(this.infoSummary, "click", function(evt)
					{
				me._executeMarkerOpenBubble();
					});
			dojo.connect(this.infoSummary, "touchend", function(evt)
					{
				me._executeMarkerOpenBubble();
					});
			dojo.connect(this.rightArrow, "click", function(evt)
					{
				me._executeMarkerOpenBubble();
					});
			dojo.connect(this.rightArrow, "touchend", function(evt)
					{
				me._executeMarkerOpenBubble();
					});

		},
		setContent:function(content)
		{
			if(typeof(content) == 'object'){
				this._setDomContent(content);
			}else{
				dojo.empty(this.infoSummary);
				dojo.create("div",{innerHTML:content},this.infoSummary);
			}
		},
		_setDomContent:function(domToAppend){
			dojo.place(domToAppend, this.infoSummary, "only");
		},
		// This method is executed whenever the section is clicked
		_executeMarkerOpenBubble: function()
		{
			if(this._openBubbleFunction)
			{
				this._openBubbleFunction();
			}
		},
		destroyRecursive: function()
		{
			this.inherited(arguments);
			if(this._arrowImageDom){
				dojo.destroy(this._arrowImageDom);
			}
		},
		_setArrowIcon: function()
		{
			var arrowIconURL = ibm.tivoli.fwm.mxmap.ImageLibraryManager.getImageLibraryManager().getLayerDetailsImageInfo().imageUrl;
			this._arrowImageDom = dojo.create("img",{src: arrowIconURL},this.rightArrow,"last");
		},
		// Set the specific marker openBubble function to be executed when this section is clicked
		setMarkerOpenBubbleFunction: function(openBubbleFunction)
		{
			this._openBubbleFunction = openBubbleFunction;
		}
	});
});		


},
'dojo/request':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	'./request/default!'/*=====,
	'./_base/declare',
	'./promise/Promise' =====*/
], function(request/*=====, declare, Promise =====*/){
	/*=====
	request = function(url, options){
		// summary:
		//		Send a request using the default transport for the current platform.
		// url: String
		//		The URL to request.
		// options: dojo/request.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.__Promise = declare(Promise, {
		// response: dojo/promise/Promise
		//		A promise resolving to an object representing
		//		the response from the server.
	});
	request.__BaseOptions = declare(null, {
		// query: String|Object?
		//		Query parameters to append to the URL.
		// data: String|Object?
		//		Data to transfer.  This is ignored for GET and DELETE
		//		requests.
		// preventCache: Boolean?
		//		Whether to append a cache-busting parameter to the URL.
		// timeout: Integer?
		//		Milliseconds to wait for the response.  If this time
		//		passes, the then the promise is rejected.
		// handleAs: String?
		//		How to handle the response from the server.  Default is
		//		'text'.  Other values are 'json', 'javascript', and 'xml'.
	});
	request.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request.  Must be
		//		uppercase.
	});
	request.__Options = declare([request.__BaseOptions, request.__MethodOptions]);

	request.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.put = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	return request;
});

},
'dijit/_DialogMixin':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"./a11y"	// _getTabNavigable
], function(declare, a11y){

	// module:
	//		dijit/_DialogMixin

	return declare("dijit._DialogMixin", null, {
		// summary:
		//		This provides functions useful to Dialog and TooltipDialog

		// actionBarTemplate: String
		//		HTML snippet to show the action bar (gray bar with OK/cancel buttons).
		//		Blank by default, but used by ConfirmDialog/ConfirmTooltipDialog subclasses.
		actionBarTemplate: "",

		execute: function(/*Object*/ /*===== formContents =====*/){
			// summary:
			//		Callback when the user hits the submit button.
			//		Override this method to handle Dialog execution.
			// description:
			//		After the user has pressed the submit button, the Dialog
			//		first calls onExecute() to notify the container to hide the
			//		dialog and restore focus to wherever it used to be.
			//
			//		*Then* this method is called.
			// type:
			//		callback
		},

		onCancel: function(){
			// summary:
			//		Called when user has pressed the Dialog's cancel button, to notify container.
			// description:
			//		Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit/form/DropDownButton`)
			// type:
			//		protected
		},

		onExecute: function(){
			// summary:
			//		Called when user has pressed the dialog's OK button, to notify container.
			// description:
			//		Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit/form/DropDownButton`)
			// type:
			//		protected
		},

		_onSubmit: function(){
			// summary:
			//		Callback when user hits submit button
			// type:
			//		protected
			this.onExecute();	// notify container that we are about to execute
			this.execute(this.get('value'));
		},

		_getFocusItems: function(){
			// summary:
			//		Finds focusable items in dialog,
			//		and sets this._firstFocusItem and this._lastFocusItem
			// tags:
			//		protected

			var elems = a11y._getTabNavigable(this.domNode);
			this._firstFocusItem = elems.lowest || elems.first || this.closeButtonNode || this.domNode;
			this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
		}
	});
});

},
'dijit/form/_FormValueWidget':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023,2024 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

define([
	"dojo/_base/declare", // declare
	"dojo/sniff", // has("ie")
	"./_FormWidget",
	"./_FormValueMixin"
], function(declare, has, _FormWidget, _FormValueMixin){

	// module:
	//		dijit/form/_FormValueWidget

	return declare("dijit.form._FormValueWidget", [_FormWidget, _FormValueMixin], {
		// summary:
		//		Base class for widgets corresponding to native HTML elements such as `<input>` or `<select>`
		//		that have user changeable values.
		// description:
		//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) `<input>` element,
		//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
		//		works as expected.

		// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
		// directly in the template as read by the parser in order to function. IE is known to specifically
		// require the 'name' attribute at element creation time.  See #8484, #8660.

		_layoutHackIE7: function(){
			// summary:
			//		Work around table sizing bugs on IE7 by forcing redraw

			if(has("ie") == 7){ // fix IE7 layout bug when the widget is scrolled out of sight
				var domNode = this.domNode;
				var parent = domNode.parentNode;
				var pingNode = domNode.firstChild || domNode; // target node most unlikely to have a custom filter
				var origFilter = pingNode.style.filter; // save custom filter, most likely nothing
				var _this = this;
				while(parent && parent.clientHeight == 0){ // search for parents that haven't rendered yet
					(function ping(){
						var disconnectHandle = _this.connect(parent, "onscroll",
							function(){
								_this.disconnect(disconnectHandle); // only call once
								pingNode.style.filter = (new Date()).getMilliseconds(); // set to anything that's unique
								_this.defer(function(){
									pingNode.style.filter = origFilter;
								}); // restore custom filter, if any
							}
						);
					})();
					parent = parent.parentNode;
				}
			}
		}
	});
});

},
'url:dijit/form/templates/Button.html':"<span class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\n\t\tdata-dojo-attach-event=\"ondijitclick:__onClick\" role=\"presentation\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode,focusNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\n\t\t\t></span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\"\n\t\tdata-dojo-attach-event=\"onclick:_onClick\"\n\t\ttabIndex=\"-1\" aria-hidden=\"true\" data-dojo-attach-point=\"valueNode\"\n/></span>\n",
'url:dijit/templates/MenuItem.html':"<tr class=\"dijitReset\" data-dojo-attach-point=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<span role=\"presentation\" class=\"dijitInline dijitIcon dijitMenuItemIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode,textDirNode\"\n\t\trole=\"presentation\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">\n\t\t<span data-dojo-attach-point=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<span class=\"dijitInline dijitIcon dijitMenuExpand\"></span>\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</span>\n\t</td>\n</tr>\n",
'url:dijit/form/templates/TextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n",
'url:dijit/form/templates/CheckBox.html':"<div class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><input\n\t \t${!nameAttrSetting} type=\"${type}\" role=\"${type}\" aria-checked=\"false\" ${checkedAttrSetting}\n\t\tclass=\"dijitReset dijitCheckBoxInput\"\n\t\tdata-dojo-attach-point=\"focusNode\"\n\t \tdata-dojo-attach-event=\"ondijitclick:_onClick\"\n/></div>\n",
'url:dijit/templates/CheckedMenuItem.html':"<tr class=\"dijitReset\" data-dojo-attach-point=\"focusNode\" role=\"${role}\" tabIndex=\"-1\" aria-checked=\"${checked}\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<span class=\"dijitInline dijitIcon dijitMenuItemIcon dijitCheckedMenuItemIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t\t<span class=\"dijitMenuItemIconChar dijitCheckedMenuItemIconChar\">${!checkedChar}</span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode,labelNode,textDirNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">&#160;</td>\n</tr>\n",
'url:dijit/form/templates/Select.html':"<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tdata-dojo-attach-point=\"_buttonNode,tableNode,focusNode,_popupStateNode\" cellspacing='0' cellpadding='0'\n\trole=\"listbox\" aria-haspopup=\"true\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonContents\" role=\"presentation\"\n\t\t\t><div class=\"dijitReset dijitInputField dijitButtonText\"  data-dojo-attach-point=\"containerNode,textDirNode\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitValidationContainer\"\n\t\t\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t/></div\n\t\t\t><input type=\"hidden\" ${!nameAttrSetting} data-dojo-attach-point=\"valueNode\" value=\"${value}\" aria-hidden=\"true\"\n\t\t/></td\n\t\t><td class=\"dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer\"\n\t\t\tdata-dojo-attach-point=\"titleNode\" role=\"presentation\"\n\t\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t\t${_buttonInputDisabled}\n\t\t/></td\n\t></tr></tbody\n></table>\n",
'url:dijit/templates/Menu.html':"<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\"\n\t   cellspacing=\"0\">\n\t<tbody class=\"dijitReset\" data-dojo-attach-point=\"containerNode\"></tbody>\n</table>\n",
'url:dijit/form/templates/DropDownButton.html':"<span class=\"dijit dijitReset dijitInline\"\n\t><span class='dijitReset dijitInline dijitButtonNode'\n\t\tdata-dojo-attach-event=\"ondijitclick:__onClick\" data-dojo-attach-point=\"_buttonNode\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"focusNode,titleNode,_arrowWrapperNode,_popupStateNode\"\n\t\t\trole=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\"\n\t\t\t\tdata-dojo-attach-point=\"iconNode\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\"></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onclick:_onClick\" data-dojo-attach-point=\"valueNode\" aria-hidden=\"true\"\n/></span>\n",
'url:dijit/templates/Tooltip.html':"<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\" data-dojo-attach-event=\"mouseenter:onMouseEnter,mouseleave:onMouseLeave\"\n\t><div class=\"dijitTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" data-dojo-attach-point=\"containerNode\" role='alert'></div\n></div>\n",
'url:dijit/form/templates/ComboButton.html':"<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tcellspacing='0' cellpadding='0' role=\"presentation\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonNode\" data-dojo-attach-point=\"buttonNode\" data-dojo-attach-event=\"ondijitclick:__onClick,onkeydown:_onButtonKeyDown\"\n\t\t><div id=\"${id}_button\" class=\"dijitReset dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><div class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" data-dojo-attach-point=\"containerNode\" role=\"presentation\"></div\n\t\t></div\n\t\t></td\n\t\t><td id=\"${id}_arrow\" class='dijitReset dijitRight dijitButtonNode dijitArrowButton'\n\t\t\tdata-dojo-attach-point=\"_popupStateNode,focusNode,_buttonNode\"\n\t\t\tdata-dojo-attach-event=\"onkeydown:_onArrowKeyDown\"\n\t\t\ttitle=\"${optionsTitle}\"\n\t\t\trole=\"button\" aria-haspopup=\"true\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" role=\"presentation\">&#9660;</div\n\t\t></td\n\t\t><td style=\"display:none !important;\"\n\t\t\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" data-dojo-attach-point=\"valueNode\"\n\t\t\t\tclass=\"dijitOffScreen\" aria-hidden=\"true\" data-dojo-attach-event=\"onclick:_onClick\"\n\t\t/></td></tr></tbody\n></table>\n",
'url:dijit/templates/Dialog.html':"<div class=\"dijitDialog\" role=\"dialog\" aria-labelledby=\"${id}_title\">\n\t<div data-dojo-attach-point=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t\t<span data-dojo-attach-point=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"\n\t\t\t\trole=\"heading\" level=\"1\"></span>\n\t\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabindex=\"-1\">\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t\t</span>\n\t</div>\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\n\t${!actionBarTemplate}\n</div>\n\n",
'url:dijit/templates/MenuSeparator.html':"<tr class=\"dijitMenuSeparator\" role=\"separator\">\n\t<td class=\"dijitMenuSeparatorIconCell\">\n\t\t<div class=\"dijitMenuSeparatorTop\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n\t<td colspan=\"3\" class=\"dijitMenuSeparatorLabelCell\">\n\t\t<div class=\"dijitMenuSeparatorTop dijitMenuSeparatorLabel\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n</tr>\n",
'*now':function(r){r(['dojo/i18n!*preload*layers/map/nls/mxmap*["ar","ca","cs","da","de","el","en","es","fi","fr","he","hr","hu","it","ja","kk","ko","nb","nl","pl","pt","pt-pt","ro","ru","sk","sl","sv","th","tr","zh","zh-tw","ROOT"]']);}
}});
define("layers/map/mxmap", [], 1);
