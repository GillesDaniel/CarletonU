/*
 * Licensed Materials - Property of IBM
 *
 * 5724-U18, 5737-M66
 *
 * (C) Copyright IBM Corp. 2023 All Rights Reserved
 *
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with
 * IBM Corp.
 */

import CommonUtil from './CommonUtil';
import { JSONDataAdapter, Page, Datasource, Application } from '@maximo/maximo-js-api';

import workorderitem from '../test/wo-detail-json-data.js';
import worLogItem from '../test/worklog-json-data.js';
import statusitem from '../test/statuses-json-data.js';
import defaultDs from '../test/defaultds_maxvars-json-data.js';
import testWoDetails from "../calibration/test/test-wodetails-data";
import testCalibrationData from "../calibration/test/test-calibration-data";
import sinon from "sinon";

function newStatusDatasource(data = defaultDs, name = 'defaultSetDs') {
    const da = new JSONDataAdapter({
        src: data,
        items: 'member',
    });
    const ds = new Datasource(da, {
        idAttribute: 'value',
        name: name
    });
    return ds;
}

function newSynonymDatasource(data = statusitem, name = 'synonymdomainData') {
    const da = new JSONDataAdapter({
        src: data,
        items: 'member',
        schema: 'responseInfo.schema'
    });

    const ds = new Datasource(da, {
        idAttribute: 'value',
        name: name
    });

    return ds;
}
function newDatasource(data = workorderitem, name = 'workorderds') {
    const da = new JSONDataAdapter({
        src: data,
        items: 'member',
        schema: 'responseInfo.schema'
    });

    const ds = new Datasource(da, {
        idAttribute: 'wonum',
        name: name
    });

    return ds;
}

function newDatasourceWorkLog(data = worLogItem, name = 'woWorklogDs') {
    const da = new JSONDataAdapter({
        src: worLogItem,
        items: 'member',
        schema: 'responseInfo.schema'
    });

    const ds = new Datasource(da, {
        name: name
    });

    return ds;
}

let systemProp = {
    "maximo.mobile.completestatus": "COMP",
    "maximo.mobile.statusforphysicalsignature": "COMP,CAN",
    "maximo.mobile.useTimer": "1",
    "maximo.mobile.radius": "0",
    "maximo.mobile.wostatusforesig": "INPRG"
}

describe('CommonUtil', () => {
    it('verify getSystemProp called', async () => {
        let app = {
            state: {
                systemProp: systemProp
            }
        };
        let propValue = await CommonUtil.getSystemProp(app, 'maximo.mobile.completestatus');
        expect(propValue).toBe('COMP');
    });

    it('verify checkSystemProp called', async () => {
        let app = {
            state: {
                systemProp: systemProp
            }
        };
        let propValueTrue = await CommonUtil.checkSystemProp(app, 'maximo.mobile.useTimer');
        expect(propValueTrue).toBe(true);
        let propValueFalse = await CommonUtil.checkSystemProp(app, 'maximo.mobile.radius');
        expect(propValueFalse).toBe(false);
    });

    it('verify checkSysPropArrExist called with return type false', async () => {
        let app = {
            state: {
                systemProp: systemProp
            }
        };
        let propValuePositive = await CommonUtil.checkSysPropArrExist(app, 'maximo.mobile.statusforphysicalsignature', 'CAN', false);
        expect(propValuePositive).toBe(1);
        let propValueNagative = await CommonUtil.checkSysPropArrExist(app, 'maximo.mobile.statusforphysicalsignature', 'INPR', false);
        expect(propValueNagative).toBe(0);
        let propValueTrue = await CommonUtil.checkSysPropArrExist(app, 'maximo.mobile.statusforphysicalsignature', 'CAN', true);
        expect(propValueTrue).toBe(true);
    });

    it('verify checkesig works as expected', async () => {
        const app = {
            state: {
                systemProp: systemProp
            }
        };
        let page = {
            state: {
                selectedStatus: "INPRG"
            }
        }
        let propValuePositive = await CommonUtil.checkEsigRequired(app, page);
        expect(propValuePositive).toBe(true);

        page.state.selectedStatus = "CAN";
        let propValueNagative = await CommonUtil.checkEsigRequired(app, page);
        expect(propValueNagative).toBe(false);
    });

    // Generated by WCA for GP
    it('Should Call checkScanRequired', async() => {
        let response = await CommonUtil.checkScanRequired("INPRG");
        expect(response).toBeTruthy();

        response = await CommonUtil.checkScanRequired("WAPR");
        expect(response).toBeFalsy();
    });

    it('verify mobilemaxvars works as expected', async () => {
        const app = new Application();
        
        const defDS = newStatusDatasource(defaultDs, 'defaultSetDs');
        app.registerDatasource(defDS);
        await defDS.load();
        
        const mobMaxVar = CommonUtil.filterMobileMaxvars("STARTTIMERINPRG", defDS);
        expect(mobMaxVar).toBeTruthy();
        expect(mobMaxVar.length).toBeGreaterThan(0);
        expect(mobMaxVar[0].varname).toBe("STARTTIMERINPRG");
        expect(mobMaxVar[0].varvalue).toBe("1");
    });

    it('should clear and reset the state of the provided data source', async () => {
    const mockDataSource = {
        clearState: jest.fn(),
        resetState: jest.fn()
      };
    await CommonUtil._resetDataSource(mockDataSource);
    expect(mockDataSource.clearState).toHaveBeenCalledTimes(1);
    expect(mockDataSource.resetState).toHaveBeenCalledTimes(1);
  });
});
it('verify open workLog works as expected', async () => {
    const app = new Application();
    const page = new Page({ name: 'page' });

    const ds = newDatasource(workorderitem, 'wodetails');
    const woWorklogDs = newDatasourceWorkLog(worLogItem, 'woWorklogDs');
    const synonymdomainDs = newSynonymDatasource(statusitem, 'synonymdomainData');
    page.registerDatasource(ds);
    page.registerDatasource(woWorklogDs);
    app.registerDatasource(synonymdomainDs);
    let items = await ds.load();

    await CommonUtil.openWorkLogDrawer(app, page, { 'item': items[1] }, woWorklogDs);
    expect(page.state.chatLogGroupData.length).toBe(1);
    expect(page.state.defaultLogType).toBe('!UPDATE!');
});

it('verify work log type filter based on orgId and siteId', async () => {
    const app = new Application();
    const page = new Page({ name: 'page' });
    const ds = newDatasource(workorderitem, 'wodetails');
    const woWorklogDs = newDatasourceWorkLog(worLogItem, 'woWorklogDs');
    const synonymdomainDs = newSynonymDatasource(statusitem, 'synonymdomainData');
    page.registerDatasource(ds);
    page.registerDatasource(woWorklogDs);
    app.registerDatasource(synonymdomainDs);
    const items = await ds.load();
    app.client = {
        userInfo: {
            insertOrg: 'EAGLENA',
            insertSite: 'BEDFORD'
        }
    }
    await CommonUtil.openWorkLogDrawer(app, page, { 'item': items[1] }, woWorklogDs);
    expect(synonymdomainDs.items.length).toBe(1);
    app.client = {
        userInfo: {
            insertOrg: '',
            insertSite: 'BEDFORD'
        }
    }
    await CommonUtil.openWorkLogDrawer(app, page, { 'item': items[1] }, woWorklogDs);
    expect(synonymdomainDs.items.length).toBe(1);
    app.client = {
        userInfo: {
            insertOrg: '',
            insertSite: ''
        }
    }
    await CommonUtil.openWorkLogDrawer(app, page, { 'item': items[1] }, woWorklogDs);
    expect(synonymdomainDs.items.length).toBe(1);
});


// Assisted by WCA for GP. Latest GenAI contribution: Version 1, granite-20B-code-instruct-v1 model
describe('canInteractWorkOrder', () => {
    it('should return true if the work order is accepted or rejected', () => {
        let item = {
            assignment: [
            {
                status: 'ACCEPTED'
            }
        ]};
        const app = {
            getChildDatasource: jest.fn(() => ({
                load: jest.fn(() => workorderitem),
                save: jest.fn(),
            })),
            state: {
                woOSName: 'security'
            },
            checkSigOption: (option) => true,
            getLocalizedLabel: jest.fn((key) => {
                if (key === 'Rejected') {
                    return 'REJECTED';
                } else {
                    return 'ACCEPTED';
                }
            })
        };
        expect(CommonUtil.canInteractWorkOrder(item, app)).toBe(true);
    });

   it('should return true if the work order status is completed', () => {
        const item = {
            status_maxvalue : 'COMP'
        };
        const app = {
            getChildDatasource: jest.fn(() => ({
                load: jest.fn(() => workorderitem),
                save: jest.fn(),
            })),
            state: {
                woOSName: 'security'
            },
            checkSigOption: (option) => true,
            getLocalizedLabel: jest.fn((key) => {
                if (key === 'Rejected') {
                    return 'REJECTED';
                } else {
                    return 'ACCEPTED';
                }
            })
        };
     
        expect(CommonUtil.canInteractWorkOrder(item, app)).toBe(true);

    });

    it('should return true if the work order status is approved', () => {
        const item = {
            status_maxvalue : 'APPR',
            assignment: [
                {
                    status: 'REJECTED'
                }
            ],
        };
        const app = {
            getChildDatasource: jest.fn(() => ({
                load: jest.fn(() => workorderitem),
                save: jest.fn(),
            })),
            state: {
                woOSName: 'security'
            },
            checkSigOption: (option) => true,
            getLocalizedLabel: jest.fn((key) => {
                if (key === 'Rejected') {
                    return 'REJECTED';
                } else {
                    return 'ACCEPTED';
                }
            })
        };
     
        expect(CommonUtil.canInteractWorkOrder(item, app)).toBe(false);
    });

    it('should return false if the work order is assigned or delivered', () => {
        let item = {
            assignment: [
            {
                status: 'ASSIGNED'
            }
            ]
        };
        const app = {
            getChildDatasource: jest.fn(() => ({
                load: jest.fn(() => workorderitem),
                save: jest.fn(),
            })),
            state: {
                woOSName: 'security'
            },
            checkSigOption: (option) => true,
            getLocalizedLabel: jest.fn((key) => {
                if (key === 'Rejected') {
                    return 'Rejected';
                } else {
                    return 'Accepted';
                }
            })
        };
        expect(CommonUtil.canInteractWorkOrder(item, app)).toBe(false);
        item = {
            assignment: [
            {
                status: 'Accepted'
            }
            ]
        };
        expect(CommonUtil.canInteractWorkOrder(item, app)).toBe(true);
    });

    it('should return false if no sigoption MANAGEASSIGNMENTSTATUS and vice versa', () => {
        const item = {
            assignment: [
            {
                status: 'ASSIGNED'
            }
            ]
        };
        const app = {
            getChildDatasource: jest.fn(() => ({
                load: jest.fn(() => workorderitem),
                save: jest.fn(),
            })),
            state: {
                woOSName: 'MANAGEASSIGNMENTSTATUS'
            },
            checkSigOption: (option) => false,
            getLocalizedLabel: jest.fn((key) => {
                if (key === 'Rejected') {
                    return 'Rejected';
                } else {
                    return 'Accepted';
                }
            })
        };
        expect(CommonUtil.canInteractWorkOrder(item, app)).toBe(true);

        app.checkSigOption = (option) => true;
        expect(CommonUtil.canInteractWorkOrder(item, app)).toBe(false);
    });
});
  
// Assisted by WCA for GP. Latest GenAI contribution: Version 1, granite-20B-code-instruct-v1 model
describe('markStatusAssigned', () => {
  it('should call api', async() => {
    const app = new Application();
        
    const event = {
        item: {
          assetnum: '1845',
          description: 'Pump10',
          wobyasset:[
            {
              description: 'HVAC overheating',
              status: 'WMATL',
              status_description: 'Waiting on material',
              status_maxvalue: 'WMATL',
              statusdate: '2021-03-09T16:08:51+05:30',
              wonum: '1228',
              worktype: 'CM',
              siteid: "BEDFORD"
            },
            {
              status_maxvalue: "WAPPR",
              status_description: "Waiting on approval",
              description: "[Auto - 634787] Work order with a description",
              worktype: "PM",
              wonum: "634787",
              status: "WAPPR",
              statusdate: "2021-08-09T13:08:57+05:30",
              siteid: "BEDFORD"
              },
              {
              status_maxvalue: "APPR",
              status_description: "Approved",
              description: "[Auto - 939232] Work order with a description",
              worktype: "PM",
              wonum: "939232",
              status: "APPR",
              statusdate: "2021-07-02T16:58:45+05:30",
              siteid: "BEDFORD"
              },
              {
              status_maxvalue: "CLOSE",
              status_description: "Waiting on approval",
              description: "Water on floor",
              wonum: "1131",
              status: "CLOSE",
              statusdate: "2004-10-06T15:30:34+05:30",
              siteid: "BEDFORD"
              }
          ]
        },
        invokeAction: jest.fn(),
        forceReload: jest.fn(),
        woNum: '634787'
    }
    let page = {
        state: {
            selectedStatus: "INPRG",
            loadingstatus: true
        }
    }
    const ds = {
        getChildDatasource: jest.fn(() => ({
            load: jest.fn(() => workorderitem.member[0].assignment),
            save: jest.fn(),
          })),
          forceReload: jest.fn(),
        getLocalizedLabel: jest.fn((key) => {
            if (key === 'Rejected') {
                return 'Rejected';
            } else {
                return 'Approved';
            }
        })
    }
    const callControllerSpy = jest.spyOn(event, "forceReload");
    await CommonUtil.markStatusAssigned(app,page,ds, event)
    expect(callControllerSpy).toBeCalled();
  });

});

it('should call api and reject work order', async() => {
    const app = new Application();
    let page = {
        state: {
            selectedStatus: "INPRG",
            loadingstatus: true
        }
    }
    const ds = {
        getChildDatasource: jest.fn(() => ({
            load: jest.fn(() => workorderitem.member[0].assignment),
            save: jest.fn(),
          })),
        getLocalizedLabel: jest.fn((key) => {
            if (key === 'Rejected') {
                return 'Rejected';
            } else {
                return 'Approved';
            }
        })
    }
    let wods = jest.spyOn(app, "findDatasource").mockImplementation(() => {
        return {
            data: workorderitem,
            initializeQbe: ()=>{},
            setQBE: (param1,params2)=>{},
            searchQBE: ()=> {return workorderitem.member},
            load: () => {},
            forceReload: () => {return workorderitem},
            getChildDatasource: jest.fn(() => ({
                load: jest.fn(() => workorderitem.member[0].assignment),
                save: jest.fn(),
              }))
        }
    });
    sinon.stub(app, "toast").callThrough();
    await CommonUtil.removeAssigned(app,page,ds)
    expect(wods).toBeCalled();
  });


it('Verify validateDataSheet method as expected', async() => {
    const app = new Application();
    const page = new Page({ name: 'page' });

    const calibration = newDatasource(testWoDetails, 'woDetailCalibration');
    calibration.load = jest.fn();
    const data = {...testCalibrationData};
    const assetFun1 = {...data.member[0]};
    assetFun1.required = true;
    assetFun1.asfoundcalstatus = "PASS";
    assetFun1.asfoundcalstatus_maxvalue = "PASS";
    assetFun1.asleftcalstatus = "PASS";
    assetFun1.asleftcalstatus_maxvalue = "PASS";
    const assetFun2 = {...data.member[0]};
    assetFun2.required = true;
    delete assetFun2.asfoundcalstatus_maxvalue;
    delete assetFun2.asleftcalstatus_maxvalue;
    const assetFun3 = {...data.member[0]};
    delete assetFun3.asfoundcalstatus_maxvalue;
    delete assetFun3.asleftcalstatus_maxvalue;
    assetFun3.required = true;
    data.member = [assetFun1, assetFun2, assetFun3];
    const datasheet = newDatasource(data, 'pluscWoDs');
    app.registerDatasource(calibration);
    app.registerDatasource(datasheet);
    const workorder = { wonum: '1200', href: 'abc' };
    const response = await CommonUtil.validateDataSheet(app, page, workorder, true);
    expect(response).toBe(true);
});

it('if event is stop or pause then only get geolocation', async() => {
    const app = new Application();
    await app.initialize({
        geolocation: {
            updateGeolocation: () => {return true}
        }
    });
    app.state = {
        systemProp: {
            'mxe.mobile.travel.prompt': '1',
        }
    };
    const callControllerSpy = jest.spyOn(app.geolocation, "updateGeolocation").mockImplementation(() => {
        return true
      });

    CommonUtil.callGeoLocation(app, 'start');
    expect(callControllerSpy).not.toBeCalled();

    CommonUtil.callGeoLocation(app, 'stop');
    expect(callControllerSpy).toBeCalled();
});

it('Verify validateActualTools method as expected', async() => {
    const app = new Application();
    const page = new Page({ name: 'page' });
    await app.initialize();
    app.showDialog = jest.fn();
    const workorder1 = { wonum: '1200', href: 'abc', pluscvaltool: '0', uxshowactualtool: ['a','b'] };
    let response = await CommonUtil.validateActualTools(app, page, workorder1);
    expect(response).toBe(true);
    const workorder2 = { wonum: '1200', href: 'abc', pluscvaltool: '2'};
    response = await CommonUtil.validateActualTools(app, page, workorder2);
    expect(response).toBe(false);
    const workorder3 = { wonum: '1200', href: 'abc', pluscvaltool: '1'};
    response = await CommonUtil.validateActualTools(app, page, workorder3);
    expect(response).toBe(false);
});
